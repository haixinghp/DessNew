
========================================================================

** ELF Header Information

    File Name: C:\Users\admin\Desktop\New_Architect_Project\RTL8762\board\evb\ota\Objects\app.axf

    Machine class: ELFCLASS32 (32-bit)
    Data encoding: ELFDATA2LSB (Little endian)
    Header version: EV_CURRENT (Current version)
    Operating System ABI: none
    ABI Version: 0
    File Type: ET_EXEC (Executable) (2)
    Machine: EM_ARM (ARM)

    Image Entry point: 0x0080e409
    Flags: EF_ARM_HASENTRY + EF_ARM_ABI_FLOAT_HARD (0x05000402)

    ARM ELF revision: 5 (ABI version 2)

    Conforms to Hard float procedure-call standard

    Built with
    Component: ARM Compiler 5.06 update 6 (build 750) Tool: armasm [4d35ec]
    Component: ARM Compiler 5.06 update 6 (build 750) Tool: armlink [4d35ed]

    Header size: 52 bytes (0x34)
    Program header entry size: 32 bytes (0x20)
    Section header entry size: 40 bytes (0x28)

    Program header entries: 3
    Section header entries: 22

    Program header offset: 385152 (0x0005e080)
    Section header offset: 385248 (0x0005e0e0)

    Section header string table index: 21

========================================================================

** Program header #0 (PT_LOAD) [PF_W + PF_R]
    Size : 4 bytes (0 bytes in file)
    Virtual address: 0x00200e54 (Alignment 4)


====================================

** Program header #1 (PT_LOAD) [PF_X + PF_W + PF_R + PF_ARM_ENTRY]
    Size : 17212 bytes (16716 bytes in file)
    Virtual address: 0x0080e000 (Alignment 4)


====================================

** Program header #2 (PT_LOAD) [PF_R]
    Size : 4876 bytes
    Virtual address: 0x08800000 (Alignment 4)


========================================================================

** Section #1 'app.bin' (SHT_PROGBITS) [SHF_ALLOC]
    Size   : 1024 bytes (alignment 4)
    Address: 0x0080e000

    0x80e000:   05 00 01 01 93 27 00 00 00 01 00 00 6d 67 de f1    .....'......mg..
    0x80e010:   3e 33 e8 11 b1 02 4d 2d f4 0c de 01 00 e4 80 00    >3....M-........
    0x80e020:   00 e4 80 00 00 00 00 00 00 e0 80 00 00 00 00 00    ................
    0x80e030:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e040:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e050:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e060:   21 20 00 08 50 43 46 1e 73 64 6b 23 23 23 23 23    ! ..PCF.sdk#####
    0x80e070:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e080:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e090:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0a0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0b0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0c0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0d0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0e0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e0f0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e100:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e110:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e120:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e130:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e140:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e150:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e160:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e170:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e180:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e190:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1a0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1b0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1c0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1d0:   00 00 00 00 00 00 00 00 01 d1 85 0e 88 15 81 00    ................
    0x80e1e0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e1f0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e200:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e210:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e220:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e230:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e240:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e250:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e260:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e270:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e280:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e290:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2a0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2b0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2c0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2d0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e2e0:   ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................
    0x80e2f0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e300:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e310:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e320:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e330:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e340:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e350:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e360:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e370:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e380:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e390:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3a0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3b0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3c0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3d0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3e0:   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
    0x80e3f0:   ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff    ................


** Section #2 'FLASH_START_ADDR' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 8 bytes (alignment 4)
    Address: 0x0080e400

    $t
    RESET
    $v0
    Reset_Handler
;;; ..\\..\\..\\src\\mcu\\rtl876x\\arm\\startup_rtl8762c.s
;;;96                     IMPORT SystemInit
;;;96                     LDR    R0, =SystemInit
        0x0080e400:    4800        .H      LDR      r0,[pc,#0] ; [0x80e404] = 0x80e5b1
;;;97                     BX     R0
        0x0080e402:    4700        .G      BX       r0
    $d
        0x0080e404:    0080e5b1    ....    DCD    8447409

** Section #3 'FLASH_TEXT' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 14916 bytes (alignment 4)
    Address: 0x0080e408

    $t
    !!!main
    __main
        0x0080e408:    f3af8000    ....    NOP.W    
        0x0080e40c:    f000f806    ....    BL       __rt_entry ; 0x80e41c
    .ARM.Collect$$libinit$$00000000
    __rt_lib_init
        0x0080e410:    b51f        ..      PUSH     {r0-r4,lr}
    .ARM.Collect$$libinit$$00000001
    __rt_lib_init_fp_1
        0x0080e412:    f003f8b3    ....    BL       _fp_init ; 0x81157c
    .ARM.Collect$$libinit$$00000004
    .ARM.Collect$$libinit$$0000000A
    .ARM.Collect$$libinit$$0000000C
    .ARM.Collect$$libinit$$0000000D
    __rt_lib_init_heap_1
    __rt_lib_init_preinit_1
    __rt_lib_init_rand_2
    __rt_lib_init_user_alloc_1
        0x0080e416:    f003f8a8    ....    BL       _rand_init ; 0x81156a
    .ARM.Collect$$libinit$$0000000E
    .ARM.Collect$$libinit$$00000011
    .ARM.Collect$$libinit$$00000013
    .ARM.Collect$$libinit$$00000015
    .ARM.Collect$$libinit$$00000017
    .ARM.Collect$$libinit$$00000019
    .ARM.Collect$$libinit$$0000001B
    .ARM.Collect$$libinit$$0000001D
    .ARM.Collect$$libinit$$0000001F
    .ARM.Collect$$libinit$$00000021
    .ARM.Collect$$libinit$$00000023
    .ARM.Collect$$libinit$$00000025
    .ARM.Collect$$libinit$$0000002C
    .ARM.Collect$$libinit$$0000002E
    .ARM.Collect$$libinit$$00000030
    .ARM.Collect$$libinit$$00000032
    .ARM.Collect$$libinit$$00000033
    __rt_lib_init_alloca_1
    __rt_lib_init_argv_1
    __rt_lib_init_atexit_1
    __rt_lib_init_clock_1
    __rt_lib_init_cpp_1
    __rt_lib_init_exceptions_1
    __rt_lib_init_fp_trap_1
    __rt_lib_init_getenv_1
    __rt_lib_init_lc_collate_1
    __rt_lib_init_lc_ctype_1
    __rt_lib_init_lc_monetary_1
    __rt_lib_init_lc_numeric_1
    __rt_lib_init_lc_time_1
    __rt_lib_init_rand_1
    __rt_lib_init_return
    __rt_lib_init_signal_1
    __rt_lib_init_stdio_1
        0x0080e41a:    bd1f        ..      POP      {r0-r4,pc}
    .ARM.Collect$$rtentry$$00000000
    .ARM.Collect$$rtentry$$00000002
    .ARM.Collect$$rtentry$$00000004
    __rt_entry
    __rt_entry_presh_1
    __rt_entry_sh
        0x0080e41c:    f000f9c0    ....    BL       __user_setup_stackheap ; 0x80e7a0
        0x0080e420:    4611        .F      MOV      r1,r2
    .ARM.Collect$$rtentry$$00000009
    .ARM.Collect$$rtentry$$0000000A
    __rt_entry_li
    __rt_entry_postsh_1
        0x0080e422:    f7fffff5    ....    BL       __rt_lib_init ; 0x80e410
    .ARM.Collect$$rtentry$$0000000C
    .ARM.Collect$$rtentry$$0000000D
    __rt_entry_main
    __rt_entry_postli_1
        0x0080e426:    f000fd34    ..4.    BL       main ; 0x80ee92
        0x0080e42a:    f44cf4fb    L...    BL       exit ; 0x5ae24
        0x0080e42e:    0000        ..      MOVS     r0,r0
    .app.flash.text
    ram_init
;;;459    {
        0x0080e430:    b510        ..      PUSH     {r4,lr}
;;;460    #if defined ( __CC_ARM   )
;;;461        //copy data on ro
;;;462        extern char Image$$RAM_DATA_ON$$RO$$Base[];
;;;463        extern char Load$$RAM_DATA_ON$$RO$$Base[];
;;;464        extern unsigned int Image$$RAM_DATA_ON$$RO$$Length;
;;;465    
;;;466        memcpy(Image$$RAM_DATA_ON$$RO$$Base,
        0x0080e432:    4aa1        .J      LDR      r2,[pc,#644] ; [0x80e6b8] = 0x150
        0x0080e434:    49a1        .I      LDR      r1,[pc,#644] ; [0x80e6bc] = 0x811f40
        0x0080e436:    48a2        .H      LDR      r0,[pc,#648] ; [0x80e6c0] = 0x207c00
        0x0080e438:    f44bf52f    K./.    BL       __aeabi_memcpy ; 0x59e9a
;;;467               Load$$RAM_DATA_ON$$RO$$Base,
;;;468               (unsigned int)&Image$$RAM_DATA_ON$$RO$$Length);
;;;469    
;;;470        //copy data on rw
;;;471        extern char Image$$RAM_DATA_ON$$RW$$Base[];
;;;472        extern char Load$$RAM_DATA_ON$$RW$$Base[];
;;;473        extern unsigned int Image$$RAM_DATA_ON$$RW$$Length;
;;;474    
;;;475        memcpy(Image$$RAM_DATA_ON$$RW$$Base,
        0x0080e43c:    4aa1        .J      LDR      r2,[pc,#644] ; [0x80e6c4] = 0xbc
        0x0080e43e:    49a2        .I      LDR      r1,[pc,#648] ; [0x80e6c8] = 0x812090
        0x0080e440:    48a2        .H      LDR      r0,[pc,#648] ; [0x80e6cc] = 0x207d50
        0x0080e442:    f44bf52a    K.*.    BL       __aeabi_memcpy ; 0x59e9a
;;;476               Load$$RAM_DATA_ON$$RW$$Base,
;;;477               (unsigned int)&Image$$RAM_DATA_ON$$RW$$Length);
;;;478    
;;;479        //clear data on zi
;;;480        extern char Image$$RAM_DATA_ON$$ZI$$Base[];
;;;481        extern unsigned int Image$$RAM_DATA_ON$$ZI$$Length;
;;;482    
;;;483        memset(Image$$RAM_DATA_ON$$ZI$$Base,
        0x0080e446:    49a2        .I      LDR      r1,[pc,#648] ; [0x80e6d0] = 0x1f0
        0x0080e448:    48a2        .H      LDR      r0,[pc,#648] ; [0x80e6d4] = 0x207e0c
        0x0080e44a:    f44bf5e7    K...    BL       __aeabi_memclr ; 0x5a01c
;;;484               0,
;;;485               (unsigned int)&Image$$RAM_DATA_ON$$ZI$$Length);
;;;486    
;;;487        //copy cache ro
;;;488        extern char Image$$CACHE_DATA_ON$$RO$$Base[];
;;;489        extern char Load$$CACHE_DATA_ON$$RO$$Base[];
;;;490        extern unsigned int Image$$CACHE_DATA_ON$$RO$$Length;
;;;491    
;;;492        memcpy(Image$$CACHE_DATA_ON$$RO$$Base,
        0x0080e44e:    4aa2        .J      LDR      r2,[pc,#648] ; [0x80e6d8] = 0
        0x0080e450:    49a2        .I      LDR      r1,[pc,#648] ; [0x80e6dc] = 0x81214c
        0x0080e452:    48a3        .H      LDR      r0,[pc,#652] ; [0x80e6e0] = 0x21c000
        0x0080e454:    f44bf521    K.!.    BL       __aeabi_memcpy ; 0x59e9a
;;;493               Load$$CACHE_DATA_ON$$RO$$Base,
;;;494               (unsigned int)&Image$$CACHE_DATA_ON$$RO$$Length);
;;;495    
;;;496        //copy share cache ram rw
;;;497        extern char Image$$CACHE_DATA_ON$$RW$$Base[];
;;;498        extern char Load$$CACHE_DATA_ON$$RW$$Base[];
;;;499        extern unsigned int Image$$CACHE_DATA_ON$$RW$$Length;
;;;500    
;;;501        memcpy(Image$$CACHE_DATA_ON$$RW$$Base,
        0x0080e458:    4aa2        .J      LDR      r2,[pc,#648] ; [0x80e6e4] = 0
        0x0080e45a:    49a3        .I      LDR      r1,[pc,#652] ; [0x80e6e8] = 0x81214c
        0x0080e45c:    48a3        .H      LDR      r0,[pc,#652] ; [0x80e6ec] = 0x21c000
        0x0080e45e:    f44bf51c    K...    BL       __aeabi_memcpy ; 0x59e9a
;;;502               Load$$CACHE_DATA_ON$$RW$$Base,
;;;503               (unsigned int)&Image$$CACHE_DATA_ON$$RW$$Length);
;;;504    
;;;505        //clear share cache ram zi
;;;506        extern char Image$$CACHE_DATA_ON$$ZI$$Base[];
;;;507        extern unsigned int Image$$CACHE_DATA_ON$$ZI$$Length;
;;;508    
;;;509        memset(Image$$CACHE_DATA_ON$$ZI$$Base,
        0x0080e462:    49a3        .I      LDR      r1,[pc,#652] ; [0x80e6f0] = 0
        0x0080e464:    48a3        .H      LDR      r0,[pc,#652] ; [0x80e6f4] = 0x21c000
        0x0080e466:    f44bf5d9    K...    BL       __aeabi_memclr ; 0x5a01c
;;;510               0,
;;;511               (unsigned int)&Image$$CACHE_DATA_ON$$ZI$$Length);
;;;512    #elif defined ( __GNUC__   )
;;;513        //copy data on rw
;;;514        extern uint32_t *__ram_dataon_rw_start__;
;;;515        extern uint32_t *__ram_rw_load_ad__;
;;;516        extern uint32_t *__ram_dataon_rw_length__;
;;;517    
;;;518        memcpy(&__ram_dataon_rw_start__,
;;;519               &__ram_rw_load_ad__,
;;;520               (unsigned int)&__ram_dataon_rw_length__);
;;;521    
;;;522        //clear data on zi
;;;523        extern uint32_t *__ram_dataon_zi_start__;
;;;524        extern uint32_t *__ram_dataon_zi_length__;
;;;525    
;;;526        memset(&__ram_dataon_zi_start__,
;;;527               0,
;;;528               (unsigned int)&__ram_dataon_zi_length__);
;;;529    
;;;530        //copy share cache ram rw
;;;531        extern uint32_t *__cache_dataon_start__;
;;;532        extern uint32_t *__cache_data_load_ad__;
;;;533        extern uint32_t *__cache_dataon_length__;
;;;534    
;;;535        memcpy(&__cache_dataon_start__,
;;;536               &__cache_data_load_ad__,
;;;537               (unsigned int)&__cache_dataon_length__);
;;;538    
;;;539        //clear share cache ram zi
;;;540    
;;;541    
;;;542    #endif
;;;543    }
        0x0080e46a:    bd10        ..      POP      {r4,pc}
    random_seed_init
;;;544    
;;;545    uint32_t random_seed_value;
;;;546    
;;;547    void random_seed_init(void) APP_FLASH_TEXT_SECTION;
;;;548    void random_seed_init(void)
;;;549    {
        0x0080e46c:    b57f        ..      PUSH     {r0-r6,lr}
;;;550        uint16_t crc16;
;;;551        uint8_t buf[DATA_SIZE_FOR_RANDOM_SEED];
;;;552        uint8_t *sour_addr = (uint8_t *)(OTP->appDataAddr + OTP->appDataSize + OTP->heapDataONSize);
        0x0080e46e:    48a2        .H      LDR      r0,[pc,#648] ; [0x80e6f8] = 0x200380
        0x0080e470:    6800        .h      LDR      r0,[r0,#0]
        0x0080e472:    f44f1100    O...    MOV      r1,#0x200000
        0x0080e476:    f8d11384    ....    LDR      r1,[r1,#0x384]
        0x0080e47a:    4408        .D      ADD      r0,r0,r1
        0x0080e47c:    499e        .I      LDR      r1,[pc,#632] ; [0x80e6f8] = 0x200380
        0x0080e47e:    3108        .1      ADDS     r1,r1,#8
        0x0080e480:    6809        .h      LDR      r1,[r1,#0]
        0x0080e482:    1845        E.      ADDS     r5,r0,r1
;;;553    
;;;554        memcpy(buf, sour_addr, DATA_SIZE_FOR_RANDOM_SEED);
        0x0080e484:    2210        ."      MOVS     r2,#0x10
        0x0080e486:    4629        )F      MOV      r1,r5
        0x0080e488:    4668        hF      MOV      r0,sp
        0x0080e48a:    f44bf506    K...    BL       __aeabi_memcpy ; 0x59e9a
;;;555        crc16 = btxfcs(0, buf, DATA_SIZE_FOR_RANDOM_SEED);
        0x0080e48e:    2210        ."      MOVS     r2,#0x10
        0x0080e490:    4669        iF      MOV      r1,sp
        0x0080e492:    2000        .       MOVS     r0,#0
        0x0080e494:    f7f8df9e    ....    BL       btxfcs ; 0x73d4
        0x0080e498:    4606        .F      MOV      r6,r0
;;;556    
;;;557        random_seed_value = (crc16 << 16) | (*(volatile uint32_t *)(0x4005817C) & 0xFFFF);
        0x0080e49a:    4898        .H      LDR      r0,[pc,#608] ; [0x80e6fc] = 0x40058000
        0x0080e49c:    f8d0017c    ..|.    LDR      r0,[r0,#0x17c]
        0x0080e4a0:    f366401f    f..@    BFI      r0,r6,#16,#16
        0x0080e4a4:    4996        .I      LDR      r1,[pc,#600] ; [0x80e700] = 0x207e1c
        0x0080e4a6:    6008        .`      STR      r0,[r1,#0]
;;;558    
;;;559        random_seed_value *= platform_random(0xFFFFFFFF);
        0x0080e4a8:    f04f30ff    O..0    MOV      r0,#0xffffffff
        0x0080e4ac:    f7f9d981    ....    BL       platform_random ; 0x77b2
        0x0080e4b0:    4993        .I      LDR      r1,[pc,#588] ; [0x80e700] = 0x207e1c
        0x0080e4b2:    6809        .h      LDR      r1,[r1,#0]
        0x0080e4b4:    4348        HC      MULS     r0,r1,r0
        0x0080e4b6:    4992        .I      LDR      r1,[pc,#584] ; [0x80e700] = 0x207e1c
        0x0080e4b8:    6008        .`      STR      r0,[r1,#0]
;;;560    
;;;561        srand(random_seed_value);
        0x0080e4ba:    4608        .F      MOV      r0,r1
        0x0080e4bc:    6800        .h      LDR      r0,[r0,#0]
        0x0080e4be:    f003f83f    ..?.    BL       srand ; 0x811540
;;;562    
;;;563        for (int i = 0; i < (DATA_SIZE_FOR_RANDOM_SEED / 4); ++i)
        0x0080e4c2:    2400        .$      MOVS     r4,#0
        0x0080e4c4:    e004        ..      B        0x80e4d0 ; random_seed_init + 100
        0x0080e4c6:    f000f949    ..I.    BL       rand ; 0x80e75c
        0x0080e4ca:    f8450024    E.$.    STR      r0,[r5,r4,LSL #2]
        0x0080e4ce:    1c64        d.      ADDS     r4,r4,#1
        0x0080e4d0:    2c04        .,      CMP      r4,#4
        0x0080e4d2:    dbf8        ..      BLT      0x80e4c6 ; random_seed_init + 90
;;;564        {
;;;565            *(uint32_t *)(sour_addr + i * 4) = rand();
;;;566        }
;;;567    
;;;568        random_seed_value = rand();
        0x0080e4d4:    f000f942    ..B.    BL       rand ; 0x80e75c
        0x0080e4d8:    4989        .I      LDR      r1,[pc,#548] ; [0x80e700] = 0x207e1c
        0x0080e4da:    6008        .`      STR      r0,[r1,#0]
;;;569    }
        0x0080e4dc:    bd7f        ..      POP      {r0-r6,pc}
    print_reset_reason
;;;570    
;;;571    #if DISABLE_FTL_REATURE
;;;572    bool patch_ftl_init_imp(uint32_t u32PageStartAddr, uint8_t pagenum) APP_FLASH_TEXT_SECTION;
;;;573    bool patch_ftl_init_imp(uint32_t u32PageStartAddr, uint8_t pagenum)
;;;574    {
;;;575        extern uint8_t g_PAGE_num;
;;;576        g_PAGE_num = 0;
;;;577    
;;;578        /*do nothing, not init ftl*/
;;;579        return true;
;;;580    }
;;;581    #endif
;;;582    
;;;583    #if defined ( __ICCARM__ )
;;;584    #if FEATURE_ENCRYPTION
;;;585    void SystemInit(void) APP_ENCRYPTION_TEXT_SECTION;
;;;586    #else
;;;587    void SystemInit(void) APP_FLASH_TEXT_SECTION;
;;;588    #endif
;;;589    #else
;;;590    void SystemInit(void) APP_FLASH_TEXT_SECTION;
;;;591    #endif
;;;592    void SystemInit(void)
;;;593    {
;;;594        //hci mode check and bypass app
;;;595        if (check_hci_mode_flag() || (OTP->stack_en == 0))
;;;596        {
;;;597            return;
;;;598        }
;;;599    
;;;600        //init pre_main and main functions
;;;601        extern void pre_main(void);
;;;602        app_pre_main = (APP_MAIN_FUNC)pre_main;
;;;603        app_main = (APP_MAIN_FUNC)common_main;
;;;604    
;;;605    #if DISABLE_FTL_REATURE
;;;606        extern BOOL_PATCH_FUNC patch_ftl_init;
;;;607        patch_ftl_init = patch_ftl_init_imp;
;;;608    #endif
;;;609    
;;;610    #if (ENABLE_WRITE_HARDFAULT_RECORD_TO_FLASH > 0) && (SYSTEM_TRACE_ENABLE == 1) && (TRACE_HARDFAULT == 1)
;;;611        patch_hardfault_save_to_flash_init();
;;;612    #endif
;;;613    
;;;614    #if (WRITE_REASON_TO_FLASH_BEFORE_RESET_ENABLE > 0) && (SYSTEM_TRACE_ENABLE == 1) && (TRACE_WDG_TIMEOUT == 1)
;;;615        patch_wdg_timeout_reason_save_to_flash_init();
;;;616    #endif
;;;617    
;;;618        /******** update otp here**********/
;;;619        //ram config
;;;620        OTP->appDataSize = APP_GLOBAL_SIZE;
;;;621        OTP->heapDataONSize = HEAP_DATA_ON_SIZE - DATA_SIZE_FOR_RANDOM_SEED;
;;;622    
;;;623        /* not share: SHARE_CACHE_RAM_0K; 8K: SHARE_CACHE_RAM_8K; 16K: SHARE_CACHE_RAM_16K */
;;;624    #if ((16 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;625        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_16K;
;;;626    #elif ((8 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;627        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_8K;
;;;628    #else
;;;629        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_0K;
;;;630    #endif
;;;631    
;;;632    #ifdef SUPPORT_SINGLE_BANK_OTA_USER_DATA
;;;633        OTP->bkp_data1_addr = USER_DATA_START_ADDR;
;;;634        OTP->bkp_data1_size = USER_DATA_MAX_SIZE;
;;;635    #if (DISABLE_AES_OTA == 1)
;;;636        OTP->ota_with_encryption_data = 0;
;;;637    #endif
;;;638    #endif
;;;639    
;;;640        //sw timer config
;;;641    #ifdef TIMER_MAX_NUMBER
;;;642        //define TIMER_MAX_NUMBER in otp_config.h
;;;643        OTP->timerMaxNumber = TIMER_MAX_NUMBER;
;;;644    #endif
;;;645    
;;;646        //flash config
;;;647        /*config enable flash block proect depending on flash layout and flash id*/
;;;648    #if (FLASH_BLOCK_PROTECT_ENABLE == 1)
;;;649        OTP->bp_enable = 1;
;;;650    #else
;;;651        OTP->bp_enable = 0;
;;;652    #endif
;;;653        OTP->delay_10us_after_toggle_cs = AFTER_TOGGLE_CS_DELAY;
;;;654    
;;;655        OTP->image_split_read = 0; //use flash auto mode to check image
;;;656    
;;;657        //os config
;;;658        /*config enable check task stack overflow*/
;;;659    #if (CHECK_STACK_OVERFLOW_ENABLE == 1)
;;;660        OTP->checkForStackOverflow = 1;
;;;661    #else
;;;662        OTP->checkForStackOverflow = 0;
;;;663    #endif
;;;664    
;;;665    
;;;666        //platform config
;;;667        /*config enable platform assert*/
;;;668    #if (PLATFORM_ASSERT_ENABLE == 1)
;;;669        OTP->enableASSERT = 1;
;;;670    #else
;;;671        OTP->enableASSERT = 0;
;;;672    #endif
;;;673    
;;;674        /*Print all log in log buffer before entering DLPS */
;;;675    #if (CHECK_LOG_BUFFER_BEFORE_DLPS_ENABLE == 1)
;;;676        OTP->printAllLogBeforeEnterDLPS = 1;
;;;677    #else
;;;678        OTP->printAllLogBeforeEnterDLPS = 0;
;;;679    #endif
;;;680    
;;;681        /*config enable log or not*/
;;;682    #if (CONFIG_LOG_FUNCTION_ENABLE == 1)
;;;683        OTP->logDisable = 0;
;;;684    #else
;;;685        OTP->logDisable = 1;
;;;686    #endif
;;;687    
;;;688        /*to fix bug need disable dump callstack info before WDG_SystemReset, default enable */
;;;689    #if (DUMP_INFO_BEFORE_RESET_DISABLE == 1)
;;;690        OTP->dump_info_before_reset = 0;
;;;691    #endif
;;;692    
;;;693        /*before wdg system reset, write reset reason to specific flash addr*/
;;;694    #if (WRITE_REASON_TO_FLASH_BEFORE_RESET_ENABLE > 0)
;;;695        OTP->write_reason_to_flash_before_reset = WRITE_REASON_TO_FLASH_BEFORE_RESET_ENABLE;
;;;696        OTP->reboot_reason_record_address = REBOOT_REASON_RECORD_ADDRESS;
;;;697        OTP->reboot_reason_record_limit_power_2 = REBOOT_REASON_RECORD_LIMIT_POWERT2;
;;;698    #endif
;;;699    
;;;700        /*config enable swd pinmux*/
;;;701    #if (SWD_PINMUX_ENABLE == 1)
;;;702        OTP->SWD_ENABLE = 1;
;;;703    #else
;;;704        OTP->SWD_ENABLE = 0;
;;;705    #endif
;;;706    
;;;707        /*config enable watch dog in rom*/
;;;708    #if (ROM_WATCH_DOG_ENABLE == 1)
;;;709        OTP->wdgEnableInRom = 1;
;;;710    #else
;;;711        OTP->wdgEnableInRom = 0;
;;;712    #endif
;;;713    
;;;714        /*config watch dog mode in rom, defualt 4s timeout and reset all*/
;;;715    #if (ROM_WATCH_DOG_ENABLE == 1)
;;;716        OTP->wdgConfigDivfactor = ROM_WATCH_DOG_CFG_DIV_FACTOR;
;;;717        OTP->wdgConfigCntLimit = ROM_WATCH_DOG_CFG_CNT_LIMIT;
;;;718        OTP->wdgMode = ROM_WATCH_DOG_MODE;
;;;719    #endif
;;;720    
;;;721        /*use os tick as log timestamp instead of TIM7*/
;;;722        OTP->log_timestamp_src = LOG_TIMESTAMP_OS;
;;;723    
;;;724    #if (XTAL_40M_DELAY_TIME > 0)
;;;725        /*Do not modify this setting unless you know what you are doing*/
;;;726        OTP->LOP_XTAL_delay = XTAL_40M_DELAY_TIME;
;;;727    #endif
;;;728    
;;;729        /*config enable write hardfault record to flash*/
;;;730    #if (ENABLE_WRITE_HARDFAULT_RECORD_TO_FLASH > 0)
;;;731        OTP->write_info_to_flash_when_hardfault = ENABLE_WRITE_HARDFAULT_RECORD_TO_FLASH;
;;;732        OTP->HardFault_Record_BegAddr = HARDFAULT_RECORD_BEG_ADDR;
;;;733        OTP->HardFault_Record_EndAddr = HARDFAULT_RECORD_END_ADDR;
;;;734        OTP->HardFault_Record_CFG = HARDFAULT_RECORD_CFG;
;;;735    #endif
;;;736    
;;;737    #if (ENABLE_FLASH_READ_TURN_OFF_RF > 0)
;;;738        OTP->read_turn_on_off_rf = ENABLE_FLASH_READ_TURN_OFF_RF;
;;;739    #endif
;;;740    
;;;741    #ifdef SDK_8772
;;;742    
;;;743    #if (USE_ALIOS == 0)
;;;744        OTP->UseAliOS = 0x0;
;;;745    #else
;;;746        OTP->UseAliOS = 0x1;
;;;747    #endif
;;;748    
;;;749    #endif
;;;750    
;;;751        //app config
;;;752        OTP->ota_timeout_total = OTA_TIMEOUT_TOTAL;
;;;753        OTP->ota_timeout_wait4_conn = OTA_TIMEOUT_WAIT4_CONN;
;;;754        OTP->ota_timeout_wait4_image_transfer = OTA_TIMEOUT_WAIT4_IMAGE_TRANS;
;;;755        OTP->ota_timeout_ctittv = OTA_TIMEOUT_CTITTV;
;;;756    
;;;757    #if ROM_OTA_LINKLOSS_RST
;;;758        OTP->ota_link_loss_reset = 1;
;;;759    #endif
;;;760        /*config bt stack parameters in rom*/
;;;761    #ifdef BT_STACK_CONFIG_ENABLE
;;;762        bt_stack_config_init();
;;;763    #endif
;;;764    
;;;765    #if defined ( __ICCARM__ )
;;;766        app_pre_main_cb = 0;
;;;767    #endif
;;;768    
;;;769    //add more otp config here
;;;770    }
;;;771    
;;;772    //Note: call print_reset_reason() before ram_init();
;;;773    #ifdef SDK_8772
;;;774    void print_reset_reason(void) APP_FLASH_TEXT_SECTION
;;;775    {
;;;776        T_SW_RESET_REASON sw_reset_type = reset_reason_get();
;;;777        if (sw_reset_type == RESET_REASON_HW)
;;;778        {
;;;779            BOOT_PRINT_INFO0("RESET Reason: HW");
;;;780        }
;;;781        else
;;;782        {
;;;783            BOOT_PRINT_INFO1("RESET Reason: SW, TYPE 0x%x", sw_reset_type);
;;;784        }
;;;785    }
;;;786    #else
;;;787    
;;;788    void print_reset_reason(void) APP_FLASH_TEXT_SECTION;
;;;789    void print_reset_reason(void)
;;;790    {
        0x0080e4de:    b510        ..      PUSH     {r4,lr}
;;;791        if (check_reset_ram.check_reset_ram_pattern != RESET_RAM_PATTERN)
        0x0080e4e0:    4888        .H      LDR      r0,[pc,#544] ; [0x80e704] = 0x207d50
        0x0080e4e2:    6800        .h      LDR      r0,[r0,#0]
        0x0080e4e4:    f020407f     ..@    BIC      r0,r0,#0xff000000
        0x0080e4e8:    4987        .I      LDR      r1,[pc,#540] ; [0x80e708] = 0x726574
        0x0080e4ea:    4288        .B      CMP      r0,r1
        0x0080e4ec:    d008        ..      BEQ      0x80e500 ; print_reset_reason + 34
;;;792        {
;;;793            BOOT_PRINT_INFO0("RESET Reason: HW or OTA");
        0x0080e4ee:    bf00        ..      NOP      
        0x0080e4f0:    bf00        ..      NOP      
        0x0080e4f2:    2200        ."      MOVS     r2,#0
        0x0080e4f4:    4985        .I      LDR      r1,[pc,#532] ; [0x80e70c] = 0x8800000
        0x0080e4f6:    4886        .H      LDR      r0,[pc,#536] ; [0x80e710] = 0x21100302
        0x0080e4f8:    f7f9dab1    ....    BL       log_buffer ; 0x7a5e
        0x0080e4fc:    bf00        ..      NOP      
        0x0080e4fe:    e020         .      B        0x80e542 ; print_reset_reason + 100
;;;794        }
;;;795        else
;;;796        {
;;;797            T_SW_RESET_REASON sw_reset_type = get_aon_record_reset_reason();
        0x0080e500:    bf00        ..      NOP      
;;; ..\..\..\inc\peripheral\rtl876x_wdg.h
;;;144        return (T_SW_RESET_REASON)flash_ioctl(flash_ioctl_get_aon_record_reset_reason, 0, 0);
        0x0080e502:    2200        ."      MOVS     r2,#0
        0x0080e504:    4611        .F      MOV      r1,r2
        0x0080e506:    f2450006    E...    MOV      r0,#0x5006
        0x0080e50a:    f7fdddb2    ....    BL       flash_ioctl ; 0xc072
        0x0080e50e:    b2c0        ..      UXTB     r0,r0
        0x0080e510:    4604        .F      MOV      r4,r0
;;; .\..\..\..\src\mcu\rtl876x\system_rtl8762c.c
;;;799            if (sw_reset_type != (T_SW_RESET_REASON)0)
        0x0080e512:    b14c        L.      CBZ      r4,0x80e528 ; print_reset_reason + 74
;;;800            {
;;;801                BOOT_PRINT_INFO1("RESET Reason: SW(reset except aon), TYPE 0x%x", sw_reset_type);
        0x0080e514:    bf00        ..      NOP      
        0x0080e516:    bf00        ..      NOP      
        0x0080e518:    4623        #F      MOV      r3,r4
        0x0080e51a:    2201        ."      MOVS     r2,#1
        0x0080e51c:    497d        }I      LDR      r1,[pc,#500] ; [0x80e714] = 0x880001c
        0x0080e51e:    487c        |H      LDR      r0,[pc,#496] ; [0x80e710] = 0x21100302
        0x0080e520:    f7f9da9d    ....    BL       log_buffer ; 0x7a5e
        0x0080e524:    bf00        ..      NOP      
        0x0080e526:    e00b        ..      B        0x80e540 ; print_reset_reason + 98
;;;802            }
;;;803            else //reset all will clear aon register
;;;804            {
;;;805                BOOT_PRINT_INFO1("RESET Reason: SW(reset all), TYPE 0x%x", check_reset_ram.check_reset_ram_type);
        0x0080e528:    bf00        ..      NOP      
        0x0080e52a:    bf00        ..      NOP      
        0x0080e52c:    4875        uH      LDR      r0,[pc,#468] ; [0x80e704] = 0x207d50
        0x0080e52e:    6800        .h      LDR      r0,[r0,#0]
        0x0080e530:    0e03        ..      LSRS     r3,r0,#24
        0x0080e532:    2201        ."      MOVS     r2,#1
        0x0080e534:    4978        xI      LDR      r1,[pc,#480] ; [0x80e718] = 0x8800050
        0x0080e536:    4876        vH      LDR      r0,[pc,#472] ; [0x80e710] = 0x21100302
        0x0080e538:    f7f9da91    ....    BL       log_buffer ; 0x7a5e
        0x0080e53c:    bf00        ..      NOP      
        0x0080e53e:    bf00        ..      NOP      
;;;806            }
;;;807        }
        0x0080e540:    bf00        ..      NOP      
;;;808    }
        0x0080e542:    bd10        ..      POP      {r4,pc}
    pre_main
;;;809    #endif
;;;810    
;;;811    void pre_main(void) APP_FLASH_TEXT_SECTION;
;;;812    void pre_main(void)
;;;813    {
        0x0080e544:    b538        8.      PUSH     {r3-r5,lr}
;;;814        __disable_irq();
        0x0080e546:    b672        r.      CPSID    i
;;;815    
;;;816        print_reset_reason();  //Note: call this function before ram_init();
        0x0080e548:    f7ffffc9    ....    BL       print_reset_reason ; 0x80e4de
;;;817    
;;;818        ram_init();
        0x0080e54c:    f7ffff70    ..p.    BL       ram_init ; 0x80e430
;;;819    
;;;820        random_seed_init();
        0x0080e550:    f7ffff8c    ....    BL       random_seed_init ; 0x80e46c
;;;821    
;;;822    #if defined ( __CC_ARM   )
;;;823        load_overlay(OVERLAY_SCENARIO_BOOT_ONCE);
        0x0080e554:    2000        .       MOVS     r0,#0
        0x0080e556:    f001f9c7    ....    BL       load_overlay ; 0x80f8e8
;;;824    #endif
;;;825    
;;;826        //reset NVIC of DMA channel used in image decryption
;;;827        NVIC_DisableIRQ(GDMA0_Channel2_IRQn);
        0x0080e55a:    2016        .       MOVS     r0,#0x16
        0x0080e55c:    f000fa6c    ..l.    BL       NVIC_DisableIRQ ; 0x80ea38
;;;828        NVIC_DisableIRQ(GDMA0_Channel3_IRQn);
        0x0080e560:    2017        .       MOVS     r0,#0x17
        0x0080e562:    f000fa69    ..i.    BL       NVIC_DisableIRQ ; 0x80ea38
;;;829    
;;;830    #if defined ( __CC_ARM   )
;;;831        setlocale(LC_ALL, "C");
        0x0080e566:    a16d        m.      ADR      r1,{pc}+0x1b6 ; 0x80e71c
        0x0080e568:    201f        .       MOVS     r0,#0x1f
        0x0080e56a:    f44bf443    K.C.    BL       setlocale ; 0x59df4
;;;832    #endif
;;;833    
;;;834        BOOT_PRINT_ERROR2("SDK Ver: %s, Build Time: %s",
        0x0080e56e:    bf00        ..      NOP      
        0x0080e570:    bf00        ..      NOP      
        0x0080e572:    a16b        k.      ADR      r1,{pc}+0x1ae ; 0x80e720
        0x0080e574:    f04f5005    O..P    MOV      r0,#0x21400000
        0x0080e578:    f7f9dc77    ..w.    BL       trace_string ; 0x7e6a
        0x0080e57c:    4604        .F      MOV      r4,r0
        0x0080e57e:    a16f        o.      ADR      r1,{pc}+0x1be ; 0x80e73c
        0x0080e580:    f04f5005    O..P    MOV      r0,#0x21400000
        0x0080e584:    f7f9dc71    ..q.    BL       trace_string ; 0x7e6a
        0x0080e588:    4605        .F      MOV      r5,r0
        0x0080e58a:    462b        +F      MOV      r3,r5
        0x0080e58c:    2202        ."      MOVS     r2,#2
        0x0080e58e:    496d        mI      LDR      r1,[pc,#436] ; [0x80e744] = 0x880007c
        0x0080e590:    485f        _H      LDR      r0,[pc,#380] ; [0x80e710] = 0x21100302
        0x0080e592:    1e80        ..      SUBS     r0,r0,#2
        0x0080e594:    9400        ..      STR      r4,[sp,#0]
        0x0080e596:    f7f9da62    ..b.    BL       log_buffer ; 0x7a5e
        0x0080e59a:    bf00        ..      NOP      
        0x0080e59c:    bf00        ..      NOP      
;;;835                          TRACE_STRING(VERSION_BUILD_STR),
;;;836                          TRACE_STRING(BUILDING_TIME));
;;;837    
;;;838        AppUpdateVectorTable();
        0x0080e59e:    f000f94d    ..M.    BL       AppUpdateVectorTable ; 0x80e83c
;;;839    
;;;840    #if (DEBUG_WATCHPOINT_ENABLE == 1)
;;;841        debug_monitor_enable();
;;;842    #endif
;;;843    
;;;844    #ifdef SDK_8772
;;;845        app_cb_wdg_reset = app_cb0_wdg_reset;
;;;846        app_cb_dfu_status = app_cb5_dfu_status;
;;;847    #endif
;;;848    
;;;849        if (app_pre_main_cb)
        0x0080e5a2:    4869        iH      LDR      r0,[pc,#420] ; [0x80e748] = 0x207d6c
        0x0080e5a4:    6800        .h      LDR      r0,[r0,#0]
        0x0080e5a6:    b110        ..      CBZ      r0,0x80e5ae ; pre_main + 106
;;;850        {
;;;851            app_pre_main_cb();
        0x0080e5a8:    4867        gH      LDR      r0,[pc,#412] ; [0x80e748] = 0x207d6c
        0x0080e5aa:    6800        .h      LDR      r0,[r0,#0]
        0x0080e5ac:    4780        .G      BLX      r0
;;;852        }
;;;853    
;;;854        return;
;;;855    }
        0x0080e5ae:    bd38        8.      POP      {r3-r5,pc}
    SystemInit
        0x0080e5b0:    b510        ..      PUSH     {r4,lr}
;;; .\..\..\..\src\mcu\rtl876x\system_rtl8762c.c (595)
        0x0080e5b2:    f7fed8d5    ....    BL       check_hci_mode_flag ; 0xc760
        0x0080e5b6:    b928        (.      CBNZ     r0,0x80e5c4 ; SystemInit + 20
        0x0080e5b8:    484f        OH      LDR      r0,[pc,#316] ; [0x80e6f8] = 0x200380
        0x0080e5ba:    38a4        .8      SUBS     r0,r0,#0xa4
        0x0080e5bc:    7800        .x      LDRB     r0,[r0,#0]
        0x0080e5be:    f0000001    ....    AND      r0,r0,#1
        0x0080e5c2:    b900        ..      CBNZ     r0,0x80e5c6 ; SystemInit + 22
        0x0080e5c4:    bd10        ..      POP      {r4,pc}
;;;596        {
;;;597            return;
;;;598        }
;;;599    
;;;600        //init pre_main and main functions
;;;601        extern void pre_main(void);
;;;602        app_pre_main = (APP_MAIN_FUNC)pre_main;
        0x0080e5c6:    f2af0083    ....    ADR      r0,{pc}-0x81 ; 0x80e545
        0x0080e5ca:    4960        `I      LDR      r1,[pc,#384] ; [0x80e74c] = 0x200c38
        0x0080e5cc:    6008        .`      STR      r0,[r1,#0]
;;;603        app_main = (APP_MAIN_FUNC)common_main;
        0x0080e5ce:    4860        `H      LDR      r0,[pc,#384] ; [0x80e750] = 0x80e7e1
        0x0080e5d0:    4960        `I      LDR      r1,[pc,#384] ; [0x80e754] = 0x200c3c
        0x0080e5d2:    6008        .`      STR      r0,[r1,#0]
;;;604    
;;;605    #if DISABLE_FTL_REATURE
;;;606        extern BOOL_PATCH_FUNC patch_ftl_init;
;;;607        patch_ftl_init = patch_ftl_init_imp;
;;;608    #endif
;;;609    
;;;610    #if (ENABLE_WRITE_HARDFAULT_RECORD_TO_FLASH > 0) && (SYSTEM_TRACE_ENABLE == 1) && (TRACE_HARDFAULT == 1)
;;;611        patch_hardfault_save_to_flash_init();
;;;612    #endif
;;;613    
;;;614    #if (WRITE_REASON_TO_FLASH_BEFORE_RESET_ENABLE > 0) && (SYSTEM_TRACE_ENABLE == 1) && (TRACE_WDG_TIMEOUT == 1)
;;;615        patch_wdg_timeout_reason_save_to_flash_init();
;;;616    #endif
;;;617    
;;;618        /******** update otp here**********/
;;;619        //ram config
;;;620        OTP->appDataSize = APP_GLOBAL_SIZE;
        0x0080e5d4:    f44f400c    O..@    MOV      r0,#0x8c00
        0x0080e5d8:    4947        GI      LDR      r1,[pc,#284] ; [0x80e6f8] = 0x200380
        0x0080e5da:    1d09        ..      ADDS     r1,r1,#4
        0x0080e5dc:    6008        .`      STR      r0,[r1,#0]
;;;621        OTP->heapDataONSize = HEAP_DATA_ON_SIZE - DATA_SIZE_FOR_RANDOM_SEED;
        0x0080e5de:    f24760f0    G..`    MOV      r0,#0x76f0
        0x0080e5e2:    f44f1100    O...    MOV      r1,#0x200000
        0x0080e5e6:    f8c10388    ....    STR      r0,[r1,#0x388]
;;;622    
;;;623        /* not share: SHARE_CACHE_RAM_0K; 8K: SHARE_CACHE_RAM_8K; 16K: SHARE_CACHE_RAM_16K */
;;;624    #if ((16 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;625        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_16K;
        0x0080e5ea:    485b        [H      LDR      r0,[pc,#364] ; [0x80e758] = 0xa2aa0003
        0x0080e5ec:    f8c103cc    ....    STR      r0,[r1,#0x3cc]
;;;626    #elif ((8 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;627        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_8K;
;;;628    #else
;;;629        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_0K;
;;;630    #endif
;;;631    
;;;632    #ifdef SUPPORT_SINGLE_BANK_OTA_USER_DATA
;;;633        OTP->bkp_data1_addr = USER_DATA_START_ADDR;
;;;634        OTP->bkp_data1_size = USER_DATA_MAX_SIZE;
;;;635    #if (DISABLE_AES_OTA == 1)
;;;636        OTP->ota_with_encryption_data = 0;
;;;637    #endif
;;;638    #endif
;;;639    
;;;640        //sw timer config
;;;641    #ifdef TIMER_MAX_NUMBER
;;;642        //define TIMER_MAX_NUMBER in otp_config.h
;;;643        OTP->timerMaxNumber = TIMER_MAX_NUMBER;
;;;644    #endif
;;;645    
;;;646        //flash config
;;;647        /*config enable flash block proect depending on flash layout and flash id*/
;;;648    #if (FLASH_BLOCK_PROTECT_ENABLE == 1)
;;;649        OTP->bp_enable = 1;
        0x0080e5f0:    4841        AH      LDR      r0,[pc,#260] ; [0x80e6f8] = 0x200380
        0x0080e5f2:    3833        38      SUBS     r0,r0,#0x33
        0x0080e5f4:    7800        .x      LDRB     r0,[r0,#0]
        0x0080e5f6:    f0200008     ...    BIC      r0,r0,#8
        0x0080e5fa:    3008        .0      ADDS     r0,r0,#8
        0x0080e5fc:    493e        >I      LDR      r1,[pc,#248] ; [0x80e6f8] = 0x200380
        0x0080e5fe:    3933        39      SUBS     r1,r1,#0x33
        0x0080e600:    7008        .p      STRB     r0,[r1,#0]
;;;650    #else
;;;651        OTP->bp_enable = 0;
;;;652    #endif
;;;653        OTP->delay_10us_after_toggle_cs = AFTER_TOGGLE_CS_DELAY;
        0x0080e602:    2006        .       MOVS     r0,#6
        0x0080e604:    f44f1100    O...    MOV      r1,#0x200000
        0x0080e608:    f881034f    ..O.    STRB     r0,[r1,#0x34f]
;;;654    
;;;655        OTP->image_split_read = 0; //use flash auto mode to check image
        0x0080e60c:    4608        .F      MOV      r0,r1
        0x0080e60e:    f890039a    ....    LDRB     r0,[r0,#0x39a]
        0x0080e612:    f0200020     . .    BIC      r0,r0,#0x20
        0x0080e616:    f881039a    ....    STRB     r0,[r1,#0x39a]
;;;656    
;;;657        //os config
;;;658        /*config enable check task stack overflow*/
;;;659    #if (CHECK_STACK_OVERFLOW_ENABLE == 1)
;;;660        OTP->checkForStackOverflow = 1;
        0x0080e61a:    4837        7H      LDR      r0,[pc,#220] ; [0x80e6f8] = 0x200380
        0x0080e61c:    3808        .8      SUBS     r0,r0,#8
        0x0080e61e:    7800        .x      LDRB     r0,[r0,#0]
        0x0080e620:    f0200002     ...    BIC      r0,r0,#2
        0x0080e624:    1c80        ..      ADDS     r0,r0,#2
        0x0080e626:    f8810378    ..x.    STRB     r0,[r1,#0x378]
;;;661    #else
;;;662        OTP->checkForStackOverflow = 0;
;;;663    #endif
;;;664    
;;;665    
;;;666        //platform config
;;;667        /*config enable platform assert*/
;;;668    #if (PLATFORM_ASSERT_ENABLE == 1)
;;;669        OTP->enableASSERT = 1;
        0x0080e62a:    4833        3H      LDR      r0,[pc,#204] ; [0x80e6f8] = 0x200380
        0x0080e62c:    3808        .8      SUBS     r0,r0,#8
        0x0080e62e:    7800        .x      LDRB     r0,[r0,#0]
        0x0080e630:    f0200020     . .    BIC      r0,r0,#0x20
        0x0080e634:    3020         0      ADDS     r0,r0,#0x20
        0x0080e636:    f8810378    ..x.    STRB     r0,[r1,#0x378]
;;;670    #else
;;;671        OTP->enableASSERT = 0;
;;;672    #endif
;;;673    
;;;674        /*Print all log in log buffer before entering DLPS */
;;;675    #if (CHECK_LOG_BUFFER_BEFORE_DLPS_ENABLE == 1)
;;;676        OTP->printAllLogBeforeEnterDLPS = 1;
        0x0080e63a:    482f        /H      LDR      r0,[pc,#188] ; [0x80e6f8] = 0x200380
        0x0080e63c:    3808        .8      SUBS     r0,r0,#8
        0x0080e63e:    7800        .x      LDRB     r0,[r0,#0]
        0x0080e640:    f0200004     ...    BIC      r0,r0,#4
        0x0080e644:    1d00        ..      ADDS     r0,r0,#4
        0x0080e646:    f8810378    ..x.    STRB     r0,[r1,#0x378]
;;;677    #else
;;;678        OTP->printAllLogBeforeEnterDLPS = 0;
;;;679    #endif
;;;680    
;;;681        /*config enable log or not*/
;;;682    #if (CONFIG_LOG_FUNCTION_ENABLE == 1)
;;;683        OTP->logDisable = 0;
        0x0080e64a:    4608        .F      MOV      r0,r1
        0x0080e64c:    f890039a    ....    LDRB     r0,[r0,#0x39a]
        0x0080e650:    f0200001     ...    BIC      r0,r0,#1
        0x0080e654:    f881039a    ....    STRB     r0,[r1,#0x39a]
;;;684    #else
;;;685        OTP->logDisable = 1;
;;;686    #endif
;;;687    
;;;688        /*to fix bug need disable dump callstack info before WDG_SystemReset, default enable */
;;;689    #if (DUMP_INFO_BEFORE_RESET_DISABLE == 1)
;;;690        OTP->dump_info_before_reset = 0;
;;;691    #endif
;;;692    
;;;693        /*before wdg system reset, write reset reason to specific flash addr*/
;;;694    #if (WRITE_REASON_TO_FLASH_BEFORE_RESET_ENABLE > 0)
;;;695        OTP->write_reason_to_flash_before_reset = WRITE_REASON_TO_FLASH_BEFORE_RESET_ENABLE;
;;;696        OTP->reboot_reason_record_address = REBOOT_REASON_RECORD_ADDRESS;
;;;697        OTP->reboot_reason_record_limit_power_2 = REBOOT_REASON_RECORD_LIMIT_POWERT2;
;;;698    #endif
;;;699    
;;;700        /*config enable swd pinmux*/
;;;701    #if (SWD_PINMUX_ENABLE == 1)
;;;702        OTP->SWD_ENABLE = 1;
        0x0080e658:    4827        'H      LDR      r0,[pc,#156] ; [0x80e6f8] = 0x200380
        0x0080e65a:    384c        L8      SUBS     r0,r0,#0x4c
        0x0080e65c:    7800        .x      LDRB     r0,[r0,#0]
        0x0080e65e:    f0200001     ...    BIC      r0,r0,#1
        0x0080e662:    1c40        @.      ADDS     r0,r0,#1
        0x0080e664:    f8810334    ..4.    STRB     r0,[r1,#0x334]
;;;703    #else
;;;704        OTP->SWD_ENABLE = 0;
;;;705    #endif
;;;706    
;;;707        /*config enable watch dog in rom*/
;;;708    #if (ROM_WATCH_DOG_ENABLE == 1)
;;;709        OTP->wdgEnableInRom = 1;
;;;710    #else
;;;711        OTP->wdgEnableInRom = 0;
        0x0080e668:    4608        .F      MOV      r0,r1
        0x0080e66a:    f890037a    ..z.    LDRB     r0,[r0,#0x37a]
        0x0080e66e:    f0200010     ...    BIC      r0,r0,#0x10
        0x0080e672:    f881037a    ..z.    STRB     r0,[r1,#0x37a]
;;;712    #endif
;;;713    
;;;714        /*config watch dog mode in rom, defualt 4s timeout and reset all*/
;;;715    #if (ROM_WATCH_DOG_ENABLE == 1)
;;;716        OTP->wdgConfigDivfactor = ROM_WATCH_DOG_CFG_DIV_FACTOR;
;;;717        OTP->wdgConfigCntLimit = ROM_WATCH_DOG_CFG_CNT_LIMIT;
;;;718        OTP->wdgMode = ROM_WATCH_DOG_MODE;
;;;719    #endif
;;;720    
;;;721        /*use os tick as log timestamp instead of TIM7*/
;;;722        OTP->log_timestamp_src = LOG_TIMESTAMP_OS;
        0x0080e676:    4608        .F      MOV      r0,r1
        0x0080e678:    f89003c3    ....    LDRB     r0,[r0,#0x3c3]
        0x0080e67c:    f02000c0     ...    BIC      r0,r0,#0xc0
        0x0080e680:    491d        .I      LDR      r1,[pc,#116] ; [0x80e6f8] = 0x200380
        0x0080e682:    3143        C1      ADDS     r1,r1,#0x43
        0x0080e684:    7008        .p      STRB     r0,[r1,#0]
;;;723    
;;;724    #if (XTAL_40M_DELAY_TIME > 0)
;;;725        /*Do not modify this setting unless you know what you are doing*/
;;;726        OTP->LOP_XTAL_delay = XTAL_40M_DELAY_TIME;
;;;727    #endif
;;;728    
;;;729        /*config enable write hardfault record to flash*/
;;;730    #if (ENABLE_WRITE_HARDFAULT_RECORD_TO_FLASH > 0)
;;;731        OTP->write_info_to_flash_when_hardfault = ENABLE_WRITE_HARDFAULT_RECORD_TO_FLASH;
;;;732        OTP->HardFault_Record_BegAddr = HARDFAULT_RECORD_BEG_ADDR;
;;;733        OTP->HardFault_Record_EndAddr = HARDFAULT_RECORD_END_ADDR;
;;;734        OTP->HardFault_Record_CFG = HARDFAULT_RECORD_CFG;
;;;735    #endif
;;;736    
;;;737    #if (ENABLE_FLASH_READ_TURN_OFF_RF > 0)
;;;738        OTP->read_turn_on_off_rf = ENABLE_FLASH_READ_TURN_OFF_RF;
;;;739    #endif
;;;740    
;;;741    #ifdef SDK_8772
;;;742    
;;;743    #if (USE_ALIOS == 0)
;;;744        OTP->UseAliOS = 0x0;
;;;745    #else
;;;746        OTP->UseAliOS = 0x1;
;;;747    #endif
;;;748    
;;;749    #endif
;;;750    
;;;751        //app config
;;;752        OTP->ota_timeout_total = OTA_TIMEOUT_TOTAL;
        0x0080e686:    20f0        .       MOVS     r0,#0xf0
        0x0080e688:    491b        .I      LDR      r1,[pc,#108] ; [0x80e6f8] = 0x200380
        0x0080e68a:    3960        `9      SUBS     r1,r1,#0x60
        0x0080e68c:    7008        .p      STRB     r0,[r1,#0]
;;;753        OTP->ota_timeout_wait4_conn = OTA_TIMEOUT_WAIT4_CONN;
        0x0080e68e:    203c        <       MOVS     r0,#0x3c
        0x0080e690:    1c49        I.      ADDS     r1,r1,#1
        0x0080e692:    7008        .p      STRB     r0,[r1,#0]
;;;754        OTP->ota_timeout_wait4_image_transfer = OTA_TIMEOUT_WAIT4_IMAGE_TRANS;
        0x0080e694:    20c8        .       MOVS     r0,#0xc8
        0x0080e696:    1c49        I.      ADDS     r1,r1,#1
        0x0080e698:    7008        .p      STRB     r0,[r1,#0]
;;;755        OTP->ota_timeout_ctittv = OTA_TIMEOUT_CTITTV;
        0x0080e69a:    20ff        .       MOVS     r0,#0xff
        0x0080e69c:    f44f1100    O...    MOV      r1,#0x200000
        0x0080e6a0:    f8810323    ..#.    STRB     r0,[r1,#0x323]
;;;756    
;;;757    #if ROM_OTA_LINKLOSS_RST
;;;758        OTP->ota_link_loss_reset = 1;
        0x0080e6a4:    4814        .H      LDR      r0,[pc,#80] ; [0x80e6f8] = 0x200380
        0x0080e6a6:    386b        k8      SUBS     r0,r0,#0x6b
        0x0080e6a8:    7800        .x      LDRB     r0,[r0,#0]
        0x0080e6aa:    f0200004     ...    BIC      r0,r0,#4
        0x0080e6ae:    1d00        ..      ADDS     r0,r0,#4
        0x0080e6b0:    f8810315    ....    STRB     r0,[r1,#0x315]
;;;759    #endif
;;;760        /*config bt stack parameters in rom*/
;;;761    #ifdef BT_STACK_CONFIG_ENABLE
;;;762        bt_stack_config_init();
;;;763    #endif
;;;764    
;;;765    #if defined ( __ICCARM__ )
;;;766        app_pre_main_cb = 0;
;;;767    #endif
;;;768    
;;;769    //add more otp config here
;;;770    }
        0x0080e6b4:    bf00        ..      NOP      
        0x0080e6b6:    e785        ..      B        0x80e5c4 ; SystemInit + 20
    $d
        0x0080e6b8:    00000150    P...    DCD    336
        0x0080e6bc:    00811f40    @...    DCD    8462144
        0x0080e6c0:    00207c00    .| .    DCD    2128896
        0x0080e6c4:    000000bc    ....    DCD    188
        0x0080e6c8:    00812090    . ..    DCD    8462480
        0x0080e6cc:    00207d50    P} .    DCD    2129232
        0x0080e6d0:    000001f0    ....    DCD    496
        0x0080e6d4:    00207e0c    .~ .    DCD    2129420
        0x0080e6d8:    00000000    ....    DCD    0
        0x0080e6dc:    0081214c    L!..    DCD    8462668
        0x0080e6e0:    0021c000    ..!.    DCD    2211840
        0x0080e6e4:    00000000    ....    DCD    0
        0x0080e6e8:    0081214c    L!..    DCD    8462668
        0x0080e6ec:    0021c000    ..!.    DCD    2211840
        0x0080e6f0:    00000000    ....    DCD    0
        0x0080e6f4:    0021c000    ..!.    DCD    2211840
        0x0080e6f8:    00200380    .. .    DCD    2098048
        0x0080e6fc:    40058000    ...@    DCD    1074102272
        0x0080e700:    00207e1c    .~ .    DCD    2129436
        0x0080e704:    00207d50    P} .    DCD    2129232
        0x0080e708:    00726574    ter.    DCD    7497076
        0x0080e70c:    08800000    ....    DCD    142606336
        0x0080e710:    21100302    ...!    DCD    554697474
        0x0080e714:    0880001c    ....    DCD    142606364
        0x0080e718:    08800050    P...    DCD    142606416
        0x0080e71c:    00000043    C...    DCD    67
        0x0080e720:    20756854    Thu     DCD    544565332
        0x0080e724:    2079614d    May     DCD    544825677
        0x0080e728:    31203720     7 1    DCD    824194848
        0x0080e72c:    37313a37    7:17    DCD    925973047
        0x0080e730:    2033313a    :13     DCD    540225850
        0x0080e734:    30323032    2020    DCD    808595506
        0x0080e738:    00000000    ....    DCD    0
        0x0080e73c:    2e322e31    1.2.    DCD    775040561
        0x0080e740:    00312e32    2.1.    DCD    3223090
        0x0080e744:    0880007c    |...    DCD    142606460
        0x0080e748:    00207d6c    l} .    DCD    2129260
        0x0080e74c:    00200c38    8. .    DCD    2100280
        0x0080e750:    0080e7e1    ....    DCD    8447969
        0x0080e754:    00200c3c    <. .    DCD    2100284
        0x0080e758:    a2aa0003    ....    DCD    2729050115
    $t
    .emb_text
    rand
        0x0080e75c:    490b        .I      LDR      r1,[pc,#44] ; [0x80e78c] = 0x207ff4
        0x0080e75e:    f8d1c000    ....    LDR      r12,[r1,#0]
        0x0080e762:    684a        Jh      LDR      r2,[r1,#4]
        0x0080e764:    f85c3b04    \..;    LDR      r3,[r12],#4
        0x0080e768:    6810        .h      LDR      r0,[r2,#0]
        0x0080e76a:    4418        .D      ADD      r0,r0,r3
        0x0080e76c:    f8420b04    B...    STR      r0,[r2],#4
        0x0080e770:    458c        .E      CMP      r12,r1
        0x0080e772:    bf28        (.      IT       CS
        0x0080e774:    f1a10cdc    ....    SUBCS    r12,r1,#0xdc
        0x0080e778:    428a        .B      CMP      r2,r1
        0x0080e77a:    bf28        (.      IT       CS
        0x0080e77c:    f1a102dc    ....    SUBCS    r2,r1,#0xdc
        0x0080e780:    f8c1c000    ....    STR      r12,[r1,#0]
        0x0080e784:    604a        J`      STR      r2,[r1,#4]
        0x0080e786:    f0204000     ..@    BIC      r0,r0,#0x80000000
        0x0080e78a:    4770        pG      BX       lr
    $d
        0x0080e78c:    00207ff4    .. .    DCD    2129908
    $t
    .text
    $v0
    ADC_Handler
    BTMAC_Handler
    BusFault_Handler
    DebugMon_Handler
    Default_Handler
    GDMA0_Channel0_Handler
    GDMA0_Channel1_Handler
    GDMA0_Channel2_Handler
    GDMA0_Channel3_Handler
    GDMA0_Channel4_Handler
    GDMA0_Channel5_Handler
    GPIO0_Handler
    GPIO10_Handler
    GPIO11_Handler
    GPIO12_Handler
    GPIO13_Handler
    GPIO14_Handler
    GPIO15_Handler
    GPIO16_Handler
    GPIO17_Handler
    GPIO18_Handler
    GPIO19_Handler
    GPIO1_Handler
    GPIO20_Handler
    GPIO21_Handler
    GPIO22_Handler
    GPIO23_Handler
    GPIO24_Handler
    GPIO25_Handler
    GPIO26_Handler
    GPIO27_Handler
    GPIO28_Handler
    GPIO29_Handler
    GPIO2_Handler
    GPIO30_Handler
    GPIO31_Handler
    GPIO3_Handler
    GPIO4_Handler
    GPIO5_Handler
    GPIO6_Handler
    GPIO7_Handler
    GPIO8_Handler
    GPIO9_Handler
    HardFault_Handler
    I2C0_Handler
    I2C1_Handler
    I2S0_RX_Handler
    I2S0_TX_Handler
    I2S1_RX_Handler
    I2S1_TX_Handler
    IR_Handler
    Keyscan_Handler
    LCD_Handler
    LPCOMP_Handler
    MemManage_Handler
    NMI_Handler
    PTA_Mailbox_Handler
    PendSV_Handler
    Peripheral_Handler
    Qdecode_Handler
    RTC_Handler
    SPI0_Handler
    SPI1_Handler
    SPI2W_Handler
    SPI_Flash_Handler
    SVC_Handler
    SysTick_Handler
    System_Handler
    Timer2_Handler
    Timer3_Handler
    Timer4_7_Handler
    Timer4_Handler
    Timer5_Handler
    Timer6_Handler
    Timer7_Handler
    UART0_Handler
    UART1_Handler
    UART2_Handler
    UsageFault_Handler
    WDG_Handler
;;; ..\\..\\..\\src\\mcu\\rtl876x\\arm\\startup_rtl8762c.s
;;;276                    LDR    R0, =0x20000000
        0x0080e790:    f04f5000    O..P    MOV      r0,#0x20000000
;;;277                    LDR    R1, =DEFAULT_HANDLER_TXT
        0x0080e794:    4910        .I      LDR      r1,[pc,#64] ; [0x80e7d8] = 0x80e7a2
;;;278                    MRS    R2, IPSR
        0x0080e796:    f3ef8205    ....    MRS      r2,IPSR
;;;279                    LDR    R3, =log_direct
        0x0080e79a:    4b10        .K      LDR      r3,[pc,#64] ; [0x80e7dc] = 0x79b1
;;;280                    BLX    R3
        0x0080e79c:    4798        .G      BLX      r3
;;;281                    B      .
        0x0080e79e:    e7fe        ..      B        0x80e79e ; ADC_Handler + 14
    __user_setup_stackheap
;;;282    
;;;283                    ENDP
;;;284    
;;;285    
;;;286    ; User Initial Stack
;;;287                    EXPORT  __user_setup_stackheap
;;;288    __user_setup_stackheap PROC
;;;289                    BX      LR
        0x0080e7a0:    4770        pG      BX       lr
    $d
    DEFAULT_HANDLER_TXT
        0x0080e7a2:    7245        Er      DCW    29253
        0x0080e7a4:    21726f72    ror!    DCD    561147762
        0x0080e7a8:    656c5020     Ple    DCD    1701597216
        0x0080e7ac:    20657361    ase     DCD    543519585
        0x0080e7b0:    6c706d69    impl    DCD    1819307369
        0x0080e7b4:    6e656d65    emen    DCD    1852140901
        0x0080e7b8:    6f792074    t yo    DCD    1870209140
        0x0080e7bc:    49207275    ur I    DCD    1226863221
        0x0080e7c0:    48205253    SR H    DCD    1210077779
        0x0080e7c4:    6c646e61    andl    DCD    1818521185
        0x0080e7c8:    66207265    er f    DCD    1713402469
        0x0080e7cc:    4920726f    or I    DCD    1226863215
        0x0080e7d0:    25205152    RQ %    DCD    622874962
        0x0080e7d4:    000a2164    d!..    DCD    663908
        0x0080e7d8:    0080e7a2    ....    DCD    8447906
        0x0080e7dc:    000079b1    .y..    DCD    31153
    $t
    .text
    common_main
;;; .\..\..\..\src\mcu\rtl876x\system_rtl8762c.c
;;;381    {
        0x0080e7e0:    b510        ..      PUSH     {r4,lr}
;;;382    //add common system code here before enter user defined main function
;;;383        OTP->run_in_app = 1;
        0x0080e7e2:    489a        .H      LDR      r0,[pc,#616] ; [0x80ea4c] = 0x20039b
        0x0080e7e4:    7800        .x      LDRB     r0,[r0,#0]
        0x0080e7e6:    f0200080     ...    BIC      r0,r0,#0x80
        0x0080e7ea:    3080        .0      ADDS     r0,r0,#0x80
        0x0080e7ec:    f44f1100    O...    MOV      r1,#0x200000
        0x0080e7f0:    f881039b    ....    STRB     r0,[r1,#0x39b]
;;;384    
;;;385    #if (RUN_APP_IN_HCIMODE_ENABLE == 0)
;;;386        if (OTP->stack_en)
        0x0080e7f4:    4895        .H      LDR      r0,[pc,#596] ; [0x80ea4c] = 0x20039b
        0x0080e7f6:    38bf        .8      SUBS     r0,r0,#0xbf
        0x0080e7f8:    7800        .x      LDRB     r0,[r0,#0]
        0x0080e7fa:    f0000001    ....    AND      r0,r0,#1
        0x0080e7fe:    b130        0.      CBZ      r0,0x80e80e ; common_main + 46
;;;387        {
;;;388            DBG_DIRECT("In SoC Mode");
        0x0080e800:    bf00        ..      NOP      
        0x0080e802:    a193        ..      ADR      r1,{pc}+0x24e ; 0x80ea50
        0x0080e804:    f04f5004    O..P    MOV      r0,#0x21000000
        0x0080e808:    f7f9d8d2    ....    BL       log_direct ; 0x79b0
        0x0080e80c:    e00a        ..      B        0x80e824 ; common_main + 68
;;;389        }
;;;390        else
;;;391        {
;;;392            DBG_DIRECT("WARNING: In HCI Mode, will not run APP Task");
        0x0080e80e:    bf00        ..      NOP      
        0x0080e810:    a192        ..      ADR      r1,{pc}+0x24c ; 0x80ea5c
        0x0080e812:    f04f5004    O..P    MOV      r0,#0x21000000
        0x0080e816:    f7f9d8cb    ....    BL       log_direct ; 0x79b0
        0x0080e81a:    bf00        ..      NOP      
;;;393            WDG_Disable();
        0x0080e81c:    f403f091    ....    BL       WDG_Disable ; 0x11942
;;;394            os_sched_start();
        0x0080e820:    f417f7cf    ....    BL       os_sched_start ; 0x267c2
;;;395        }
;;;396    #endif
;;;397    
;;;398        //fix system hang if app call log_module_trace_set after enable RELEASE_VERSION
;;;399        if (OTP->logDisable == 1)
        0x0080e824:    4889        .H      LDR      r0,[pc,#548] ; [0x80ea4c] = 0x20039b
        0x0080e826:    1e40        @.      SUBS     r0,r0,#1
        0x0080e828:    7800        .x      LDRB     r0,[r0,#0]
        0x0080e82a:    f0000001    ....    AND      r0,r0,#1
        0x0080e82e:    b110        ..      CBZ      r0,0x80e836 ; common_main + 86
;;;400        {
;;;401            log_module_trace_init(NULL);
        0x0080e830:    2000        .       MOVS     r0,#0
        0x0080e832:    f7f9dccf    ....    BL       log_module_trace_init ; 0x81d4
;;;402        }
;;;403    
;;;404    #if (SYSTEM_TRACE_ENABLE == 1)
;;;405        extern void system_trace_init(void);
;;;406        system_trace_init();
;;;407    #endif
;;;408    
;;;409    #if defined ( __ICCARM__ )
;;;410        extern void __iar_program_start(const int);
;;;411        __iar_program_start(0);
;;;412    #elif defined (__CC_ARM)
;;;413        extern int __main(void);
;;;414        __main();
        0x0080e836:    f7fffde7    ....    BL       __main ; 0x80e408
;;;415    #elif defined (__GNUC__)
;;;416        extern int main(void);
;;;417        main();
;;;418    #endif
;;;419    }
        0x0080e83a:    bd10        ..      POP      {r4,pc}
    AppUpdateVectorTable
;;;420    
;;;421    #if (DEBUG_WATCHPOINT_ENABLE == 1)
;;;422    /**
;;;423     * @brief  Enable Debug Monitor Function (include NVIC Enable and DWT configuration)
;;;424     * @param  none
;;;425     * @return none
;;;426     */
;;;427    
;;;428    void debug_monitor_enable(void) DATA_RAM_FUNCTION;
;;;429    void debug_monitor_enable(void)
;;;430    {
;;;431        //DBG_DIRECT("debug_monitor_enable");
;;;432    
;;;433        //set debug monitor priority
;;;434        NVIC_SetPriority(DebugMonitor_IRQn, 3);
;;;435    
;;;436        //enable exception and monitor control register
;;;437        CoreDebug->DEMCR |= CoreDebug_DEMCR_MON_EN_Msk | CoreDebug_DEMCR_TRCENA_Msk;
;;;438    
;;;439        //set DWT compare registers (max 4 comparators)
;;;440        //watch_point_0_setting(0x1000180C, DWT_DATAVSIZE_WORD, DWT_FUNCTION_WRITE);
;;;441        //watch_point_1_setting(0x10000004, DWT_DATAVSIZE_WORD, DWT_FUNCTION_READ_OR_WRITE);
;;;442        //watch_point_2_setting(0x10000008, DWT_DATAVSIZE_WORD, DWT_FUNCTION_READ_OR_WRITE);
;;;443        //watch_point_3_setting(0x1000000C, DWT_DATAVSIZE_WORD, DWT_FUNCTION_READ_OR_WRITE);
;;;444    
;;;445        //If use the following APIs, the start address shoule be aligned to the data size
;;;446        //watch_point_0_setting_align(0x201000, DWT_DATASIZE_ALIGN_4_BYTE, DWT_FUNCTION_READ);
;;;447        //watch_point_1_setting_align(0x201008, DWT_DATASIZE_ALIGN_8_BYTE, DWT_FUNCTION_WRITE);
;;;448        //watch_point_2_setting_align(0x201010, DWT_DATASIZE_ALIGN_16_BYTE, DWT_FUNCTION_READ_OR_WRITE);
;;;449        //watch_point_3_setting_align(0x201020, DWT_DATASIZE_ALIGN_32_BYTE, DWT_FUNCTION_READ_OR_WRITE);
;;;450    
;;;451        //enable DWT control register
;;;452        DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
;;;453    
;;;454        return;
;;;455    }
;;;456    #endif
;;;457    void ram_init(void) APP_FLASH_TEXT_SECTION;
;;;458    void ram_init(void)
;;;459    {
;;;460    #if defined ( __CC_ARM   )
;;;461        //copy data on ro
;;;462        extern char Image$$RAM_DATA_ON$$RO$$Base[];
;;;463        extern char Load$$RAM_DATA_ON$$RO$$Base[];
;;;464        extern unsigned int Image$$RAM_DATA_ON$$RO$$Length;
;;;465    
;;;466        memcpy(Image$$RAM_DATA_ON$$RO$$Base,
;;;467               Load$$RAM_DATA_ON$$RO$$Base,
;;;468               (unsigned int)&Image$$RAM_DATA_ON$$RO$$Length);
;;;469    
;;;470        //copy data on rw
;;;471        extern char Image$$RAM_DATA_ON$$RW$$Base[];
;;;472        extern char Load$$RAM_DATA_ON$$RW$$Base[];
;;;473        extern unsigned int Image$$RAM_DATA_ON$$RW$$Length;
;;;474    
;;;475        memcpy(Image$$RAM_DATA_ON$$RW$$Base,
;;;476               Load$$RAM_DATA_ON$$RW$$Base,
;;;477               (unsigned int)&Image$$RAM_DATA_ON$$RW$$Length);
;;;478    
;;;479        //clear data on zi
;;;480        extern char Image$$RAM_DATA_ON$$ZI$$Base[];
;;;481        extern unsigned int Image$$RAM_DATA_ON$$ZI$$Length;
;;;482    
;;;483        memset(Image$$RAM_DATA_ON$$ZI$$Base,
;;;484               0,
;;;485               (unsigned int)&Image$$RAM_DATA_ON$$ZI$$Length);
;;;486    
;;;487        //copy cache ro
;;;488        extern char Image$$CACHE_DATA_ON$$RO$$Base[];
;;;489        extern char Load$$CACHE_DATA_ON$$RO$$Base[];
;;;490        extern unsigned int Image$$CACHE_DATA_ON$$RO$$Length;
;;;491    
;;;492        memcpy(Image$$CACHE_DATA_ON$$RO$$Base,
;;;493               Load$$CACHE_DATA_ON$$RO$$Base,
;;;494               (unsigned int)&Image$$CACHE_DATA_ON$$RO$$Length);
;;;495    
;;;496        //copy share cache ram rw
;;;497        extern char Image$$CACHE_DATA_ON$$RW$$Base[];
;;;498        extern char Load$$CACHE_DATA_ON$$RW$$Base[];
;;;499        extern unsigned int Image$$CACHE_DATA_ON$$RW$$Length;
;;;500    
;;;501        memcpy(Image$$CACHE_DATA_ON$$RW$$Base,
;;;502               Load$$CACHE_DATA_ON$$RW$$Base,
;;;503               (unsigned int)&Image$$CACHE_DATA_ON$$RW$$Length);
;;;504    
;;;505        //clear share cache ram zi
;;;506        extern char Image$$CACHE_DATA_ON$$ZI$$Base[];
;;;507        extern unsigned int Image$$CACHE_DATA_ON$$ZI$$Length;
;;;508    
;;;509        memset(Image$$CACHE_DATA_ON$$ZI$$Base,
;;;510               0,
;;;511               (unsigned int)&Image$$CACHE_DATA_ON$$ZI$$Length);
;;;512    #elif defined ( __GNUC__   )
;;;513        //copy data on rw
;;;514        extern uint32_t *__ram_dataon_rw_start__;
;;;515        extern uint32_t *__ram_rw_load_ad__;
;;;516        extern uint32_t *__ram_dataon_rw_length__;
;;;517    
;;;518        memcpy(&__ram_dataon_rw_start__,
;;;519               &__ram_rw_load_ad__,
;;;520               (unsigned int)&__ram_dataon_rw_length__);
;;;521    
;;;522        //clear data on zi
;;;523        extern uint32_t *__ram_dataon_zi_start__;
;;;524        extern uint32_t *__ram_dataon_zi_length__;
;;;525    
;;;526        memset(&__ram_dataon_zi_start__,
;;;527               0,
;;;528               (unsigned int)&__ram_dataon_zi_length__);
;;;529    
;;;530        //copy share cache ram rw
;;;531        extern uint32_t *__cache_dataon_start__;
;;;532        extern uint32_t *__cache_data_load_ad__;
;;;533        extern uint32_t *__cache_dataon_length__;
;;;534    
;;;535        memcpy(&__cache_dataon_start__,
;;;536               &__cache_data_load_ad__,
;;;537               (unsigned int)&__cache_dataon_length__);
;;;538    
;;;539        //clear share cache ram zi
;;;540    
;;;541    
;;;542    #endif
;;;543    }
;;;544    
;;;545    uint32_t random_seed_value;
;;;546    
;;;547    void random_seed_init(void) APP_FLASH_TEXT_SECTION;
;;;548    void random_seed_init(void)
;;;549    {
;;;550        uint16_t crc16;
;;;551        uint8_t buf[DATA_SIZE_FOR_RANDOM_SEED];
;;;552        uint8_t *sour_addr = (uint8_t *)(OTP->appDataAddr + OTP->appDataSize + OTP->heapDataONSize);
;;;553    
;;;554        memcpy(buf, sour_addr, DATA_SIZE_FOR_RANDOM_SEED);
;;;555        crc16 = btxfcs(0, buf, DATA_SIZE_FOR_RANDOM_SEED);
;;;556    
;;;557        random_seed_value = (crc16 << 16) | (*(volatile uint32_t *)(0x4005817C) & 0xFFFF);
;;;558    
;;;559        random_seed_value *= platform_random(0xFFFFFFFF);
;;;560    
;;;561        srand(random_seed_value);
;;;562    
;;;563        for (int i = 0; i < (DATA_SIZE_FOR_RANDOM_SEED / 4); ++i)
;;;564        {
;;;565            *(uint32_t *)(sour_addr + i * 4) = rand();
;;;566        }
;;;567    
;;;568        random_seed_value = rand();
;;;569    }
;;;570    
;;;571    #if DISABLE_FTL_REATURE
;;;572    bool patch_ftl_init_imp(uint32_t u32PageStartAddr, uint8_t pagenum) APP_FLASH_TEXT_SECTION;
;;;573    bool patch_ftl_init_imp(uint32_t u32PageStartAddr, uint8_t pagenum)
;;;574    {
;;;575        extern uint8_t g_PAGE_num;
;;;576        g_PAGE_num = 0;
;;;577    
;;;578        /*do nothing, not init ftl*/
;;;579        return true;
;;;580    }
;;;581    #endif
;;;582    
;;;583    #if defined ( __ICCARM__ )
;;;584    #if FEATURE_ENCRYPTION
;;;585    void SystemInit(void) APP_ENCRYPTION_TEXT_SECTION;
;;;586    #else
;;;587    void SystemInit(void) APP_FLASH_TEXT_SECTION;
;;;588    #endif
;;;589    #else
;;;590    void SystemInit(void) APP_FLASH_TEXT_SECTION;
;;;591    #endif
;;;592    void SystemInit(void)
;;;593    {
;;;594        //hci mode check and bypass app
;;;595        if (check_hci_mode_flag() || (OTP->stack_en == 0))
;;;596        {
;;;597            return;
;;;598        }
;;;599    
;;;600        //init pre_main and main functions
;;;601        extern void pre_main(void);
;;;602        app_pre_main = (APP_MAIN_FUNC)pre_main;
;;;603        app_main = (APP_MAIN_FUNC)common_main;
;;;604    
;;;605    #if DISABLE_FTL_REATURE
;;;606        extern BOOL_PATCH_FUNC patch_ftl_init;
;;;607        patch_ftl_init = patch_ftl_init_imp;
;;;608    #endif
;;;609    
;;;610    #if (ENABLE_WRITE_HARDFAULT_RECORD_TO_FLASH > 0) && (SYSTEM_TRACE_ENABLE == 1) && (TRACE_HARDFAULT == 1)
;;;611        patch_hardfault_save_to_flash_init();
;;;612    #endif
;;;613    
;;;614    #if (WRITE_REASON_TO_FLASH_BEFORE_RESET_ENABLE > 0) && (SYSTEM_TRACE_ENABLE == 1) && (TRACE_WDG_TIMEOUT == 1)
;;;615        patch_wdg_timeout_reason_save_to_flash_init();
;;;616    #endif
;;;617    
;;;618        /******** update otp here**********/
;;;619        //ram config
;;;620        OTP->appDataSize = APP_GLOBAL_SIZE;
;;;621        OTP->heapDataONSize = HEAP_DATA_ON_SIZE - DATA_SIZE_FOR_RANDOM_SEED;
;;;622    
;;;623        /* not share: SHARE_CACHE_RAM_0K; 8K: SHARE_CACHE_RAM_8K; 16K: SHARE_CACHE_RAM_16K */
;;;624    #if ((16 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;625        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_16K;
;;;626    #elif ((8 * 1024) == SHARE_CACHE_RAM_SIZE)
;;;627        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_8K;
;;;628    #else
;;;629        OTP->share_cache_ram_reg = SHARE_CACHE_RAM_0K;
;;;630    #endif
;;;631    
;;;632    #ifdef SUPPORT_SINGLE_BANK_OTA_USER_DATA
;;;633        OTP->bkp_data1_addr = USER_DATA_START_ADDR;
;;;634        OTP->bkp_data1_size = USER_DATA_MAX_SIZE;
;;;635    #if (DISABLE_AES_OTA == 1)
;;;636        OTP->ota_with_encryption_data = 0;
;;;637    #endif
;;;638    #endif
;;;639    
;;;640        //sw timer config
;;;641    #ifdef TIMER_MAX_NUMBER
;;;642        //define TIMER_MAX_NUMBER in otp_config.h
;;;643        OTP->timerMaxNumber = TIMER_MAX_NUMBER;
;;;644    #endif
;;;645    
;;;646        //flash config
;;;647        /*config enable flash block proect depending on flash layout and flash id*/
;;;648    #if (FLASH_BLOCK_PROTECT_ENABLE == 1)
;;;649        OTP->bp_enable = 1;
;;;650    #else
;;;651        OTP->bp_enable = 0;
;;;652    #endif
;;;653        OTP->delay_10us_after_toggle_cs = AFTER_TOGGLE_CS_DELAY;
;;;654    
;;;655        OTP->image_split_read = 0; //use flash auto mode to check image
;;;656    
;;;657        //os config
;;;658        /*config enable check task stack overflow*/
;;;659    #if (CHECK_STACK_OVERFLOW_ENABLE == 1)
;;;660        OTP->checkForStackOverflow = 1;
;;;661    #else
;;;662        OTP->checkForStackOverflow = 0;
;;;663    #endif
;;;664    
;;;665    
;;;666        //platform config
;;;667        /*config enable platform assert*/
;;;668    #if (PLATFORM_ASSERT_ENABLE == 1)
;;;669        OTP->enableASSERT = 1;
;;;670    #else
;;;671        OTP->enableASSERT = 0;
;;;672    #endif
;;;673    
;;;674        /*Print all log in log buffer before entering DLPS */
;;;675    #if (CHECK_LOG_BUFFER_BEFORE_DLPS_ENABLE == 1)
;;;676        OTP->printAllLogBeforeEnterDLPS = 1;
;;;677    #else
;;;678        OTP->printAllLogBeforeEnterDLPS = 0;
;;;679    #endif
;;;680    
;;;681        /*config enable log or not*/
;;;682    #if (CONFIG_LOG_FUNCTION_ENABLE == 1)
;;;683        OTP->logDisable = 0;
;;;684    #else
;;;685        OTP->logDisable = 1;
;;;686    #endif
;;;687    
;;;688        /*to fix bug need disable dump callstack info before WDG_SystemReset, default enable */
;;;689    #if (DUMP_INFO_BEFORE_RESET_DISABLE == 1)
;;;690        OTP->dump_info_before_reset = 0;
;;;691    #endif
;;;692    
;;;693        /*before wdg system reset, write reset reason to specific flash addr*/
;;;694    #if (WRITE_REASON_TO_FLASH_BEFORE_RESET_ENABLE > 0)
;;;695        OTP->write_reason_to_flash_before_reset = WRITE_REASON_TO_FLASH_BEFORE_RESET_ENABLE;
;;;696        OTP->reboot_reason_record_address = REBOOT_REASON_RECORD_ADDRESS;
;;;697        OTP->reboot_reason_record_limit_power_2 = REBOOT_REASON_RECORD_LIMIT_POWERT2;
;;;698    #endif
;;;699    
;;;700        /*config enable swd pinmux*/
;;;701    #if (SWD_PINMUX_ENABLE == 1)
;;;702        OTP->SWD_ENABLE = 1;
;;;703    #else
;;;704        OTP->SWD_ENABLE = 0;
;;;705    #endif
;;;706    
;;;707        /*config enable watch dog in rom*/
;;;708    #if (ROM_WATCH_DOG_ENABLE == 1)
;;;709        OTP->wdgEnableInRom = 1;
;;;710    #else
;;;711        OTP->wdgEnableInRom = 0;
;;;712    #endif
;;;713    
;;;714        /*config watch dog mode in rom, defualt 4s timeout and reset all*/
;;;715    #if (ROM_WATCH_DOG_ENABLE == 1)
;;;716        OTP->wdgConfigDivfactor = ROM_WATCH_DOG_CFG_DIV_FACTOR;
;;;717        OTP->wdgConfigCntLimit = ROM_WATCH_DOG_CFG_CNT_LIMIT;
;;;718        OTP->wdgMode = ROM_WATCH_DOG_MODE;
;;;719    #endif
;;;720    
;;;721        /*use os tick as log timestamp instead of TIM7*/
;;;722        OTP->log_timestamp_src = LOG_TIMESTAMP_OS;
;;;723    
;;;724    #if (XTAL_40M_DELAY_TIME > 0)
;;;725        /*Do not modify this setting unless you know what you are doing*/
;;;726        OTP->LOP_XTAL_delay = XTAL_40M_DELAY_TIME;
;;;727    #endif
;;;728    
;;;729        /*config enable write hardfault record to flash*/
;;;730    #if (ENABLE_WRITE_HARDFAULT_RECORD_TO_FLASH > 0)
;;;731        OTP->write_info_to_flash_when_hardfault = ENABLE_WRITE_HARDFAULT_RECORD_TO_FLASH;
;;;732        OTP->HardFault_Record_BegAddr = HARDFAULT_RECORD_BEG_ADDR;
;;;733        OTP->HardFault_Record_EndAddr = HARDFAULT_RECORD_END_ADDR;
;;;734        OTP->HardFault_Record_CFG = HARDFAULT_RECORD_CFG;
;;;735    #endif
;;;736    
;;;737    #if (ENABLE_FLASH_READ_TURN_OFF_RF > 0)
;;;738        OTP->read_turn_on_off_rf = ENABLE_FLASH_READ_TURN_OFF_RF;
;;;739    #endif
;;;740    
;;;741    #ifdef SDK_8772
;;;742    
;;;743    #if (USE_ALIOS == 0)
;;;744        OTP->UseAliOS = 0x0;
;;;745    #else
;;;746        OTP->UseAliOS = 0x1;
;;;747    #endif
;;;748    
;;;749    #endif
;;;750    
;;;751        //app config
;;;752        OTP->ota_timeout_total = OTA_TIMEOUT_TOTAL;
;;;753        OTP->ota_timeout_wait4_conn = OTA_TIMEOUT_WAIT4_CONN;
;;;754        OTP->ota_timeout_wait4_image_transfer = OTA_TIMEOUT_WAIT4_IMAGE_TRANS;
;;;755        OTP->ota_timeout_ctittv = OTA_TIMEOUT_CTITTV;
;;;756    
;;;757    #if ROM_OTA_LINKLOSS_RST
;;;758        OTP->ota_link_loss_reset = 1;
;;;759    #endif
;;;760        /*config bt stack parameters in rom*/
;;;761    #ifdef BT_STACK_CONFIG_ENABLE
;;;762        bt_stack_config_init();
;;;763    #endif
;;;764    
;;;765    #if defined ( __ICCARM__ )
;;;766        app_pre_main_cb = 0;
;;;767    #endif
;;;768    
;;;769    //add more otp config here
;;;770    }
;;;771    
;;;772    //Note: call print_reset_reason() before ram_init();
;;;773    #ifdef SDK_8772
;;;774    void print_reset_reason(void) APP_FLASH_TEXT_SECTION
;;;775    {
;;;776        T_SW_RESET_REASON sw_reset_type = reset_reason_get();
;;;777        if (sw_reset_type == RESET_REASON_HW)
;;;778        {
;;;779            BOOT_PRINT_INFO0("RESET Reason: HW");
;;;780        }
;;;781        else
;;;782        {
;;;783            BOOT_PRINT_INFO1("RESET Reason: SW, TYPE 0x%x", sw_reset_type);
;;;784        }
;;;785    }
;;;786    #else
;;;787    
;;;788    void print_reset_reason(void) APP_FLASH_TEXT_SECTION;
;;;789    void print_reset_reason(void)
;;;790    {
;;;791        if (check_reset_ram.check_reset_ram_pattern != RESET_RAM_PATTERN)
;;;792        {
;;;793            BOOT_PRINT_INFO0("RESET Reason: HW or OTA");
;;;794        }
;;;795        else
;;;796        {
;;;797            T_SW_RESET_REASON sw_reset_type = get_aon_record_reset_reason();
;;;798    
;;;799            if (sw_reset_type != (T_SW_RESET_REASON)0)
;;;800            {
;;;801                BOOT_PRINT_INFO1("RESET Reason: SW(reset except aon), TYPE 0x%x", sw_reset_type);
;;;802            }
;;;803            else //reset all will clear aon register
;;;804            {
;;;805                BOOT_PRINT_INFO1("RESET Reason: SW(reset all), TYPE 0x%x", check_reset_ram.check_reset_ram_type);
;;;806            }
;;;807        }
;;;808    }
;;;809    #endif
;;;810    
;;;811    void pre_main(void) APP_FLASH_TEXT_SECTION;
;;;812    void pre_main(void)
;;;813    {
;;;814        __disable_irq();
;;;815    
;;;816        print_reset_reason();  //Note: call this function before ram_init();
;;;817    
;;;818        ram_init();
;;;819    
;;;820        random_seed_init();
;;;821    
;;;822    #if defined ( __CC_ARM   )
;;;823        load_overlay(OVERLAY_SCENARIO_BOOT_ONCE);
;;;824    #endif
;;;825    
;;;826        //reset NVIC of DMA channel used in image decryption
;;;827        NVIC_DisableIRQ(GDMA0_Channel2_IRQn);
;;;828        NVIC_DisableIRQ(GDMA0_Channel3_IRQn);
;;;829    
;;;830    #if defined ( __CC_ARM   )
;;;831        setlocale(LC_ALL, "C");
;;;832    #endif
;;;833    
;;;834        BOOT_PRINT_ERROR2("SDK Ver: %s, Build Time: %s",
;;;835                          TRACE_STRING(VERSION_BUILD_STR),
;;;836                          TRACE_STRING(BUILDING_TIME));
;;;837    
;;;838        AppUpdateVectorTable();
;;;839    
;;;840    #if (DEBUG_WATCHPOINT_ENABLE == 1)
;;;841        debug_monitor_enable();
;;;842    #endif
;;;843    
;;;844    #ifdef SDK_8772
;;;845        app_cb_wdg_reset = app_cb0_wdg_reset;
;;;846        app_cb_dfu_status = app_cb5_dfu_status;
;;;847    #endif
;;;848    
;;;849        if (app_pre_main_cb)
;;;850        {
;;;851            app_pre_main_cb();
;;;852        }
;;;853    
;;;854        return;
;;;855    }
;;;856    /**
;;;857     * @brief  update vector table in app
;;;858     * @param  none
;;;859     * @return none
;;;860      */
;;;861    
;;;862    //static void AppUpdateVectorTable(void) OVERLAY_SECTION_BOOT_ONCE;
;;;863    static void AppUpdateVectorTable(void)
;;;864    {
        0x0080e83c:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x0080e840:    b0be        ..      SUB      sp,sp,#0xf8
;;;865    #if defined ( __CC_ARM )
;;;866        extern uint32_t Load$$RAM_VECTOR_TABLE$$RO$$Base;
;;;867        extern uint32_t Image$$RAM_VECTOR_TABLE$$RO$$Length;
;;;868    #elif defined ( __GNUC__ )
;;;869        extern uint32_t *__ram_vector_load_ad__;
;;;870        extern uint32_t *__ram_vector_table_length__;
;;;871    #endif
;;;872        extern void Default_Handler(void);
;;;873        const char *SysException[] =
        0x0080e842:    2240        @"      MOVS     r2,#0x40
        0x0080e844:    4990        .I      LDR      r1,[pc,#576] ; [0x80ea88] = 0x8115ac
        0x0080e846:    a82e        ..      ADD      r0,sp,#0xb8
        0x0080e848:    f44bf3ae    K...    BL       __aeabi_memcpy4 ; 0x59fa8
;;;874        {
;;;875            "InitialSP", "Reset", "NMI", "HardFault", "MemManage", "BusFault", "UsageFault", "Rsvd",
;;;876            "Rsvd", "Rsvd", "Rsvd", "SVC", "DebugMon", "Rsvd", "PendSV", "SysTick"
;;;877        };
;;;878        const char *ExtIrq[] =
        0x0080e84c:    22b4        ."      MOVS     r2,#0xb4
        0x0080e84e:    498e        .I      LDR      r1,[pc,#568] ; [0x80ea88] = 0x8115ac
        0x0080e850:    3140        @1      ADDS     r1,r1,#0x40
        0x0080e852:    a801        ..      ADD      r0,sp,#4
        0x0080e854:    f44bf3a8    K...    BL       __aeabi_memcpy4 ; 0x59fa8
;;;879        {
;;;880            "System", "WDG", "BTMAC", "TIM3", "TIM2", "Platform", "I2S0_TX", "I2S0_RX", "Timer4-7",
;;;881            "GPIO4", "GPIO5", "UART1", "UART0", "RTC", "SPI0", "SPI1", "I2C0", "I2C1", "ADC",
;;;882            "Peripheral", "GDMA0 Channel0", "GDMA0 Channel1", "GDMA0 Channel2", "GDMA0 Channel3",
;;;883            "GDMA0 Channel4", "GDMA0 Channel5", "GPIO_Group3", "GPIO_Group2", "IR", "GPIO_Group1",
;;;884            "GPIO_Group0", "UART2", "TIM4", "TIM5", "TIM6", "TIM7", "SPI_Flash", "Qdecode",
;;;885            "Keyscan", "SPI2W", "LPCOMP", "PTA_Mailbox", "SPORT1 TX", "SPORT1 RX", "LCD"
;;;886        };
;;;887    
;;;888        IRQ_Fun *pRamVector    = (IRQ_Fun *)VTOR_RAM_ADDR;
        0x0080e858:    f44f1600    O...    MOV      r6,#0x200000
;;;889    #if defined ( __ICCARM__ )
;;;890    #pragma section = ".intvec"
;;;891    
;;;892        IRQ_Fun *pAppVector    = (IRQ_Fun *)__section_begin(".intvec");
;;;893        uint32_t AppVectorSize = (uint32_t)__section_size(".intvec");
;;;894        DBG_DIRECT("pAppVector = 0x%x, AppVectorSize = %d", pAppVector, AppVectorSize);
;;;895    #elif defined (__CC_ARM)
;;;896        IRQ_Fun *pAppVector    = (IRQ_Fun *)&Load$$RAM_VECTOR_TABLE$$RO$$Base;
        0x0080e85c:    4d8b        .M      LDR      r5,[pc,#556] ; [0x80ea8c] = 0x811e4c
;;;897        uint32_t AppVectorSize = (uint32_t)&Image$$RAM_VECTOR_TABLE$$RO$$Length;
        0x0080e85e:    4f8c        .O      LDR      r7,[pc,#560] ; [0x80ea90] = 0xf4
;;;898    #elif defined (__GNUC__)
;;;899        IRQ_Fun *pAppVector    = (IRQ_Fun *)(&__ram_vector_load_ad__);
;;;900        uint32_t AppVectorSize = (uint32_t)&__ram_vector_table_length__;
;;;901    #endif
;;;902        uint32_t i             = 0;
        0x0080e860:    2400        .$      MOVS     r4,#0
;;;903    
;;;904        if (SCB->VTOR != VTOR_RAM_ADDR)
        0x0080e862:    488c        .H      LDR      r0,[pc,#560] ; [0x80ea94] = 0xe000ed08
        0x0080e864:    6800        .h      LDR      r0,[r0,#0]
        0x0080e866:    f5b01f00    ....    CMP      r0,#0x200000
        0x0080e86a:    d002        ..      BEQ      0x80e872 ; AppUpdateVectorTable + 54
;;;905        {
;;;906            RamVectorTableInit(VTOR_RAM_ADDR);
        0x0080e86c:    4630        0F      MOV      r0,r6
        0x0080e86e:    f7f6da1b    ....    BL       RamVectorTableInit ; 0x4ca8
;;;907        }
;;;908    
;;;909        /* Update APP defined handlers */
;;;910        for (i = 0; i < AppVectorSize / 4; ++i)
        0x0080e872:    2400        .$      MOVS     r4,#0
        0x0080e874:    e044        D.      B        0x80e900 ; AppUpdateVectorTable + 196
;;;911        {
;;;912            if (i == 0 || i == 1) //skip __initial_sp and reset_handler remap
        0x0080e876:    b10c        ..      CBZ      r4,0x80e87c ; AppUpdateVectorTable + 64
        0x0080e878:    2c01        .,      CMP      r4,#1
        0x0080e87a:    d100        ..      BNE      0x80e87e ; AppUpdateVectorTable + 66
;;;913            {
;;;914                continue;
        0x0080e87c:    e03f        ?.      B        0x80e8fe ; AppUpdateVectorTable + 194
;;;915            }
;;;916    
;;;917            if (((pAppVector[i] != Default_Handler) && (pAppVector[i] != 0)) ||
        0x0080e87e:    f8550024    U.$.    LDR      r0,[r5,r4,LSL #2]
        0x0080e882:    4985        .I      LDR      r1,[pc,#532] ; [0x80ea98] = 0x80e791
        0x0080e884:    4288        .B      CMP      r0,r1
        0x0080e886:    d002        ..      BEQ      0x80e88e ; AppUpdateVectorTable + 82
        0x0080e888:    f8550024    U.$.    LDR      r0,[r5,r4,LSL #2]
        0x0080e88c:    b950        P.      CBNZ     r0,0x80e8a4 ; AppUpdateVectorTable + 104
;;;918                ((pAppVector[i] == Default_Handler) && (pRamVector[i] == (IRQ_Fun)0x155)))  //rom default handler
        0x0080e88e:    f8550024    U.$.    LDR      r0,[r5,r4,LSL #2]
        0x0080e892:    4981        .I      LDR      r1,[pc,#516] ; [0x80ea98] = 0x80e791
        0x0080e894:    4288        .B      CMP      r0,r1
        0x0080e896:    d131        1.      BNE      0x80e8fc ; AppUpdateVectorTable + 192
        0x0080e898:    f8560024    V.$.    LDR      r0,[r6,r4,LSL #2]
        0x0080e89c:    f2401155    @.U.    MOV      r1,#0x155
        0x0080e8a0:    4288        .B      CMP      r0,r1
        0x0080e8a2:    d12b        +.      BNE      0x80e8fc ; AppUpdateVectorTable + 192
;;;919            {
;;;920                if (i < System_VECTORn)
        0x0080e8a4:    2c10        .,      CMP      r4,#0x10
        0x0080e8a6:    d211        ..      BCS      0x80e8cc ; AppUpdateVectorTable + 144
;;;921                {
;;;922                    OS_PRINT_WARN1("Warning! %s is updated by APP!", TRACE_STRING(SysException[i]));
        0x0080e8a8:    bf00        ..      NOP      
        0x0080e8aa:    bf00        ..      NOP      
        0x0080e8ac:    a82e        ..      ADD      r0,sp,#0xb8
        0x0080e8ae:    f8501024    P.$.    LDR      r1,[r0,r4,LSL #2]
        0x0080e8b2:    f04f5005    O..P    MOV      r0,#0x21400000
        0x0080e8b6:    f7f9dad8    ....    BL       trace_string ; 0x7e6a
        0x0080e8ba:    4680        .F      MOV      r8,r0
        0x0080e8bc:    4643        CF      MOV      r3,r8
        0x0080e8be:    2201        ."      MOVS     r2,#1
        0x0080e8c0:    4976        vI      LDR      r1,[pc,#472] ; [0x80ea9c] = 0x880009c
        0x0080e8c2:    4877        wH      LDR      r0,[pc,#476] ; [0x80eaa0] = 0x21100101
        0x0080e8c4:    f7f9d8cb    ....    BL       log_buffer ; 0x7a5e
        0x0080e8c8:    bf00        ..      NOP      
        0x0080e8ca:    e013        ..      B        0x80e8f4 ; AppUpdateVectorTable + 184
;;;923                }
;;;924                else
;;;925                {
;;;926                    OS_PRINT_WARN1("Warning! ISR %s is updated by APP!",
        0x0080e8cc:    bf00        ..      NOP      
        0x0080e8ce:    bf00        ..      NOP      
        0x0080e8d0:    f1a40010    ....    SUB      r0,r4,#0x10
        0x0080e8d4:    aa01        ..      ADD      r2,sp,#4
        0x0080e8d6:    f8521020    R. .    LDR      r1,[r2,r0,LSL #2]
        0x0080e8da:    f04f5005    O..P    MOV      r0,#0x21400000
        0x0080e8de:    f7f9dac4    ....    BL       trace_string ; 0x7e6a
        0x0080e8e2:    4680        .F      MOV      r8,r0
        0x0080e8e4:    4643        CF      MOV      r3,r8
        0x0080e8e6:    2201        ."      MOVS     r2,#1
        0x0080e8e8:    496e        nI      LDR      r1,[pc,#440] ; [0x80eaa4] = 0x88000c0
        0x0080e8ea:    486d        mH      LDR      r0,[pc,#436] ; [0x80eaa0] = 0x21100101
        0x0080e8ec:    f7f9d8b7    ....    BL       log_buffer ; 0x7a5e
        0x0080e8f0:    bf00        ..      NOP      
        0x0080e8f2:    bf00        ..      NOP      
;;;927                                   TRACE_STRING(ExtIrq[i - System_VECTORn]));
;;;928                }
;;;929    
;;;930                pRamVector[i] = pAppVector[i];
        0x0080e8f4:    f8550024    U.$.    LDR      r0,[r5,r4,LSL #2]
        0x0080e8f8:    f8460024    F.$.    STR      r0,[r6,r4,LSL #2]
        0x0080e8fc:    bf00        ..      NOP      
        0x0080e8fe:    1c64        d.      ADDS     r4,r4,#1
        0x0080e900:    ebb40f97    ....    CMP      r4,r7,LSR #2
        0x0080e904:    d3b7        ..      BCC      0x80e876 ; AppUpdateVectorTable + 58
;;;931            }
;;;932        }
;;;933    
;;;934        __DMB();
        0x0080e906:    f3bf8f5f    .._.    DMB      
;;;935        __DSB();
        0x0080e90a:    f3bf8f4f    ..O.    DSB      
;;;936    }
        0x0080e90e:    b03e        >.      ADD      sp,sp,#0xf8
        0x0080e910:    e8bd81f0    ....    POP      {r4-r8,pc}
    WDG_SystemReset
;;;937    /**
;;;938     * @brief  GPIO Group3 Handler
;;;939     * @param  none
;;;940     * @return none
;;;941      */
;;;942    void GPIO_Group3_Handler(void) DATA_RAM_FUNCTION;
;;;943    void GPIO_Group3_Handler(void)
;;;944    {
;;;945        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;946    
;;;947        //Check exact IRQ function
;;;948        if (GPIOIrqStatus & BIT3)
;;;949        {
;;;950            GPIO3_Handler();
;;;951        }
;;;952        if (GPIOIrqStatus & BIT7)
;;;953        {
;;;954            GPIO7_Handler();
;;;955        }
;;;956        if (GPIOIrqStatus & BIT11)
;;;957        {
;;;958            GPIO11_Handler();
;;;959        }
;;;960        if (GPIOIrqStatus & BIT15)
;;;961        {
;;;962            GPIO15_Handler();
;;;963        }
;;;964        if (GPIOIrqStatus & BIT19)
;;;965        {
;;;966            GPIO19_Handler();
;;;967        }
;;;968        if (GPIOIrqStatus & BIT23)
;;;969        {
;;;970            GPIO23_Handler();
;;;971        }
;;;972        if (GPIOIrqStatus & BIT27)
;;;973        {
;;;974            GPIO27_Handler();
;;;975        }
;;;976        if (GPIOIrqStatus & BIT31)
;;;977        {
;;;978            GPIO31_Handler();
;;;979        }
;;;980    }
;;;981    /**
;;;982     * @brief  GPIO Group2 Handler
;;;983     * @param  none
;;;984     * @return none
;;;985      */
;;;986    void GPIO_Group2_Handler(void) DATA_RAM_FUNCTION;
;;;987    void GPIO_Group2_Handler(void)
;;;988    {
;;;989        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;990    
;;;991        //Check exact IRQ function
;;;992        if (GPIOIrqStatus & BIT2)
;;;993        {
;;;994            GPIO2_Handler();
;;;995        }
;;;996        if (GPIOIrqStatus & BIT6)
;;;997        {
;;;998            GPIO6_Handler();
;;;999        }
;;;1000       if (GPIOIrqStatus & BIT10)
;;;1001       {
;;;1002           GPIO10_Handler();
;;;1003       }
;;;1004       if (GPIOIrqStatus & BIT14)
;;;1005       {
;;;1006           GPIO14_Handler();
;;;1007       }
;;;1008       if (GPIOIrqStatus & BIT18)
;;;1009       {
;;;1010           GPIO18_Handler();
;;;1011       }
;;;1012       if (GPIOIrqStatus & BIT22)
;;;1013       {
;;;1014           GPIO22_Handler();
;;;1015       }
;;;1016       if (GPIOIrqStatus & BIT26)
;;;1017       {
;;;1018           GPIO26_Handler();
;;;1019       }
;;;1020       if (GPIOIrqStatus & BIT30)
;;;1021       {
;;;1022           GPIO30_Handler();
;;;1023       }
;;;1024   }
;;;1025   /**
;;;1026    * @brief  GPIO Group1 Handler
;;;1027    * @param  none
;;;1028    * @return none
;;;1029     */
;;;1030   void GPIO_Group1_Handler(void) DATA_RAM_FUNCTION;
;;;1031   void GPIO_Group1_Handler(void)
;;;1032   {
;;;1033       uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;1034   
;;;1035       //Check exact IRQ function
;;;1036       if (GPIOIrqStatus & BIT1)
;;;1037       {
;;;1038           GPIO1_Handler();
;;;1039       }
;;;1040       if (GPIOIrqStatus & BIT9)
;;;1041       {
;;;1042           GPIO9_Handler();
;;;1043       }
;;;1044       if (GPIOIrqStatus & BIT13)
;;;1045       {
;;;1046           GPIO13_Handler();
;;;1047       }
;;;1048       if (GPIOIrqStatus & BIT17)
;;;1049       {
;;;1050           GPIO17_Handler();
;;;1051       }
;;;1052       if (GPIOIrqStatus & BIT21)
;;;1053       {
;;;1054           GPIO21_Handler();
;;;1055       }
;;;1056       if (GPIOIrqStatus & BIT25)
;;;1057       {
;;;1058           GPIO25_Handler();
;;;1059       }
;;;1060       if (GPIOIrqStatus & BIT29)
;;;1061       {
;;;1062           GPIO29_Handler();
;;;1063       }
;;;1064   }
;;;1065   /**
;;;1066    * @brief  GPIO Group0 Handler
;;;1067    * @param  none
;;;1068    * @return none
;;;1069     */
;;;1070   void GPIO_Group0_Handler(void) DATA_RAM_FUNCTION;
;;;1071   void GPIO_Group0_Handler(void)
;;;1072   {
;;;1073       uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
;;;1074   
;;;1075       //Check exact IRQ function
;;;1076       if (GPIOIrqStatus & BIT0)
;;;1077       {
;;;1078           GPIO0_Handler();
;;;1079       }
;;;1080       if (GPIOIrqStatus & BIT8)
;;;1081       {
;;;1082           GPIO8_Handler();
;;;1083       }
;;;1084       if (GPIOIrqStatus & BIT12)
;;;1085       {
;;;1086           GPIO12_Handler();
;;;1087       }
;;;1088       if (GPIOIrqStatus & BIT16)
;;;1089       {
;;;1090           GPIO16_Handler();
;;;1091       }
;;;1092       if (GPIOIrqStatus & BIT20)
;;;1093       {
;;;1094           GPIO20_Handler();
;;;1095       }
;;;1096       if (GPIOIrqStatus & BIT24)
;;;1097       {
;;;1098           GPIO24_Handler();
;;;1099       }
;;;1100       if (GPIOIrqStatus & BIT28)
;;;1101       {
;;;1102           GPIO28_Handler();
;;;1103       }
;;;1104   }
;;;1105   
;;;1106   #ifdef SDK_8772
;;;1107   #else
;;;1108   void WDG_SystemReset(T_WDG_MODE wdg_mode, T_SW_RESET_REASON reset_reason)
;;;1109   {
        0x0080e914:    b570        p.      PUSH     {r4-r6,lr}
        0x0080e916:    4604        .F      MOV      r4,r0
        0x0080e918:    460d        .F      MOV      r5,r1
;;;1110       uint32_t parm = wdg_mode | (reset_reason << 8);
        0x0080e91a:    ea442605    D..&    ORR      r6,r4,r5,LSL #8
;;;1111       SystemCall(SYSTEM_CALL_WDG_RESET, parm);
        0x0080e91e:    4631        1F      MOV      r1,r6
        0x0080e920:    2001        .       MOVS     r0,#1
        0x0080e922:    f7f8dcbd    ....    BL       SystemCall ; 0x72a0
;;;1112   }
        0x0080e926:    bd70        p.      POP      {r4-r6,pc}
    flash_try_high_speed
;;;1113   #endif
;;;1114   
;;;1115   /**
;;;1116    * @brief  flash try to switch to high speed bit mode
;;;1117    * @note  switch back to 1 bit mode, if flash switch to high speed bit mode fail
;;;1118    * @param  bit_mode config bit mode @ref T_FLASH_MODE
;;;1119    * @retval 0 fail
;;;1120    * @retval 1 success
;;;1121     */
;;;1122   uint32_t flash_try_high_speed(T_FLASH_MODE bit_mode)
;;;1123   {
        0x0080e928:    b570        p.      PUSH     {r4-r6,lr}
        0x0080e92a:    4605        .F      MOV      r5,r0
;;;1124       uint32_t result = 0;
        0x0080e92c:    2400        .$      MOVS     r4,#0
;;;1125       OTP->bit_mode = bit_mode;
        0x0080e92e:    4847        GH      LDR      r0,[pc,#284] ; [0x80ea4c] = 0x20039b
        0x0080e930:    384f        O8      SUBS     r0,r0,#0x4f
        0x0080e932:    7800        .x      LDRB     r0,[r0,#0]
        0x0080e934:    f3650001    e...    BFI      r0,r5,#0,#2
        0x0080e938:    f44f1100    O...    MOV      r1,#0x200000
        0x0080e93c:    f881034c    ..L.    STRB     r0,[r1,#0x34c]
;;;1126       result = flash_ioctl(flash_ioctrl_try_high_speed, 0, 0);
        0x0080e940:    2200        ."      MOVS     r2,#0
        0x0080e942:    4611        .F      MOV      r1,r2
        0x0080e944:    f2450002    E...    MOV      r0,#0x5002
        0x0080e948:    f7fddb93    ....    BL       flash_ioctl ; 0xc072
        0x0080e94c:    4604        .F      MOV      r4,r0
;;;1127       //if try fail, set back OTP->bit_mode to one bit mode
;;;1128       if (!result)
        0x0080e94e:    b944        D.      CBNZ     r4,0x80e962 ; flash_try_high_speed + 58
;;;1129       {
;;;1130           OTP->bit_mode = FLASH_MODE_1BIT;
        0x0080e950:    483e        >H      LDR      r0,[pc,#248] ; [0x80ea4c] = 0x20039b
        0x0080e952:    384f        O8      SUBS     r0,r0,#0x4f
        0x0080e954:    7800        .x      LDRB     r0,[r0,#0]
        0x0080e956:    f0200003     ...    BIC      r0,r0,#3
        0x0080e95a:    f44f1100    O...    MOV      r1,#0x200000
        0x0080e95e:    f881034c    ..L.    STRB     r0,[r1,#0x34c]
;;;1131       }
;;;1132       return result;
        0x0080e962:    4620         F      MOV      r0,r4
;;;1133   }
        0x0080e964:    bd70        p.      POP      {r4-r6,pc}
    malloc
;;;1134   
;;;1135   void *malloc(size_t size)
;;;1136   {
        0x0080e966:    b510        ..      PUSH     {r4,lr}
        0x0080e968:    4604        .F      MOV      r4,r0
;;;1137       return os_mem_alloc(RAM_TYPE_DATA_ON, size);
        0x0080e96a:    f2404371    @.qC    MOV      r3,#0x471
        0x0080e96e:    4a4e        NJ      LDR      r2,[pc,#312] ; [0x80eaa8] = 0x8116a0
        0x0080e970:    4621        !F      MOV      r1,r4
        0x0080e972:    2000        .       MOVS     r0,#0
        0x0080e974:    f417f1f4    ....    BL       os_mem_alloc_intern ; 0x25d60
;;;1138   }
        0x0080e978:    bd10        ..      POP      {r4,pc}
    calloc
;;;1139   
;;;1140   void *calloc(size_t n, size_t size)
;;;1141   {
        0x0080e97a:    b570        p.      PUSH     {r4-r6,lr}
        0x0080e97c:    4604        .F      MOV      r4,r0
        0x0080e97e:    460d        .F      MOV      r5,r1
;;;1142       return os_mem_zalloc(RAM_TYPE_DATA_ON, n * size);
        0x0080e980:    fb04f105    ....    MUL      r1,r4,r5
        0x0080e984:    f2404376    @.vC    MOV      r3,#0x476
        0x0080e988:    4a48        HJ      LDR      r2,[pc,#288] ; [0x80eaac] = 0x8116a7
        0x0080e98a:    2000        .       MOVS     r0,#0
        0x0080e98c:    f417f214    ....    BL       os_mem_zalloc_intern ; 0x25db8
;;;1143   }
        0x0080e990:    bd70        p.      POP      {r4-r6,pc}
    realloc
;;;1144   
;;;1145   void *realloc(void *ptr, size_t size)
;;;1146   {
        0x0080e992:    b570        p.      PUSH     {r4-r6,lr}
        0x0080e994:    4604        .F      MOV      r4,r0
        0x0080e996:    460d        .F      MOV      r5,r1
;;;1147       if (ptr)
        0x0080e998:    b114        ..      CBZ      r4,0x80e9a0 ; realloc + 14
;;;1148       {
;;;1149           os_mem_free(ptr);
        0x0080e99a:    4620         F      MOV      r0,r4
        0x0080e99c:    f417f26b    ..k.    BL       os_mem_free ; 0x25e76
;;;1150       }
;;;1151   
;;;1152       return os_mem_alloc(RAM_TYPE_DATA_ON, size);
        0x0080e9a0:    f44f6390    O..c    MOV      r3,#0x480
        0x0080e9a4:    4a42        BJ      LDR      r2,[pc,#264] ; [0x80eab0] = 0x8116ae
        0x0080e9a6:    4629        )F      MOV      r1,r5
        0x0080e9a8:    2000        .       MOVS     r0,#0
        0x0080e9aa:    f417f1d9    ....    BL       os_mem_alloc_intern ; 0x25d60
;;;1153   }
        0x0080e9ae:    bd70        p.      POP      {r4-r6,pc}
    free
;;;1154   
;;;1155   void free(void *ptr)
;;;1156   {
        0x0080e9b0:    b510        ..      PUSH     {r4,lr}
        0x0080e9b2:    4604        .F      MOV      r4,r0
;;;1157       os_mem_free(ptr);
        0x0080e9b4:    4620         F      MOV      r0,r4
        0x0080e9b6:    f417f25e    ..^.    BL       os_mem_free ; 0x25e76
;;;1158   }
        0x0080e9ba:    bd10        ..      POP      {r4,pc}
    app_cb0_wdg_reset
;;;1159   
;;;1160   void app_cb0_wdg_reset(T_WDG_MODE wdg_mode, T_SW_RESET_REASON reset_reason)
;;;1161   {
        0x0080e9bc:    b570        p.      PUSH     {r4-r6,lr}
        0x0080e9be:    4605        .F      MOV      r5,r0
        0x0080e9c0:    460c        .F      MOV      r4,r1
;;;1162       check_reset_ram.check_reset_ram_type = reset_reason;
        0x0080e9c2:    483c        <H      LDR      r0,[pc,#240] ; [0x80eab4] = 0x207d50
        0x0080e9c4:    6800        .h      LDR      r0,[r0,#0]
        0x0080e9c6:    f364601f    d..`    BFI      r0,r4,#24,#8
        0x0080e9ca:    493a        :I      LDR      r1,[pc,#232] ; [0x80eab4] = 0x207d50
        0x0080e9cc:    6008        .`      STR      r0,[r1,#0]
;;;1163   
;;;1164       if (user_wdg_cb)
        0x0080e9ce:    483a        :H      LDR      r0,[pc,#232] ; [0x80eab8] = 0x207e0c
        0x0080e9d0:    6800        .h      LDR      r0,[r0,#0]
        0x0080e9d2:    b130        0.      CBZ      r0,0x80e9e2 ; app_cb0_wdg_reset + 38
;;;1165       {
;;;1166           if (user_wdg_cb(wdg_mode, reset_reason))
        0x0080e9d4:    4621        !F      MOV      r1,r4
        0x0080e9d6:    4628        (F      MOV      r0,r5
        0x0080e9d8:    4a37        7J      LDR      r2,[pc,#220] ; [0x80eab8] = 0x207e0c
        0x0080e9da:    6812        .h      LDR      r2,[r2,#0]
        0x0080e9dc:    4790        .G      BLX      r2
        0x0080e9de:    b100        ..      CBZ      r0,0x80e9e2 ; app_cb0_wdg_reset + 38
;;;1167           {
;;;1168               return;
;;;1169           }
;;;1170       }
;;;1171   
;;;1172       //do something necessary before watch dog reset
;;;1173   }
        0x0080e9e0:    bd70        p.      POP      {r4-r6,pc}
        0x0080e9e2:    bf00        ..      NOP      
        0x0080e9e4:    e7fc        ..      B        0x80e9e0 ; app_cb0_wdg_reset + 36
    app_cb5_dfu_status
;;;1174   
;;;1175   void app_cb5_dfu_status(DFU_PROGRESS_STATUS status, uint32_t length)
;;;1176   {
        0x0080e9e6:    b570        p.      PUSH     {r4-r6,lr}
        0x0080e9e8:    4604        .F      MOV      r4,r0
        0x0080e9ea:    460d        .F      MOV      r5,r1
;;;1177   //    uint32_t value = 0;
;;;1178   //    switch(status)
;;;1179   //    {
;;;1180   //        case DFU_START:
;;;1181   //            value = *((uint32_t *)0x180e000);
;;;1182   //            DBG_DIRECT("DFU start, total length = %d, value = 0x%x", length, value);
;;;1183   //            break;
;;;1184   //        case DFU_DOING:
;;;1185   //            value = *((uint32_t *)0x180e000);
;;;1186   //            DBG_DIRECT("DFU doing, paccket length = %d, value = 0x%x", length, value);
;;;1187   //            break;
;;;1188   //        case DFU_END:
;;;1189   //            value = *((uint32_t *)0x180e000);
;;;1190   //            DBG_DIRECT("DFU end, check result = %d, value = 0x%x", length, value);
;;;1191   //            break;
;;;1192   //        default:
;;;1193   //            DBG_DIRECT("wrong status input");
;;;1194   //    }
;;;1195       if (user_dfu_status_cb)
        0x0080e9ec:    4833        3H      LDR      r0,[pc,#204] ; [0x80eabc] = 0x207e10
        0x0080e9ee:    6800        .h      LDR      r0,[r0,#0]
        0x0080e9f0:    b130        0.      CBZ      r0,0x80ea00 ; app_cb5_dfu_status + 26
;;;1196       {
;;;1197           if (user_dfu_status_cb(status, length))
        0x0080e9f2:    4629        )F      MOV      r1,r5
        0x0080e9f4:    4620         F      MOV      r0,r4
        0x0080e9f6:    4a31        1J      LDR      r2,[pc,#196] ; [0x80eabc] = 0x207e10
        0x0080e9f8:    6812        .h      LDR      r2,[r2,#0]
        0x0080e9fa:    4790        .G      BLX      r2
        0x0080e9fc:    b100        ..      CBZ      r0,0x80ea00 ; app_cb5_dfu_status + 26
;;;1198           {
;;;1199               return;
;;;1200           }
;;;1201       }
;;;1202   }
        0x0080e9fe:    bd70        p.      POP      {r4-r6,pc}
        0x0080ea00:    bf00        ..      NOP      
        0x0080ea02:    e7fc        ..      B        0x80e9fe ; app_cb5_dfu_status + 24
    app_cb6_rtc_handler
;;;1203   
;;;1204   void app_cb6_rtc_handler()
;;;1205   {
        0x0080ea04:    b510        ..      PUSH     {r4,lr}
;;;1206       if (user_rtc_handler_cb)
        0x0080ea06:    482e        .H      LDR      r0,[pc,#184] ; [0x80eac0] = 0x207e14
        0x0080ea08:    6800        .h      LDR      r0,[r0,#0]
        0x0080ea0a:    b120         .      CBZ      r0,0x80ea16 ; app_cb6_rtc_handler + 18
;;;1207       {
;;;1208           if (user_rtc_handler_cb())
        0x0080ea0c:    482c        ,H      LDR      r0,[pc,#176] ; [0x80eac0] = 0x207e14
        0x0080ea0e:    6800        .h      LDR      r0,[r0,#0]
        0x0080ea10:    4780        .G      BLX      r0
        0x0080ea12:    b100        ..      CBZ      r0,0x80ea16 ; app_cb6_rtc_handler + 18
;;;1209           {
;;;1210               return;
;;;1211           }
;;;1212       }
;;;1213   }
        0x0080ea14:    bd10        ..      POP      {r4,pc}
        0x0080ea16:    bf00        ..      NOP      
        0x0080ea18:    e7fc        ..      B        0x80ea14 ; app_cb6_rtc_handler + 16
    get_cpu_clock
;;;1214   
;;;1215   /**
;;;1216    * @brief  get cpu clock
;;;1217    * @param  none
;;;1218    * @return uint32, for example 40000000 is 40M, 20000000 is 20M.
;;;1219     */
;;;1220   uint32_t get_cpu_clock(void)
;;;1221   {
;;;1222       extern uint32_t SystemCpuClock;
;;;1223       return SystemCpuClock;
        0x0080ea1a:    482a        *H      LDR      r0,[pc,#168] ; [0x80eac4] = 0x2000f4
        0x0080ea1c:    6800        .h      LDR      r0,[r0,#0]
;;;1224   }
        0x0080ea1e:    4770        pG      BX       lr
    get_ic_euid
;;;1225   
;;;1226   /**
;;;1227    * @brief  get 14 bytes EUID
;;;1228    * @param  none
;;;1229    * @return uint8_t *, the pointer to a copy of EUID.
;;;1230     */
;;;1231   uint8_t *get_ic_euid(void)
;;;1232   {
        0x0080ea20:    b510        ..      PUSH     {r4,lr}
;;;1233       static uint8_t euid[15] = {0};
;;;1234   
;;;1235       memcpy(euid, (uint8_t *)0x2028F5, 14);
        0x0080ea22:    220e        ."      MOVS     r2,#0xe
        0x0080ea24:    4928        (I      LDR      r1,[pc,#160] ; [0x80eac8] = 0x2028f5
        0x0080ea26:    4829        )H      LDR      r0,[pc,#164] ; [0x80eacc] = 0x207e20
        0x0080ea28:    f44bf237    K.7.    BL       __aeabi_memcpy ; 0x59e9a
;;;1236       return euid;
        0x0080ea2c:    4827        'H      LDR      r0,[pc,#156] ; [0x80eacc] = 0x207e20
;;;1237   }
        0x0080ea2e:    bd10        ..      POP      {r4,pc}
    get_ic_type
;;;1238   
;;;1239   /**
;;;1240    * @brief  get ic type
;;;1241    * @param  none
;;;1242    * @return uint8_t, ic type:
;;;1243    * #define RTL8752CRF              0x08
;;;1244    * #define RTL8752CGF              0x38
;;;1245    * #define RTL8762CJ               0x11
;;;1246    * #define RTL8752CJ               0x01
;;;1247    * #define RTL8762CJF              0x19
;;;1248    * #define RTL8752CJF              0x09
;;;1249    * #define RTL8762CK               0x12
;;;1250    * #define RTL8762CKF              0x1A
;;;1251    * #define RTL8762CKO              0x1B
;;;1252    * #define RTL8752CKO              0x0B
;;;1253    * #define RTL8762CAF              0x0A
;;;1254    * #define RTL8762CMF              0x2A
;;;1255    * #define RTL8752CMF              0x29
;;;1256    */
;;;1257   uint8_t get_ic_type(void)
;;;1258   {
;;;1259       return *(uint8_t *)0x002028f3;
        0x0080ea30:    4825        %H      LDR      r0,[pc,#148] ; [0x80eac8] = 0x2028f5
        0x0080ea32:    1e80        ..      SUBS     r0,r0,#2
        0x0080ea34:    7800        .x      LDRB     r0,[r0,#0]
;;;1260   }
        0x0080ea36:    4770        pG      BX       lr
    NVIC_DisableIRQ
;;; ..\..\..\inc\platform\cmsis\core_cm4.h
;;;1659       NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
        0x0080ea38:    f000021f    ....    AND      r2,r0,#0x1f
        0x0080ea3c:    2101        .!      MOVS     r1,#1
        0x0080ea3e:    4091        .@      LSLS     r1,r1,r2
        0x0080ea40:    4a23        #J      LDR      r2,[pc,#140] ; [0x80ead0] = 0xe000e180
        0x0080ea42:    0943        C.      LSRS     r3,r0,#5
        0x0080ea44:    f8421023    B.#.    STR      r1,[r2,r3,LSL #2]
;;;1660   }
        0x0080ea48:    4770        pG      BX       lr
    $d
        0x0080ea4a:    0000        ..      DCW    0
        0x0080ea4c:    0020039b    .. .    DCD    2098075
        0x0080ea50:    53206e49    In S    DCD    1394634313
        0x0080ea54:    4d20436f    oC M    DCD    1293960047
        0x0080ea58:    0065646f    ode.    DCD    6644847
        0x0080ea5c:    4e524157    WARN    DCD    1314013527
        0x0080ea60:    3a474e49    ING:    DCD    977751625
        0x0080ea64:    206e4920     In     DCD    544098592
        0x0080ea68:    20494348    HCI     DCD    541672264
        0x0080ea6c:    65646f4d    Mode    DCD    1701080909
        0x0080ea70:    6977202c    , wi    DCD    1769414700
        0x0080ea74:    6e206c6c    ll n    DCD    1847618668
        0x0080ea78:    7220746f    ot r    DCD    1914729583
        0x0080ea7c:    41206e75    un A    DCD    1092644469
        0x0080ea80:    54205050    PP T    DCD    1411403856
        0x0080ea84:    006b7361    ask.    DCD    7041889
        0x0080ea88:    008115ac    ....    DCD    8459692
        0x0080ea8c:    00811e4c    L...    DCD    8461900
        0x0080ea90:    000000f4    ....    DCD    244
        0x0080ea94:    e000ed08    ....    DCD    3758157064
        0x0080ea98:    0080e791    ....    DCD    8447889
        0x0080ea9c:    0880009c    ....    DCD    142606492
        0x0080eaa0:    21100101    ...!    DCD    554696961
        0x0080eaa4:    088000c0    ....    DCD    142606528
        0x0080eaa8:    008116a0    ....    DCD    8459936
        0x0080eaac:    008116a7    ....    DCD    8459943
        0x0080eab0:    008116ae    ....    DCD    8459950
        0x0080eab4:    00207d50    P} .    DCD    2129232
        0x0080eab8:    00207e0c    .~ .    DCD    2129420
        0x0080eabc:    00207e10    .~ .    DCD    2129424
        0x0080eac0:    00207e14    .~ .    DCD    2129428
        0x0080eac4:    002000f4    .. .    DCD    2097396
        0x0080eac8:    002028f5    .( .    DCD    2107637
        0x0080eacc:    00207e20     ~ .    DCD    2129440
        0x0080ead0:    e000e180    ....    DCD    3758154112
    $t
    .text
    app_main_task
;;; ..\..\..\src\app\ota\app_task.c
;;;54     {
        0x0080ead4:    b51f        ..      PUSH     {r0-r4,lr}
;;;55         uint8_t event;
;;;56     
;;;57         os_msg_queue_create(&io_queue_handle, MAX_NUMBER_OF_IO_MESSAGE, sizeof(T_IO_MSG));
        0x0080ead6:    2039        9       MOVS     r0,#0x39
        0x0080ead8:    4b23        #K      LDR      r3,[pc,#140] ; [0x80eb68] = 0x8116b6
        0x0080eada:    2208        ."      MOVS     r2,#8
        0x0080eadc:    2120         !      MOVS     r1,#0x20
        0x0080eade:    9000        ..      STR      r0,[sp,#0]
        0x0080eae0:    4822        "H      LDR      r0,[pc,#136] ; [0x80eb6c] = 0x207e38
        0x0080eae2:    f417f207    ....    BL       os_msg_queue_create_intern ; 0x25ef4
;;;58         os_msg_queue_create(&evt_queue_handle, MAX_NUMBER_OF_EVENT_MESSAGE, sizeof(uint8_t));
        0x0080eae6:    203a        :       MOVS     r0,#0x3a
        0x0080eae8:    4b1f        .K      LDR      r3,[pc,#124] ; [0x80eb68] = 0x8116b6
        0x0080eaea:    2201        ."      MOVS     r2,#1
        0x0080eaec:    2140        @!      MOVS     r1,#0x40
        0x0080eaee:    9000        ..      STR      r0,[sp,#0]
        0x0080eaf0:    481f        .H      LDR      r0,[pc,#124] ; [0x80eb70] = 0x207e34
        0x0080eaf2:    f417f1ff    ....    BL       os_msg_queue_create_intern ; 0x25ef4
;;;59     
;;;60         gap_start_bt_stack(evt_queue_handle, io_queue_handle, MAX_NUMBER_OF_GAP_MESSAGE);
        0x0080eaf6:    2220         "      MOVS     r2,#0x20
        0x0080eaf8:    481c        .H      LDR      r0,[pc,#112] ; [0x80eb6c] = 0x207e38
        0x0080eafa:    6801        .h      LDR      r1,[r0,#0]
        0x0080eafc:    481c        .H      LDR      r0,[pc,#112] ; [0x80eb70] = 0x207e34
        0x0080eafe:    6800        .h      LDR      r0,[r0,#0]
        0x0080eb00:    f43df1b3    =...    BL       gap_start_bt_stack ; 0x4be6a
;;;61     
;;;62         while (true)
        0x0080eb04:    e021        !.      B        0x80eb4a ; app_main_task + 118
;;;63         {
;;;64             if (os_msg_recv(evt_queue_handle, &event, 0xFFFFFFFF) == true)
        0x0080eb06:    2040        @       MOVS     r0,#0x40
        0x0080eb08:    4b17        .K      LDR      r3,[pc,#92] ; [0x80eb68] = 0x8116b6
        0x0080eb0a:    f04f32ff    O..2    MOV      r2,#0xffffffff
        0x0080eb0e:    a903        ..      ADD      r1,sp,#0xc
        0x0080eb10:    9000        ..      STR      r0,[sp,#0]
        0x0080eb12:    4817        .H      LDR      r0,[pc,#92] ; [0x80eb70] = 0x207e34
        0x0080eb14:    6800        .h      LDR      r0,[r0,#0]
        0x0080eb16:    f417f295    ....    BL       os_msg_recv_intern ; 0x26044
        0x0080eb1a:    b1b0        ..      CBZ      r0,0x80eb4a ; app_main_task + 118
;;;65             {
;;;66                 //DBG_DIRECT("***os_msg_recv***");
;;;67                 if (event == EVENT_IO_TO_APP)
        0x0080eb1c:    f89d000c    ....    LDRB     r0,[sp,#0xc]
        0x0080eb20:    2802        .(      CMP      r0,#2
        0x0080eb22:    d10e        ..      BNE      0x80eb42 ; app_main_task + 110
;;;68                 {
;;;69                     T_IO_MSG io_msg;
;;;70                     if (os_msg_recv(io_queue_handle, &io_msg, 0) == true)
        0x0080eb24:    2046        F       MOVS     r0,#0x46
        0x0080eb26:    4b10        .K      LDR      r3,[pc,#64] ; [0x80eb68] = 0x8116b6
        0x0080eb28:    2200        ."      MOVS     r2,#0
        0x0080eb2a:    a901        ..      ADD      r1,sp,#4
        0x0080eb2c:    9000        ..      STR      r0,[sp,#0]
        0x0080eb2e:    480f        .H      LDR      r0,[pc,#60] ; [0x80eb6c] = 0x207e38
        0x0080eb30:    6800        .h      LDR      r0,[r0,#0]
        0x0080eb32:    f417f287    ....    BL       os_msg_recv_intern ; 0x26044
        0x0080eb36:    b118        ..      CBZ      r0,0x80eb40 ; app_main_task + 108
;;;71                     {
;;;72                         app_handle_io_msg(io_msg);
        0x0080eb38:    e9dd0101    ....    LDRD     r0,r1,[sp,#4]
        0x0080eb3c:    f000fcc7    ....    BL       app_handle_io_msg ; 0x80f4ce
;;;73                     }
;;;74                 }
        0x0080eb40:    e003        ..      B        0x80eb4a ; app_main_task + 118
;;;75                 else
;;;76                 {
;;;77                     gap_handle_msg(event);
        0x0080eb42:    f89d000c    ....    LDRB     r0,[sp,#0xc]
        0x0080eb46:    f43df1fd    =...    BL       gap_handle_msg ; 0x4bf44
        0x0080eb4a:    e7dc        ..      B        0x80eb06 ; app_main_task + 50
    app_task_init
        0x0080eb4c:    b51c        ..      PUSH     {r2-r4,lr}
;;; ..\..\..\src\app\ota\app_task.c (42)
        0x0080eb4e:    2001        .       MOVS     r0,#1
        0x0080eb50:    02c1        ..      LSLS     r1,r0,#11
        0x0080eb52:    2300        .#      MOVS     r3,#0
        0x0080eb54:    f2af0283    ....    ADR      r2,{pc}-0x7f ; 0x80ead5
        0x0080eb58:    e9cd1000    ....    STRD     r1,r0,[sp,#0]
        0x0080eb5c:    a105        ..      ADR      r1,{pc}+0x18 ; 0x80eb74
        0x0080eb5e:    4806        .H      LDR      r0,[pc,#24] ; [0x80eb78] = 0x207e30
        0x0080eb60:    f417f736    ..6.    BL       os_task_create ; 0x269d0
;;;43                        APP_TASK_PRIORITY);
;;;44     }
        0x0080eb64:    bd1c        ..      POP      {r2-r4,pc}
    $d
        0x0080eb66:    0000        ..      DCW    0
        0x0080eb68:    008116b6    ....    DCD    8459958
        0x0080eb6c:    00207e38    8~ .    DCD    2129464
        0x0080eb70:    00207e34    4~ .    DCD    2129460
        0x0080eb74:    00707061    app.    DCD    7368801
        0x0080eb78:    00207e30    0~ .    DCD    2129456
    $t
    .text
    get_active_bank_image_version
;;; ..\..\..\inc\platform\patch_header_check.h
;;;331    {
        0x0080eb7c:    e92d47f0    -..G    PUSH     {r4-r10,lr}
        0x0080eb80:    4605        .F      MOV      r5,r0
        0x0080eb82:    460e        .F      MOV      r6,r1
;;;332        uint32_t image_addr;
;;;333        uint32_t image_size;
;;;334    
;;;335        if ((image_id < OTA) || (image_id >= IMAGE_MAX)) //not support
        0x0080eb84:    f2427090    B..p    MOV      r0,#0x2790
        0x0080eb88:    4285        .B      CMP      r5,r0
        0x0080eb8a:    db03        ..      BLT      0x80eb94 ; get_active_bank_image_version + 24
        0x0080eb8c:    f242709a    B..p    MOV      r0,#0x279a
        0x0080eb90:    4285        .B      CMP      r5,r0
        0x0080eb92:    db02        ..      BLT      0x80eb9a ; get_active_bank_image_version + 30
;;;336        {
;;;337            return false;
        0x0080eb94:    2000        .       MOVS     r0,#0
        0x0080eb96:    e8bd87f0    ....    POP      {r4-r10,pc}
;;;338        }
;;;339        else if (image_id == OTA)
        0x0080eb9a:    f2427090    B..p    MOV      r0,#0x2790
        0x0080eb9e:    4285        .B      CMP      r5,r0
        0x0080eba0:    d10e        ..      BNE      0x80ebc0 ; get_active_bank_image_version + 68
;;;340        {
;;;341            image_addr = get_header_addr_by_img_id(image_id);
        0x0080eba2:    4628        (F      MOV      r0,r5
        0x0080eba4:    f7fdde1e    ....    BL       get_header_addr_by_img_id ; 0xc7e4
        0x0080eba8:    4604        .F      MOV      r4,r0
;;;342            T_OTA_HEADER_FORMAT *p_header = (T_OTA_HEADER_FORMAT *)image_addr;
        0x0080ebaa:    46a1        .F      MOV      r9,r4
;;;343            if (!p_header)
        0x0080ebac:    f1b90f00    ....    CMP      r9,#0
        0x0080ebb0:    d101        ..      BNE      0x80ebb6 ; get_active_bank_image_version + 58
;;;344            {
;;;345                return false;
        0x0080ebb2:    2000        .       MOVS     r0,#0
        0x0080ebb4:    e7ef        ..      B        0x80eb96 ; get_active_bank_image_version + 26
;;;346            }
;;;347            else
;;;348            {
;;;349                p_image_version->ver_info.version = p_header->ver_val;
        0x0080ebb6:    f8d90194    ....    LDR      r0,[r9,#0x194]
        0x0080ebba:    6030        0`      STR      r0,[r6,#0]
;;;350                return true;
        0x0080ebbc:    2001        .       MOVS     r0,#1
        0x0080ebbe:    e7ea        ..      B        0x80eb96 ; get_active_bank_image_version + 26
;;;351            }
;;;352        }
;;;353    #ifdef SDK_8772
;;;354        image_addr = get_header_addr_by_img_id(image_id);
;;;355    #else
;;;356        else if (image_id <= AppData2)
        0x0080ebc0:    f2427095    B..p    MOV      r0,#0x2795
        0x0080ebc4:    4285        .B      CMP      r5,r0
        0x0080ebc6:    dc04        ..      BGT      0x80ebd2 ; get_active_bank_image_version + 86
;;;357        {
;;;358            image_addr = get_header_addr_by_img_id(image_id);
        0x0080ebc8:    4628        (F      MOV      r0,r5
        0x0080ebca:    f7fdde0b    ....    BL       get_header_addr_by_img_id ; 0xc7e4
        0x0080ebce:    4604        .F      MOV      r4,r0
        0x0080ebd0:    e006        ..      B        0x80ebe0 ; get_active_bank_image_version + 100
;;;359        }
;;;360        else
;;;361        {
;;;362            //if patch not support cmd flash_ioctl_get_image_addr_by_image_id_ext, will get app data3-6 version fail!!!
;;;363            image_addr = flash_ioctl(flash_ioctl_get_image_addr_by_image_id_ext, image_id, 0);
        0x0080ebd2:    2200        ."      MOVS     r2,#0
        0x0080ebd4:    4629        )F      MOV      r1,r5
        0x0080ebd6:    f2450005    E...    MOV      r0,#0x5005
        0x0080ebda:    f7fdda4a    ..J.    BL       flash_ioctl ; 0xc072
        0x0080ebde:    4604        .F      MOV      r4,r0
;;;364        }
;;;365    #endif
;;;366        image_size = get_active_bank_image_size_by_img_id(image_id);
        0x0080ebe0:    4628        (F      MOV      r0,r5
        0x0080ebe2:    f000f979    ..y.    BL       get_active_bank_image_size_by_img_id ; 0x80eed8
        0x0080ebe6:    4607        .F      MOV      r7,r0
;;;367    
;;;368        //get active bank image version when image id is not less than OTA
;;;369        T_IMG_HEADER_FORMAT *p_header = (T_IMG_HEADER_FORMAT *)image_addr;
        0x0080ebe8:    46a0        .F      MOV      r8,r4
;;;370        if ((!p_header) || (image_size == 0))
        0x0080ebea:    f1b80400    ....    SUBS     r4,r8,#0
        0x0080ebee:    d000        ..      BEQ      0x80ebf2 ; get_active_bank_image_version + 118
        0x0080ebf0:    b90f        ..      CBNZ     r7,0x80ebf6 ; get_active_bank_image_version + 122
;;;371        {
;;;372            return false;
        0x0080ebf2:    2000        .       MOVS     r0,#0
        0x0080ebf4:    e7cf        ..      B        0x80eb96 ; get_active_bank_image_version + 26
;;;373        }
;;;374        else
;;;375        {
;;;376            p_image_version->ver_info.version = p_header->git_ver.ver_info.version;
        0x0080ebf6:    f8d80060    ..`.    LDR      r0,[r8,#0x60]
        0x0080ebfa:    6030        0`      STR      r0,[r6,#0]
;;;377            return true;
        0x0080ebfc:    2001        .       MOVS     r0,#1
        0x0080ebfe:    e7ca        ..      B        0x80eb96 ; get_active_bank_image_version + 26
    app_le_gap_init
;;; ..\..\..\src\app\ota\main.c
;;;88     {
        0x0080ec00:    b500        ..      PUSH     {lr}
        0x0080ec02:    b09b        ..      SUB      sp,sp,#0x6c
;;;89         //device name and device appearance
;;;90         uint8_t  device_name[GAP_DEVICE_NAME_LEN] = "BLE_OTA";
        0x0080ec04:    2228        ("      MOVS     r2,#0x28
        0x0080ec06:    49cc        .I      LDR      r1,[pc,#816] ; [0x80ef38] = 0x8116c4
        0x0080ec08:    a811        ..      ADD      r0,sp,#0x44
        0x0080ec0a:    f44bf1cd    K...    BL       __aeabi_memcpy4 ; 0x59fa8
;;;91         uint16_t appearance = GAP_GATT_APPEARANCE_KEYBOARD;
        0x0080ec0e:    f24030c1    @..0    MOV      r0,#0x3c1
        0x0080ec12:    9010        ..      STR      r0,[sp,#0x40]
;;;92     
;;;93         //advertising parameters
;;;94         uint8_t  adv_evt_type = GAP_ADTYPE_ADV_IND;
        0x0080ec14:    2000        .       MOVS     r0,#0
        0x0080ec16:    900f        ..      STR      r0,[sp,#0x3c]
;;;95         uint8_t  adv_direct_type = GAP_REMOTE_ADDR_LE_PUBLIC;
        0x0080ec18:    900e        ..      STR      r0,[sp,#0x38]
;;;96         uint8_t  adv_direct_addr[GAP_BD_ADDR_LEN] = {0};
        0x0080ec1a:    900c        ..      STR      r0,[sp,#0x30]
        0x0080ec1c:    900d        ..      STR      r0,[sp,#0x34]
;;;97         uint8_t  adv_chann_map = GAP_ADVCHAN_ALL;
        0x0080ec1e:    2007        .       MOVS     r0,#7
        0x0080ec20:    900b        ..      STR      r0,[sp,#0x2c]
;;;98         uint8_t  adv_filter_policy = GAP_ADV_FILTER_ANY;
        0x0080ec22:    2000        .       MOVS     r0,#0
        0x0080ec24:    900a        ..      STR      r0,[sp,#0x28]
;;;99         uint16_t adv_int_min = DEFAULT_ADVERTISING_INTERVAL_MIN;
        0x0080ec26:    f44f70a0    O..p    MOV      r0,#0x140
        0x0080ec2a:    9009        ..      STR      r0,[sp,#0x24]
;;;100        uint16_t adv_int_max = DEFAULT_ADVERTISING_INTERVAL_MIN;
        0x0080ec2c:    9008        ..      STR      r0,[sp,#0x20]
;;;101    
;;;102        //GAP Bond Manager parameters
;;;103        uint8_t  auth_pair_mode = GAP_PAIRING_MODE_PAIRABLE;
        0x0080ec2e:    2001        .       MOVS     r0,#1
        0x0080ec30:    9007        ..      STR      r0,[sp,#0x1c]
;;;104        uint16_t auth_flags = GAP_AUTHEN_BIT_BONDING_FLAG | GAP_AUTHEN_BIT_MITM_FLAG;
        0x0080ec32:    2005        .       MOVS     r0,#5
        0x0080ec34:    9006        ..      STR      r0,[sp,#0x18]
;;;105        uint8_t  auth_io_cap = GAP_IO_CAP_NO_INPUT_NO_OUTPUT;
        0x0080ec36:    2003        .       MOVS     r0,#3
        0x0080ec38:    9005        ..      STR      r0,[sp,#0x14]
;;;106        uint8_t  auth_oob = false;
        0x0080ec3a:    2000        .       MOVS     r0,#0
        0x0080ec3c:    9004        ..      STR      r0,[sp,#0x10]
;;;107        uint8_t  auth_use_fix_passkey = false;
        0x0080ec3e:    9003        ..      STR      r0,[sp,#0xc]
;;;108        uint32_t auth_fix_passkey = 0;
        0x0080ec40:    9002        ..      STR      r0,[sp,#8]
;;;109        uint8_t  auth_sec_req_enalbe = false;
        0x0080ec42:    9001        ..      STR      r0,[sp,#4]
;;;110        uint16_t auth_sec_req_flags = GAP_AUTHEN_BIT_NONE;
        0x0080ec44:    9000        ..      STR      r0,[sp,#0]
;;;111    
;;;112        //Register gap callback
;;;113        le_register_app_cb(app_gap_callback);
        0x0080ec46:    48bd        .H      LDR      r0,[pc,#756] ; [0x80ef3c] = 0x80f4ed
        0x0080ec48:    f43df7fb    =...    BL       le_register_app_cb ; 0x4cc42
;;;114    
;;;115        //Set device name and device appearance
;;;116        le_set_gap_param(GAP_PARAM_DEVICE_NAME, GAP_DEVICE_NAME_LEN, device_name);
        0x0080ec4c:    aa11        ..      ADD      r2,sp,#0x44
        0x0080ec4e:    2128        (!      MOVS     r1,#0x28
        0x0080ec50:    f2402022    @."     MOV      r0,#0x222
        0x0080ec54:    f43df7f8    =...    BL       le_set_gap_param ; 0x4cc48
;;;117        le_set_gap_param(GAP_PARAM_APPEARANCE, sizeof(appearance), &appearance);
        0x0080ec58:    aa10        ..      ADD      r2,sp,#0x40
        0x0080ec5a:    2102        .!      MOVS     r1,#2
        0x0080ec5c:    f2402021    @.!     MOV      r0,#0x221
        0x0080ec60:    f43df7f2    =...    BL       le_set_gap_param ; 0x4cc48
;;;118    
;;;119        //Set advertising parameters
;;;120        le_adv_set_param(GAP_PARAM_ADV_EVENT_TYPE, sizeof(adv_evt_type), &adv_evt_type);
        0x0080ec64:    aa0f        ..      ADD      r2,sp,#0x3c
        0x0080ec66:    2101        .!      MOVS     r1,#1
        0x0080ec68:    f2402063    @.c     MOV      r0,#0x263
        0x0080ec6c:    f443f110    C...    BL       le_adv_set_param ; 0x51e90
;;;121        le_adv_set_param(GAP_PARAM_ADV_DIRECT_ADDR_TYPE, sizeof(adv_direct_type), &adv_direct_type);
        0x0080ec70:    aa0e        ..      ADD      r2,sp,#0x38
        0x0080ec72:    2101        .!      MOVS     r1,#1
        0x0080ec74:    f44f7019    O..p    MOV      r0,#0x264
        0x0080ec78:    f443f10a    C...    BL       le_adv_set_param ; 0x51e90
;;;122        le_adv_set_param(GAP_PARAM_ADV_DIRECT_ADDR, sizeof(adv_direct_addr), adv_direct_addr);
        0x0080ec7c:    aa0c        ..      ADD      r2,sp,#0x30
        0x0080ec7e:    2106        .!      MOVS     r1,#6
        0x0080ec80:    f2402065    @.e     MOV      r0,#0x265
        0x0080ec84:    f443f104    C...    BL       le_adv_set_param ; 0x51e90
;;;123        le_adv_set_param(GAP_PARAM_ADV_CHANNEL_MAP, sizeof(adv_chann_map), &adv_chann_map);
        0x0080ec88:    aa0b        ..      ADD      r2,sp,#0x2c
        0x0080ec8a:    2101        .!      MOVS     r1,#1
        0x0080ec8c:    f2402066    @.f     MOV      r0,#0x266
        0x0080ec90:    f443f0fe    C...    BL       le_adv_set_param ; 0x51e90
;;;124        le_adv_set_param(GAP_PARAM_ADV_FILTER_POLICY, sizeof(adv_filter_policy), &adv_filter_policy);
        0x0080ec94:    aa0a        ..      ADD      r2,sp,#0x28
        0x0080ec96:    2101        .!      MOVS     r1,#1
        0x0080ec98:    f2402067    @.g     MOV      r0,#0x267
        0x0080ec9c:    f443f0f8    C...    BL       le_adv_set_param ; 0x51e90
;;;125        le_adv_set_param(GAP_PARAM_ADV_INTERVAL_MIN, sizeof(adv_int_min), &adv_int_min);
        0x0080eca0:    aa09        ..      ADD      r2,sp,#0x24
        0x0080eca2:    2102        .!      MOVS     r1,#2
        0x0080eca4:    f44f701a    O..p    MOV      r0,#0x268
        0x0080eca8:    f443f0f2    C...    BL       le_adv_set_param ; 0x51e90
;;;126        le_adv_set_param(GAP_PARAM_ADV_INTERVAL_MAX, sizeof(adv_int_max), &adv_int_max);
        0x0080ecac:    aa08        ..      ADD      r2,sp,#0x20
        0x0080ecae:    2102        .!      MOVS     r1,#2
        0x0080ecb0:    f2402069    @.i     MOV      r0,#0x269
        0x0080ecb4:    f443f0ec    C...    BL       le_adv_set_param ; 0x51e90
;;;127        le_adv_set_param(GAP_PARAM_ADV_DATA, sizeof(ADV_DATA), ADV_DATA);
        0x0080ecb8:    4aa1        .J      LDR      r2,[pc,#644] ; [0x80ef40] = 0x207d59
        0x0080ecba:    2110        .!      MOVS     r1,#0x10
        0x0080ecbc:    f2402061    @.a     MOV      r0,#0x261
        0x0080ecc0:    f443f0e6    C...    BL       le_adv_set_param ; 0x51e90
;;;128        le_adv_set_param(GAP_PARAM_SCAN_RSP_DATA, sizeof(SCAN_RSP_DATA), SCAN_RSP_DATA);
        0x0080ecc4:    4a9f        .J      LDR      r2,[pc,#636] ; [0x80ef44] = 0x207d55
        0x0080ecc6:    2104        .!      MOVS     r1,#4
        0x0080ecc8:    f2402062    @.b     MOV      r0,#0x262
        0x0080eccc:    f443f0e0    C...    BL       le_adv_set_param ; 0x51e90
;;;129    
;;;130        // Setup the GAP Bond Manager
;;;131        gap_set_param(GAP_PARAM_BOND_PAIRING_MODE, sizeof(auth_pair_mode), &auth_pair_mode);
        0x0080ecd0:    aa07        ..      ADD      r2,sp,#0x1c
        0x0080ecd2:    2101        .!      MOVS     r1,#1
        0x0080ecd4:    f2402002    @..     MOV      r0,#0x202
        0x0080ecd8:    f43df167    =.g.    BL       gap_set_param ; 0x4bfaa
;;;132        gap_set_param(GAP_PARAM_BOND_AUTHEN_REQUIREMENTS_FLAGS, sizeof(auth_flags), &auth_flags);
        0x0080ecdc:    aa06        ..      ADD      r2,sp,#0x18
        0x0080ecde:    2102        .!      MOVS     r1,#2
        0x0080ece0:    f2402003    @..     MOV      r0,#0x203
        0x0080ece4:    f43df161    =.a.    BL       gap_set_param ; 0x4bfaa
;;;133        gap_set_param(GAP_PARAM_BOND_IO_CAPABILITIES, sizeof(auth_io_cap), &auth_io_cap);
        0x0080ece8:    aa05        ..      ADD      r2,sp,#0x14
        0x0080ecea:    2101        .!      MOVS     r1,#1
        0x0080ecec:    f44f7001    O..p    MOV      r0,#0x204
        0x0080ecf0:    f43df15b    =.[.    BL       gap_set_param ; 0x4bfaa
;;;134        gap_set_param(GAP_PARAM_BOND_OOB_ENABLED, sizeof(auth_oob), &auth_oob);
        0x0080ecf4:    aa04        ..      ADD      r2,sp,#0x10
        0x0080ecf6:    2101        .!      MOVS     r1,#1
        0x0080ecf8:    f2402005    @..     MOV      r0,#0x205
        0x0080ecfc:    f43df155    =.U.    BL       gap_set_param ; 0x4bfaa
;;;135        le_bond_set_param(GAP_PARAM_BOND_FIXED_PASSKEY, sizeof(auth_fix_passkey), &auth_fix_passkey);
        0x0080ed00:    aa02        ..      ADD      r2,sp,#8
        0x0080ed02:    2104        .!      MOVS     r1,#4
        0x0080ed04:    f2402011    @..     MOV      r0,#0x211
        0x0080ed08:    f43df271    =.q.    BL       le_bond_set_param ; 0x4c1ee
;;;136        le_bond_set_param(GAP_PARAM_BOND_FIXED_PASSKEY_ENABLE, sizeof(auth_use_fix_passkey),
        0x0080ed0c:    aa03        ..      ADD      r2,sp,#0xc
        0x0080ed0e:    2101        .!      MOVS     r1,#1
        0x0080ed10:    f2402012    @..     MOV      r0,#0x212
        0x0080ed14:    f43df26b    =.k.    BL       le_bond_set_param ; 0x4c1ee
;;;137                          &auth_use_fix_passkey);
;;;138        le_bond_set_param(GAP_PARAM_BOND_SEC_REQ_ENABLE, sizeof(auth_sec_req_enalbe), &auth_sec_req_enalbe);
        0x0080ed18:    aa01        ..      ADD      r2,sp,#4
        0x0080ed1a:    2101        .!      MOVS     r1,#1
        0x0080ed1c:    f2402013    @..     MOV      r0,#0x213
        0x0080ed20:    f43df265    =.e.    BL       le_bond_set_param ; 0x4c1ee
;;;139        le_bond_set_param(GAP_PARAM_BOND_SEC_REQ_REQUIREMENT, sizeof(auth_sec_req_flags),
        0x0080ed24:    466a        jF      MOV      r2,sp
        0x0080ed26:    2102        .!      MOVS     r1,#2
        0x0080ed28:    f44f7005    O..p    MOV      r0,#0x214
        0x0080ed2c:    f43df25f    =._.    BL       le_bond_set_param ; 0x4c1ee
;;;140                          &auth_sec_req_flags);
;;;141    
;;;142    }
        0x0080ed30:    b01b        ..      ADD      sp,sp,#0x6c
        0x0080ed32:    bd00        ..      POP      {pc}
    app_le_profile_init
;;;143    
;;;144    /******************************************************************
;;;145     * @fn          Initial profile
;;;146     * @brief      Add simple profile service and register callbacks
;;;147     *
;;;148     * @return     void
;;;149     */
;;;150    void app_le_profile_init(void)
;;;151    {
        0x0080ed34:    b510        ..      PUSH     {r4,lr}
;;;152        server_init(3);
        0x0080ed36:    2003        .       MOVS     r0,#3
        0x0080ed38:    f440f3e4    @...    BL       server_init ; 0x4f504
;;;153        g_bas_service_id = bas_add_service(app_profile_callback);
        0x0080ed3c:    4882        .H      LDR      r0,[pc,#520] ; [0x80ef48] = 0x80f587
        0x0080ed3e:    f000feda    ....    BL       bas_add_service ; 0x80faf6
        0x0080ed42:    4982        .I      LDR      r1,[pc,#520] ; [0x80ef4c] = 0x207e3d
        0x0080ed44:    7008        .p      STRB     r0,[r1,#0]
;;;154        g_dis_service_id = dis_add_service(app_profile_callback);
        0x0080ed46:    4880        .H      LDR      r0,[pc,#512] ; [0x80ef48] = 0x80f587
        0x0080ed48:    f001f843    ..C.    BL       dis_add_service ; 0x80fdd2
        0x0080ed4c:    4980        .I      LDR      r1,[pc,#512] ; [0x80ef50] = 0x207e3e
        0x0080ed4e:    7008        .p      STRB     r0,[r1,#0]
;;;155        g_ota_service_id = ota_add_service(app_profile_callback);
        0x0080ed50:    487d        }H      LDR      r0,[pc,#500] ; [0x80ef48] = 0x80f587
        0x0080ed52:    f001fa7c    ..|.    BL       ota_add_service ; 0x81024e
        0x0080ed56:    497f        .I      LDR      r1,[pc,#508] ; [0x80ef54] = 0x207e3f
        0x0080ed58:    7008        .p      STRB     r0,[r1,#0]
;;;156        server_register_app_cb(app_profile_callback);
        0x0080ed5a:    487b        {H      LDR      r0,[pc,#492] ; [0x80ef48] = 0x80f587
        0x0080ed5c:    f440f3eb    @...    BL       server_register_app_cb ; 0x4f536
;;;157    }
        0x0080ed60:    bd10        ..      POP      {r4,pc}
    board_init
;;;158    /**
;;;159    * @brief    Board_Init() contains the initialization of pinmux settings and pad settings.
;;;160    *
;;;161    *               All the pinmux settings and pad settings shall be initiated in this function.
;;;162    *               But if legacy driver is used, the initialization of pinmux setting and pad setting
;;;163    *               should be peformed with the IO initializing.
;;;164    *
;;;165    * @return  void
;;;166    */
;;;167    void board_init(void)
;;;168    {
        0x0080ed62:    b51c        ..      PUSH     {r2-r4,lr}
;;;169        Pinmux_Config(TP0, DWGPIO);
        0x0080ed64:    215a        Z!      MOVS     r1,#0x5a
        0x0080ed66:    2000        .       MOVS     r0,#0
        0x0080ed68:    f402f304    ....    BL       Pinmux_Config ; 0x11374
;;;170        Pad_Config(TP0, PAD_PINMUX_MODE, PAD_IS_PWRON, PAD_PULL_DOWN, PAD_OUT_DISABLE, PAD_OUT_LOW);
        0x0080ed6c:    2000        .       MOVS     r0,#0
        0x0080ed6e:    9000        ..      STR      r0,[sp,#0]
        0x0080ed70:    2302        .#      MOVS     r3,#2
        0x0080ed72:    2201        ."      MOVS     r2,#1
        0x0080ed74:    4611        .F      MOV      r1,r2
        0x0080ed76:    9001        ..      STR      r0,[sp,#4]
        0x0080ed78:    f402f330    ..0.    BL       Pad_Config ; 0x113dc
;;;171    }
        0x0080ed7c:    bd1c        ..      POP      {r2-r4,pc}
    driver_init
;;;172    
;;;173    /**
;;;174    * @brief    Driver_Init() contains the initialization of peripherals.
;;;175    *
;;;176    *               Both new architecture driver and legacy driver initialization method can be used.
;;;177    *
;;;178    * @return  void
;;;179    */
;;;180    void driver_init(void)
;;;181    {
        0x0080ed7e:    b51f        ..      PUSH     {r0-r4,lr}
;;;182        RCC_PeriphClockCmd(APBPeriph_GPIO, APBPeriph_GPIO_CLOCK, ENABLE);
        0x0080ed80:    2201        ."      MOVS     r2,#1
        0x0080ed82:    f04f5104    O..Q    MOV      r1,#0x21000000
        0x0080ed86:    4874        tH      LDR      r0,[pc,#464] ; [0x80ef58] = 0xc000100
        0x0080ed88:    f001fab6    ....    BL       RCC_PeriphClockCmd ; 0x8102f8
;;;183        GPIO_InitTypeDef gpio_struct;
;;;184        GPIO_StructInit(&gpio_struct);
        0x0080ed8c:    4668        hF      MOV      r0,sp
        0x0080ed8e:    f001fd80    ....    BL       GPIO_StructInit ; 0x810892
;;;185        gpio_struct.GPIO_Pin = GPIO_GetPin(TP0);
        0x0080ed92:    2000        .       MOVS     r0,#0
        0x0080ed94:    f001fda7    ....    BL       GPIO_GetPin ; 0x8108e6
        0x0080ed98:    9000        ..      STR      r0,[sp,#0]
;;;186        gpio_struct.GPIO_Mode = GPIO_Mode_IN;
        0x0080ed9a:    2000        .       MOVS     r0,#0
        0x0080ed9c:    f88d0004    ....    STRB     r0,[sp,#4]
;;;187        GPIO_Init(&gpio_struct);
        0x0080eda0:    4668        hF      MOV      r0,sp
        0x0080eda2:    f001fcff    ....    BL       GPIO_Init ; 0x8107a4
;;;188        g_ota_mode = !GPIO_ReadInputDataBit(GPIO_GetPin(TP0));
        0x0080eda6:    2000        .       MOVS     r0,#0
        0x0080eda8:    f001fd9d    ....    BL       GPIO_GetPin ; 0x8108e6
        0x0080edac:    4604        .F      MOV      r4,r0
;;; ..\..\..\inc\peripheral\rtl876x_gpio.h
;;;386        uint8_t bitstatus = RESET;
        0x0080edae:    2000        .       MOVS     r0,#0
;;;387    
;;;388        /* Check the parameters */
;;;389        assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
;;;390    
;;;391        if (GPIO->DATAIN & GPIO_Pin)
        0x0080edb0:    496a        jI      LDR      r1,[pc,#424] ; [0x80ef5c] = 0x40001000
        0x0080edb2:    6d09        .m      LDR      r1,[r1,#0x50]
        0x0080edb4:    4021        !@      ANDS     r1,r1,r4
        0x0080edb6:    b101        ..      CBZ      r1,0x80edba ; driver_init + 60
;;;392        {
;;;393            bitstatus = (uint8_t)SET;
        0x0080edb8:    2001        .       MOVS     r0,#1
;;;394        }
;;;395    
;;;396        return bitstatus;
        0x0080edba:    bf00        ..      NOP      
        0x0080edbc:    b908        ..      CBNZ     r0,0x80edc2 ; driver_init + 68
        0x0080edbe:    2001        .       MOVS     r0,#1
        0x0080edc0:    e000        ..      B        0x80edc4 ; driver_init + 70
        0x0080edc2:    2000        .       MOVS     r0,#0
        0x0080edc4:    4966        fI      LDR      r1,[pc,#408] ; [0x80ef60] = 0x207e3c
        0x0080edc6:    7008        .p      STRB     r0,[r1,#0]
;;; ..\..\..\src\app\ota\main.c
;;;189    }
        0x0080edc8:    bd1f        ..      POP      {r0-r4,pc}
    pwr_mgr_init
;;;190    
;;;191    #if DLPS_EN
;;;192    /**
;;;193     * @brief this function will be called before enter DLPS
;;;194     *
;;;195     *  set PAD and wakeup pin config for enterring DLPS
;;;196     *
;;;197     * @param none
;;;198     * @return none
;;;199     * @retval void
;;;200    */
;;;201    void ota_enter_dlps_set(void)
;;;202    {
;;;203    
;;;204    }
;;;205    
;;;206    /**
;;;207     * @brief this function will be called after exit DLPS
;;;208     *
;;;209     *  set PAD and wakeup pin config for enterring DLPS
;;;210     *
;;;211     * @param none
;;;212     * @return none
;;;213     * @retval void
;;;214    */
;;;215    void ota_exit_dlps_init(void)
;;;216    {
;;;217    
;;;218    }
;;;219    
;;;220    bool dlps_ota_check(void)
;;;221    {
;;;222        return allowed_ota_enter_dlps;
;;;223    }
;;;224    #endif
;;;225    
;;;226    /**
;;;227    * @brief    PwrMgr_Init() contains the setting about power mode.
;;;228    *
;;;229    * @return  void
;;;230    */
;;;231    void pwr_mgr_init(void)
;;;232    {
;;;233    #if DLPS_EN
;;;234        if (false == dlps_check_cb_reg(dlps_ota_check))
;;;235        {
;;;236            DBG_DIRECT("Error: dlps_check_cb_reg(dlps_ota_check) failed!\n");
;;;237        }
;;;238        DLPS_IORegUserDlpsEnterCb(ota_enter_dlps_set);
;;;239        DLPS_IORegUserDlpsExitCb(ota_exit_dlps_init);
;;;240        DLPS_IORegister();
;;;241        lps_mode_set(LPM_DLPS_MODE);
;;;242    #endif
;;;243    }
        0x0080edca:    4770        pG      BX       lr
    task_init
;;;244    
;;;245    
;;;246    /**
;;;247    * @brief  Task_Init() contains the initialization of all the tasks.
;;;248    *
;;;249    *           There are four tasks are initiated.
;;;250    *           Lowerstack task and upperstack task are used by bluetooth stack.
;;;251    *           Application task is task which user application code resides in.
;;;252    *           Emergency task is reserved.
;;;253    *
;;;254    * @return  void
;;;255    */
;;;256    void task_init(void)
;;;257    {
        0x0080edcc:    b510        ..      PUSH     {r4,lr}
;;;258        app_task_init();
        0x0080edce:    f7fffebd    ....    BL       app_task_init ; 0x80eb4c
;;;259    }
        0x0080edd2:    bd10        ..      POP      {r4,pc}
    print_all_images_version
;;;260    
;;;261    /**
;;;262    * @brief  print all images version to check ota whether success.
;;;263    * @return  void
;;;264    */
;;;265    void print_all_images_version(void)
;;;266    {
        0x0080edd4:    b510        ..      PUSH     {r4,lr}
        0x0080edd6:    b086        ..      SUB      sp,sp,#0x18
;;;267        T_IMG_ID image_id;
;;;268        T_IMAGE_VERSION image_version;
;;;269    
;;;270        image_id = OTA;
        0x0080edd8:    f2427490    B..t    MOV      r4,#0x2790
;;;271        if (get_active_bank_image_version(image_id, &image_version))
        0x0080eddc:    a905        ..      ADD      r1,sp,#0x14
        0x0080edde:    4620         F      MOV      r0,r4
        0x0080ede0:    f7fffecc    ....    BL       get_active_bank_image_version ; 0x80eb7c
        0x0080ede4:    b1b0        ..      CBZ      r0,0x80ee14 ; print_all_images_version + 64
;;;272        {
;;;273            DBG_DIRECT("image:0x%x,version =0x%x, sub_version:%d.%d.%d.%d", image_id,
        0x0080ede6:    bf00        ..      NOP      
        0x0080ede8:    9805        ..      LDR      r0,[sp,#0x14]
        0x0080edea:    b2c0        ..      UXTB     r0,r0
        0x0080edec:    9905        ..      LDR      r1,[sp,#0x14]
        0x0080edee:    f3c12107    ...!    UBFX     r1,r1,#8,#8
        0x0080edf2:    9a05        ..      LDR      r2,[sp,#0x14]
        0x0080edf4:    f3c24207    ...B    UBFX     r2,r2,#16,#8
        0x0080edf8:    9b05        ..      LDR      r3,[sp,#0x14]
        0x0080edfa:    0e1b        ..      LSRS     r3,r3,#24
        0x0080edfc:    e9cd3200    ...2    STRD     r3,r2,[sp,#0]
        0x0080ee00:    e9cd1002    ....    STRD     r1,r0,[sp,#8]
        0x0080ee04:    4622        "F      MOV      r2,r4
        0x0080ee06:    a157        W.      ADR      r1,{pc}+0x15e ; 0x80ef64
        0x0080ee08:    f04f5004    O..P    MOV      r0,#0x21000000
        0x0080ee0c:    9b05        ..      LDR      r3,[sp,#0x14]
        0x0080ee0e:    f7f8ddcf    ....    BL       log_direct ; 0x79b0
        0x0080ee12:    e007        ..      B        0x80ee24 ; print_all_images_version + 80
;;;274                       image_version.ver_info.version,
;;;275                       image_version.ver_info.header_sub_version._version_major,
;;;276                       image_version.ver_info.header_sub_version._version_minor,
;;;277                       image_version.ver_info.header_sub_version._version_revision,
;;;278                       image_version.ver_info.header_sub_version._version_reserve);
;;;279        }
;;;280        else
;;;281        {
;;;282            DBG_DIRECT("image:0x%x get_active_bank_image_version fail!!!", image_id);
        0x0080ee14:    bf00        ..      NOP      
        0x0080ee16:    4622        "F      MOV      r2,r4
        0x0080ee18:    a15f        _.      ADR      r1,{pc}+0x180 ; 0x80ef98
        0x0080ee1a:    f04f5004    O..P    MOV      r0,#0x21000000
        0x0080ee1e:    f7f8ddc7    ....    BL       log_direct ; 0x79b0
        0x0080ee22:    bf00        ..      NOP      
;;;283        }
;;;284    
;;;285        for (image_id = SecureBoot; image_id < IMAGE_MAX; image_id++)
        0x0080ee24:    f2427491    B..t    MOV      r4,#0x2791
        0x0080ee28:    e024        $.      B        0x80ee74 ; print_all_images_version + 160
        0x0080ee2a:    a905        ..      ADD      r1,sp,#0x14
        0x0080ee2c:    4620         F      MOV      r0,r4
        0x0080ee2e:    f7fffea5    ....    BL       get_active_bank_image_version ; 0x80eb7c
        0x0080ee32:    b1a8        ..      CBZ      r0,0x80ee60 ; print_all_images_version + 140
        0x0080ee34:    bf00        ..      NOP      
        0x0080ee36:    9805        ..      LDR      r0,[sp,#0x14]
        0x0080ee38:    0ec1        ..      LSRS     r1,r0,#27
        0x0080ee3a:    f3c0320e    ...2    UBFX     r2,r0,#12,#15
        0x0080ee3e:    f3c01007    ....    UBFX     r0,r0,#4,#8
        0x0080ee42:    9b05        ..      LDR      r3,[sp,#0x14]
        0x0080ee44:    f003030f    ....    AND      r3,r3,#0xf
        0x0080ee48:    e9cd3000    ...0    STRD     r3,r0,[sp,#0]
        0x0080ee4c:    e9cd2102    ...!    STRD     r2,r1,[sp,#8]
        0x0080ee50:    4622        "F      MOV      r2,r4
        0x0080ee52:    a144        D.      ADR      r1,{pc}+0x112 ; 0x80ef64
        0x0080ee54:    f04f5004    O..P    MOV      r0,#0x21000000
        0x0080ee58:    9b05        ..      LDR      r3,[sp,#0x14]
        0x0080ee5a:    f7f8dda9    ....    BL       log_direct ; 0x79b0
        0x0080ee5e:    e007        ..      B        0x80ee70 ; print_all_images_version + 156
        0x0080ee60:    bf00        ..      NOP      
        0x0080ee62:    4622        "F      MOV      r2,r4
        0x0080ee64:    a14c        L.      ADR      r1,{pc}+0x134 ; 0x80ef98
        0x0080ee66:    f04f5004    O..P    MOV      r0,#0x21000000
        0x0080ee6a:    f7f8dda1    ....    BL       log_direct ; 0x79b0
        0x0080ee6e:    bf00        ..      NOP      
        0x0080ee70:    1c60        `.      ADDS     r0,r4,#1
        0x0080ee72:    b284        ..      UXTH     r4,r0
        0x0080ee74:    f242709a    B..p    MOV      r0,#0x279a
        0x0080ee78:    4284        .B      CMP      r4,r0
        0x0080ee7a:    dbd6        ..      BLT      0x80ee2a ; print_all_images_version + 86
;;;286        {
;;;287            if (get_active_bank_image_version(image_id, &image_version))
;;;288            {
;;;289                DBG_DIRECT("image:0x%x,version =0x%x, sub_version:%d.%d.%d.%d", image_id,
;;;290                           image_version.ver_info.version,
;;;291                           image_version.ver_info.img_sub_version._version_major,
;;;292                           image_version.ver_info.img_sub_version._version_minor,
;;;293                           image_version.ver_info.img_sub_version._version_revision,
;;;294                           image_version.ver_info.img_sub_version._version_reserve);
;;;295            }
;;;296            else
;;;297            {
;;;298                DBG_DIRECT("image:0x%x get_active_bank_image_version fail!!!", image_id);
;;;299            }
;;;300        }
;;;301    }
        0x0080ee7c:    b006        ..      ADD      sp,sp,#0x18
        0x0080ee7e:    bd10        ..      POP      {r4,pc}
    user_pre_main
;;;302    
;;;303    void user_pre_main(void)
;;;304    {
        0x0080ee80:    b510        ..      PUSH     {r4,lr}
;;;305        DBG_DIRECT("user_pre_main");
        0x0080ee82:    bf00        ..      NOP      
        0x0080ee84:    a151        Q.      ADR      r1,{pc}+0x148 ; 0x80efcc
        0x0080ee86:    f04f5004    O..P    MOV      r0,#0x21000000
        0x0080ee8a:    f7f8dd91    ....    BL       log_direct ; 0x79b0
        0x0080ee8e:    bf00        ..      NOP      
;;;306    }
        0x0080ee90:    bd10        ..      POP      {r4,pc}
    main
;;;307    
;;;308    USER_CALL_BACK app_pre_main_cb = user_pre_main;
;;;309    
;;;310    int main(void)
;;;311    {
        0x0080ee92:    b510        ..      PUSH     {r4,lr}
;;;312        extern uint32_t random_seed_value;
;;;313        srand(random_seed_value);
        0x0080ee94:    4851        QH      LDR      r0,[pc,#324] ; [0x80efdc] = 0x207e1c
        0x0080ee96:    6800        .h      LDR      r0,[r0,#0]
        0x0080ee98:    f002fb52    ..R.    BL       srand ; 0x811540
;;;314    
;;;315        DBG_DIRECT("Normal ota main");
        0x0080ee9c:    bf00        ..      NOP      
        0x0080ee9e:    a150        P.      ADR      r1,{pc}+0x142 ; 0x80efe0
        0x0080eea0:    f04f5004    O..P    MOV      r0,#0x21000000
        0x0080eea4:    f7f8dd84    ....    BL       log_direct ; 0x79b0
        0x0080eea8:    bf00        ..      NOP      
;;;316        print_all_images_version();
        0x0080eeaa:    f7ffff93    ....    BL       print_all_images_version ; 0x80edd4
;;;317    
;;;318        board_init();
        0x0080eeae:    f7ffff58    ..X.    BL       board_init ; 0x80ed62
;;;319        driver_init();
        0x0080eeb2:    f7ffff64    ..d.    BL       driver_init ; 0x80ed7e
;;;320    
;;;321        le_gap_init(1);
        0x0080eeb6:    2001        .       MOVS     r0,#1
        0x0080eeb8:    f43df680    =...    BL       le_gap_init ; 0x4cbbc
;;;322        gap_lib_init();
        0x0080eebc:    f001fd9b    ....    BL       gap_lib_init ; 0x8109f6
;;;323        app_le_gap_init();
        0x0080eec0:    f7fffe9e    ....    BL       app_le_gap_init ; 0x80ec00
;;;324        app_le_profile_init();
        0x0080eec4:    f7ffff36    ..6.    BL       app_le_profile_init ; 0x80ed34
;;;325        pwr_mgr_init();
        0x0080eec8:    f7ffff7f    ....    BL       pwr_mgr_init ; 0x80edca
;;;326        task_init();
        0x0080eecc:    f7ffff7e    ..~.    BL       task_init ; 0x80edcc
;;;327        os_sched_start();
        0x0080eed0:    f417f477    ..w.    BL       os_sched_start ; 0x267c2
;;;328    
;;;329        return 0;
        0x0080eed4:    2000        .       MOVS     r0,#0
;;;330    }
        0x0080eed6:    bd10        ..      POP      {r4,pc}
    get_active_bank_image_size_by_img_id
;;; ..\..\..\inc\platform\patch_header_check.h
;;;282    {
        0x0080eed8:    b570        p.      PUSH     {r4-r6,lr}
        0x0080eeda:    4604        .F      MOV      r4,r0
;;;283        uint32_t image_size = 0;
        0x0080eedc:    2600        .&      MOVS     r6,#0
;;;284    
;;;285        if (image_id < OTA || image_id >= IMAGE_MAX) //not support
        0x0080eede:    f2427090    B..p    MOV      r0,#0x2790
        0x0080eee2:    4284        .B      CMP      r4,r0
        0x0080eee4:    db03        ..      BLT      0x80eeee ; get_active_bank_image_size_by_img_id + 22
        0x0080eee6:    f242709a    B..p    MOV      r0,#0x279a
        0x0080eeea:    4284        .B      CMP      r4,r0
        0x0080eeec:    db01        ..      BLT      0x80eef2 ; get_active_bank_image_size_by_img_id + 26
;;;286        {
;;;287            return image_size;
        0x0080eeee:    4630        0F      MOV      r0,r6
        0x0080eef0:    bd70        p.      POP      {r4-r6,pc}
;;;288        }
;;;289        else
;;;290        {
;;;291            uint32_t ota_header_addr = get_active_ota_bank_addr();
        0x0080eef2:    f7f2d96b    ..k.    BL       get_active_ota_bank_addr ; 0x11cc
        0x0080eef6:    4605        .F      MOV      r5,r0
;;;292    
;;;293            if (!check_header_valid(ota_header_addr, OTA))
        0x0080eef8:    f2427190    B..q    MOV      r1,#0x2790
        0x0080eefc:    4628        (F      MOV      r0,r5
        0x0080eefe:    f7fddc53    ..S.    BL       check_header_valid ; 0xc7a8
        0x0080ef02:    b908        ..      CBNZ     r0,0x80ef08 ; get_active_bank_image_size_by_img_id + 48
;;;294            {
;;;295                return image_size;
        0x0080ef04:    4630        0F      MOV      r0,r6
        0x0080ef06:    e7f3        ..      B        0x80eef0 ; get_active_bank_image_size_by_img_id + 24
;;;296            }
;;;297            else
;;;298            {
;;;299                if (image_id == OTA)
        0x0080ef08:    f2427090    B..p    MOV      r0,#0x2790
        0x0080ef0c:    4284        .B      CMP      r4,r0
        0x0080ef0e:    d102        ..      BNE      0x80ef16 ; get_active_bank_image_size_by_img_id + 62
;;;300                {
;;;301                    image_size = OTA_HEADER_SIZE;
        0x0080ef10:    f44f5680    O..V    MOV      r6,#0x1000
        0x0080ef14:    e00c        ..      B        0x80ef30 ; get_active_bank_image_size_by_img_id + 88
;;;302                }
;;;303                else
;;;304                {
;;;305                    T_OTA_HEADER_FORMAT *ota_header = (T_OTA_HEADER_FORMAT *)ota_header_addr;
        0x0080ef16:    4628        (F      MOV      r0,r5
;;;306    
;;;307                    image_size = HAL_READ32((uint32_t)&ota_header->secure_boot_size, (image_id - SecureBoot) * 8);
        0x0080ef18:    f5a4511c    ...Q    SUB      r1,r4,#0x2700
        0x0080ef1c:    3991        .9      SUBS     r1,r1,#0x91
        0x0080ef1e:    f50072ce    ...r    ADD      r2,r0,#0x19c
        0x0080ef22:    f8526031    R.1`    LDR      r6,[r2,r1,LSL #3]
;;;308    
;;;309                    if (OTA_HEADER_DEFAULT_VALUE == image_size)
        0x0080ef26:    f1b63fff    ...?    CMP      r6,#0xffffffff
        0x0080ef2a:    d100        ..      BNE      0x80ef2e ; get_active_bank_image_size_by_img_id + 86
;;;310                    {
;;;311                        image_size = 0;
        0x0080ef2c:    2600        .&      MOVS     r6,#0
;;;312                    }
;;;313                }
        0x0080ef2e:    bf00        ..      NOP      
;;;314            }
;;;315        }
        0x0080ef30:    bf00        ..      NOP      
;;;316    
;;;317        return image_size;
        0x0080ef32:    4630        0F      MOV      r0,r6
        0x0080ef34:    e7dc        ..      B        0x80eef0 ; get_active_bank_image_size_by_img_id + 24
    $d
        0x0080ef36:    0000        ..      DCW    0
        0x0080ef38:    008116c4    ....    DCD    8459972
        0x0080ef3c:    0080f4ed    ....    DCD    8451309
        0x0080ef40:    00207d59    Y} .    DCD    2129241
        0x0080ef44:    00207d55    U} .    DCD    2129237
        0x0080ef48:    0080f587    ....    DCD    8451463
        0x0080ef4c:    00207e3d    =~ .    DCD    2129469
        0x0080ef50:    00207e3e    >~ .    DCD    2129470
        0x0080ef54:    00207e3f    ?~ .    DCD    2129471
        0x0080ef58:    0c000100    ....    DCD    201326848
        0x0080ef5c:    40001000    ...@    DCD    1073745920
        0x0080ef60:    00207e3c    <~ .    DCD    2129468
        0x0080ef64:    67616d69    imag    DCD    1734438249
        0x0080ef68:    78303a65    e:0x    DCD    2016426597
        0x0080ef6c:    762c7825    %x,v    DCD    1982625829
        0x0080ef70:    69737265    ersi    DCD    1769173605
        0x0080ef74:    3d206e6f    on =    DCD    1025535599
        0x0080ef78:    78257830    0x%x    DCD    2015721520
        0x0080ef7c:    7573202c    , su    DCD    1970479148
        0x0080ef80:    65765f62    b_ve    DCD    1702256482
        0x0080ef84:    6f697372    rsio    DCD    1869181810
        0x0080ef88:    64253a6e    n:%d    DCD    1680161390
        0x0080ef8c:    2e64252e    .%d.    DCD    778315054
        0x0080ef90:    252e6425    %d.%    DCD    623797285
        0x0080ef94:    00000064    d...    DCD    100
        0x0080ef98:    67616d69    imag    DCD    1734438249
        0x0080ef9c:    78303a65    e:0x    DCD    2016426597
        0x0080efa0:    67207825    %x g    DCD    1730181157
        0x0080efa4:    615f7465    et_a    DCD    1633645669
        0x0080efa8:    76697463    ctiv    DCD    1986622563
        0x0080efac:    61625f65    e_ba    DCD    1633836901
        0x0080efb0:    695f6b6e    nk_i    DCD    1767861102
        0x0080efb4:    6567616d    mage    DCD    1701273965
        0x0080efb8:    7265765f    _ver    DCD    1919252063
        0x0080efbc:    6e6f6973    sion    DCD    1852795251
        0x0080efc0:    69616620     fai    DCD    1767990816
        0x0080efc4:    2121216c    l!!!    DCD    555819372
        0x0080efc8:    00000000    ....    DCD    0
        0x0080efcc:    72657375    user    DCD    1919251317
        0x0080efd0:    6572705f    _pre    DCD    1701998687
        0x0080efd4:    69616d5f    _mai    DCD    1767992671
        0x0080efd8:    0000006e    n...    DCD    110
        0x0080efdc:    00207e1c    .~ .    DCD    2129436
        0x0080efe0:    6d726f4e    Norm    DCD    1836216142
        0x0080efe4:    6f206c61    al o    DCD    1864395873
        0x0080efe8:    6d206174    ta m    DCD    1830838644
        0x0080efec:    006e6961    ain.    DCD    7235937
    $t
    .text
    periph_conn_param_update_evt
;;; ..\..\..\src\app\ota\ota_application.c
;;;226    {
        0x0080eff0:    b570        p.      PUSH     {r4-r6,lr}
        0x0080eff2:    b086        ..      SUB      sp,sp,#0x18
        0x0080eff4:    4604        .F      MOV      r4,r0
        0x0080eff6:    460e        .F      MOV      r6,r1
        0x0080eff8:    4615        .F      MOV      r5,r2
;;;227        switch (status)
        0x0080effa:    b126        &.      CBZ      r6,0x80f006 ; periph_conn_param_update_evt + 22
        0x0080effc:    2e01        ..      CMP      r6,#1
        0x0080effe:    d026        &.      BEQ      0x80f04e ; periph_conn_param_update_evt + 94
        0x0080f000:    2e02        ..      CMP      r6,#2
        0x0080f002:    d13a        :.      BNE      0x80f07a ; periph_conn_param_update_evt + 138
        0x0080f004:    e02f        /.      B        0x80f066 ; periph_conn_param_update_evt + 118
;;;228        {
;;;229        case GAP_CONN_PARAM_UPDATE_STATUS_SUCCESS:
;;;230            {
;;;231                uint16_t conn_interval;
;;;232                uint16_t conn_slave_latency;
;;;233                uint16_t conn_supervision_timeout;
;;;234    
;;;235                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
        0x0080f006:    4622        "F      MOV      r2,r4
        0x0080f008:    a905        ..      ADD      r1,sp,#0x14
        0x0080f00a:    f2402072    @.r     MOV      r0,#0x272
        0x0080f00e:    f43ef536    >.6.    BL       le_get_conn_param ; 0x4da7e
;;;236                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_slave_latency, conn_id);
        0x0080f012:    4622        "F      MOV      r2,r4
        0x0080f014:    a904        ..      ADD      r1,sp,#0x10
        0x0080f016:    f2402073    @.s     MOV      r0,#0x273
        0x0080f01a:    f43ef530    >.0.    BL       le_get_conn_param ; 0x4da7e
;;;237                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
        0x0080f01e:    4622        "F      MOV      r2,r4
        0x0080f020:    a903        ..      ADD      r1,sp,#0xc
        0x0080f022:    f44f701d    O..p    MOV      r0,#0x274
        0x0080f026:    f43ef52a    >.*.    BL       le_get_conn_param ; 0x4da7e
;;;238    
;;;239                APP_PRINT_INFO3("GAP_MSG_LE_CONN_PARAM_UPDATE update success, conn_interval = 0x%x, conn_slave_latency = 0x%x, conn_supervision_timeout = 0x%x",
        0x0080f02a:    bf00        ..      NOP      
        0x0080f02c:    bf00        ..      NOP      
        0x0080f02e:    f8bd000c    ....    LDRH     r0,[sp,#0xc]
        0x0080f032:    f8bd1010    ....    LDRH     r1,[sp,#0x10]
        0x0080f036:    e9cd1000    ....    STRD     r1,r0,[sp,#0]
        0x0080f03a:    f8bd3014    ...0    LDRH     r3,[sp,#0x14]
        0x0080f03e:    2203        ."      MOVS     r2,#3
        0x0080f040:    49fa        .I      LDR      r1,[pc,#1000] ; [0x80f42c] = 0x88003e4
        0x0080f042:    48fb        .H      LDR      r0,[pc,#1004] ; [0x80f430] = 0x21103002
        0x0080f044:    f7f8dd0b    ....    BL       log_buffer ; 0x7a5e
        0x0080f048:    bf00        ..      NOP      
        0x0080f04a:    bf00        ..      NOP      
;;;240                                conn_interval, conn_slave_latency, conn_supervision_timeout);
;;;241            }
;;;242            break;
        0x0080f04c:    e016        ..      B        0x80f07c ; periph_conn_param_update_evt + 140
;;;243    
;;;244        case GAP_CONN_PARAM_UPDATE_STATUS_FAIL:
;;;245            {
;;;246                APP_PRINT_ERROR1("GAP_MSG_LE_CONN_PARAM_UPDATE failed: cause 0x%x", cause);
        0x0080f04e:    bf00        ..      NOP      
        0x0080f050:    bf00        ..      NOP      
        0x0080f052:    462b        +F      MOV      r3,r5
        0x0080f054:    2201        ."      MOVS     r2,#1
        0x0080f056:    49f7        .I      LDR      r1,[pc,#988] ; [0x80f434] = 0x8800468
        0x0080f058:    48f5        .H      LDR      r0,[pc,#980] ; [0x80f430] = 0x21103002
        0x0080f05a:    1e80        ..      SUBS     r0,r0,#2
        0x0080f05c:    f7f8dcff    ....    BL       log_buffer ; 0x7a5e
        0x0080f060:    bf00        ..      NOP      
        0x0080f062:    bf00        ..      NOP      
;;;247            }
;;;248            break;
        0x0080f064:    e00a        ..      B        0x80f07c ; periph_conn_param_update_evt + 140
;;;249    
;;;250        case GAP_CONN_PARAM_UPDATE_STATUS_PENDING:
;;;251            {
;;;252                APP_PRINT_INFO0("GAP_MSG_LE_CONN_PARAM_UPDATE request success.");
        0x0080f066:    bf00        ..      NOP      
        0x0080f068:    bf00        ..      NOP      
        0x0080f06a:    2200        ."      MOVS     r2,#0
        0x0080f06c:    49f2        .I      LDR      r1,[pc,#968] ; [0x80f438] = 0x880049c
        0x0080f06e:    48f0        .H      LDR      r0,[pc,#960] ; [0x80f430] = 0x21103002
        0x0080f070:    f7f8dcf5    ....    BL       log_buffer ; 0x7a5e
        0x0080f074:    bf00        ..      NOP      
        0x0080f076:    bf00        ..      NOP      
;;;253            }
;;;254            break;
        0x0080f078:    e000        ..      B        0x80f07c ; periph_conn_param_update_evt + 140
;;;255    
;;;256        default:
;;;257            break;
        0x0080f07a:    bf00        ..      NOP      
        0x0080f07c:    bf00        ..      NOP      
;;;258        }
;;;259    }
        0x0080f07e:    b006        ..      ADD      sp,sp,#0x18
        0x0080f080:    bd70        p.      POP      {r4-r6,pc}
    periph_handle_authen_state_evt
        0x0080f082:    b570        p.      PUSH     {r4-r6,lr}
        0x0080f084:    4605        .F      MOV      r5,r0
        0x0080f086:    460c        .F      MOV      r4,r1
        0x0080f088:    4616        .F      MOV      r6,r2
;;; ..\..\..\src\app\ota\ota_application.c (185)
        0x0080f08a:    bf00        ..      NOP      
        0x0080f08c:    bf00        ..      NOP      
        0x0080f08e:    462b        +F      MOV      r3,r5
        0x0080f090:    2201        ."      MOVS     r2,#1
        0x0080f092:    49ea        .I      LDR      r1,[pc,#936] ; [0x80f43c] = 0x88002b4
        0x0080f094:    48e6        .H      LDR      r0,[pc,#920] ; [0x80f430] = 0x21103002
        0x0080f096:    f7f8dce2    ....    BL       log_buffer ; 0x7a5e
        0x0080f09a:    bf00        ..      NOP      
        0x0080f09c:    bf00        ..      NOP      
;;;186    
;;;187        switch (new_state)
        0x0080f09e:    b114        ..      CBZ      r4,0x80f0a6 ; periph_handle_authen_state_evt + 36
        0x0080f0a0:    2c01        .,      CMP      r4,#1
        0x0080f0a2:    d11e        ..      BNE      0x80f0e2 ; periph_handle_authen_state_evt + 96
        0x0080f0a4:    e009        ..      B        0x80f0ba ; periph_handle_authen_state_evt + 56
;;;188        {
;;;189        case GAP_AUTHEN_STATE_STARTED:
;;;190            {
;;;191                APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_STARTED");
        0x0080f0a6:    bf00        ..      NOP      
        0x0080f0a8:    bf00        ..      NOP      
        0x0080f0aa:    2200        ."      MOVS     r2,#0
        0x0080f0ac:    49e4        .I      LDR      r1,[pc,#912] ; [0x80f440] = 0x88002e4
        0x0080f0ae:    48e0        .H      LDR      r0,[pc,#896] ; [0x80f430] = 0x21103002
        0x0080f0b0:    f7f8dcd5    ....    BL       log_buffer ; 0x7a5e
        0x0080f0b4:    bf00        ..      NOP      
        0x0080f0b6:    bf00        ..      NOP      
;;;192            }
;;;193            break;
        0x0080f0b8:    e01f        ..      B        0x80f0fa ; periph_handle_authen_state_evt + 120
;;;194    
;;;195        case GAP_AUTHEN_STATE_COMPLETE:
;;;196            {
;;;197                if (cause == GAP_SUCCESS)
        0x0080f0ba:    b946        F.      CBNZ     r6,0x80f0ce ; periph_handle_authen_state_evt + 76
;;;198                {
;;;199                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair success");
        0x0080f0bc:    bf00        ..      NOP      
        0x0080f0be:    bf00        ..      NOP      
        0x0080f0c0:    2200        ."      MOVS     r2,#0
        0x0080f0c2:    49e0        .I      LDR      r1,[pc,#896] ; [0x80f444] = 0x8800320
        0x0080f0c4:    48da        .H      LDR      r0,[pc,#872] ; [0x80f430] = 0x21103002
        0x0080f0c6:    f7f8dcca    ....    BL       log_buffer ; 0x7a5e
        0x0080f0ca:    bf00        ..      NOP      
        0x0080f0cc:    e008        ..      B        0x80f0e0 ; periph_handle_authen_state_evt + 94
;;;200    
;;;201                }
;;;202                else
;;;203                {
;;;204                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair failed");
        0x0080f0ce:    bf00        ..      NOP      
        0x0080f0d0:    bf00        ..      NOP      
        0x0080f0d2:    2200        ."      MOVS     r2,#0
        0x0080f0d4:    49dc        .I      LDR      r1,[pc,#880] ; [0x80f448] = 0x8800368
        0x0080f0d6:    48d6        .H      LDR      r0,[pc,#856] ; [0x80f430] = 0x21103002
        0x0080f0d8:    f7f8dcc1    ....    BL       log_buffer ; 0x7a5e
        0x0080f0dc:    bf00        ..      NOP      
        0x0080f0de:    bf00        ..      NOP      
;;;205                }
;;;206            }
;;;207            break;
        0x0080f0e0:    e00b        ..      B        0x80f0fa ; periph_handle_authen_state_evt + 120
;;;208    
;;;209        default:
;;;210            {
;;;211                APP_PRINT_ERROR1("app_handle_authen_state_evt: unknown newstate %d", new_state);
        0x0080f0e2:    bf00        ..      NOP      
        0x0080f0e4:    bf00        ..      NOP      
        0x0080f0e6:    4623        #F      MOV      r3,r4
        0x0080f0e8:    2201        ."      MOVS     r2,#1
        0x0080f0ea:    49d8        .I      LDR      r1,[pc,#864] ; [0x80f44c] = 0x88003b0
        0x0080f0ec:    48d0        .H      LDR      r0,[pc,#832] ; [0x80f430] = 0x21103002
        0x0080f0ee:    1e80        ..      SUBS     r0,r0,#2
        0x0080f0f0:    f7f8dcb5    ....    BL       log_buffer ; 0x7a5e
        0x0080f0f4:    bf00        ..      NOP      
        0x0080f0f6:    bf00        ..      NOP      
;;;212            }
;;;213            break;
        0x0080f0f8:    bf00        ..      NOP      
        0x0080f0fa:    bf00        ..      NOP      
;;;214        }
;;;215    }
        0x0080f0fc:    bd70        p.      POP      {r4-r6,pc}
    periph_handle_conn_state_evt
;;; ..\..\..\src\app\ota\ota_application.c (125)
        0x0080f0fe:    b5f0        ..      PUSH     {r4-r7,lr}
        0x0080f100:    b08b        ..      SUB      sp,sp,#0x2c
        0x0080f102:    4606        .F      MOV      r6,r0
        0x0080f104:    460c        .F      MOV      r4,r1
        0x0080f106:    4615        .F      MOV      r5,r2
;;;126        APP_PRINT_INFO3("periph_handle_conn_state_evt: conn_id = %d old_state = %d new_state = %d",
        0x0080f108:    bf00        ..      NOP      
        0x0080f10a:    bf00        ..      NOP      
        0x0080f10c:    48d0        .H      LDR      r0,[pc,#832] ; [0x80f450] = 0x207e42
        0x0080f10e:    7800        .x      LDRB     r0,[r0,#0]
        0x0080f110:    4633        3F      MOV      r3,r6
        0x0080f112:    2203        ."      MOVS     r2,#3
        0x0080f114:    49cf        .I      LDR      r1,[pc,#828] ; [0x80f454] = 0x88001b0
        0x0080f116:    e9cd0400    ....    STRD     r0,r4,[sp,#0]
        0x0080f11a:    48c5        .H      LDR      r0,[pc,#788] ; [0x80f430] = 0x21103002
        0x0080f11c:    f7f8dc9f    ....    BL       log_buffer ; 0x7a5e
        0x0080f120:    bf00        ..      NOP      
        0x0080f122:    bf00        ..      NOP      
;;;127                        conn_id, gap_conn_state, new_state);
;;;128        switch (new_state)
        0x0080f124:    b114        ..      CBZ      r4,0x80f12c ; periph_handle_conn_state_evt + 46
        0x0080f126:    2c02        .,      CMP      r4,#2
        0x0080f128:    d15f        _.      BNE      0x80f1ea ; periph_handle_conn_state_evt + 236
        0x0080f12a:    e02b        +.      B        0x80f184 ; periph_handle_conn_state_evt + 134
;;;129        {
;;;130        case GAP_CONN_STATE_DISCONNECTED:
;;;131            {
;;;132                if ((disc_cause != (HCI_ERR | HCI_ERR_REMOTE_USER_TERMINATE))
        0x0080f12c:    f2401013    @...    MOV      r0,#0x113
        0x0080f130:    4285        .B      CMP      r5,r0
        0x0080f132:    d00d        ..      BEQ      0x80f150 ; periph_handle_conn_state_evt + 82
;;;133                    && (disc_cause != (HCI_ERR | HCI_ERR_LOCAL_HOST_TERMINATE)))
        0x0080f134:    f5b57f8b    ....    CMP      r5,#0x116
        0x0080f138:    d00a        ..      BEQ      0x80f150 ; periph_handle_conn_state_evt + 82
;;;134                {
;;;135                    APP_PRINT_ERROR1("connection lost: cause 0x%x", disc_cause);
        0x0080f13a:    bf00        ..      NOP      
        0x0080f13c:    bf00        ..      NOP      
        0x0080f13e:    462b        +F      MOV      r3,r5
        0x0080f140:    2201        ."      MOVS     r2,#1
        0x0080f142:    49c5        .I      LDR      r1,[pc,#788] ; [0x80f458] = 0x88001fc
        0x0080f144:    48ba        .H      LDR      r0,[pc,#744] ; [0x80f430] = 0x21103002
        0x0080f146:    1e80        ..      SUBS     r0,r0,#2
        0x0080f148:    f7f8dc89    ....    BL       log_buffer ; 0x7a5e
        0x0080f14c:    bf00        ..      NOP      
        0x0080f14e:    bf00        ..      NOP      
;;;136                }
;;;137                APP_PRINT_INFO1("disc_cause is %d", disc_cause);
        0x0080f150:    bf00        ..      NOP      
        0x0080f152:    bf00        ..      NOP      
        0x0080f154:    462b        +F      MOV      r3,r5
        0x0080f156:    2201        ."      MOVS     r2,#1
        0x0080f158:    49c0        .I      LDR      r1,[pc,#768] ; [0x80f45c] = 0x880021c
        0x0080f15a:    48b5        .H      LDR      r0,[pc,#724] ; [0x80f430] = 0x21103002
        0x0080f15c:    f7f8dc7f    ....    BL       log_buffer ; 0x7a5e
        0x0080f160:    bf00        ..      NOP      
        0x0080f162:    bf00        ..      NOP      
;;;138                if (g_switch_into_ota_pending)
        0x0080f164:    48be        .H      LDR      r0,[pc,#760] ; [0x80f460] = 0x207e40
        0x0080f166:    7800        .x      LDRB     r0,[r0,#0]
        0x0080f168:    b148        H.      CBZ      r0,0x80f17e ; periph_handle_conn_state_evt + 128
;;;139                {
;;;140                    g_switch_into_ota_pending = false;
        0x0080f16a:    2000        .       MOVS     r0,#0
        0x0080f16c:    49bc        .I      LDR      r1,[pc,#752] ; [0x80f460] = 0x207e40
        0x0080f16e:    7008        .p      STRB     r0,[r1,#0]
;;;141                    dfu_switch_to_ota_mode();
        0x0080f170:    f438f4b1    8...    BL       dfu_switch_to_ota_mode ; 0x47ad6
;;;142                    WDG_SystemReset(RESET_ALL_EXCEPT_AON, DFU_SWITCH_TO_OTA);
        0x0080f174:    21d2        .!      MOVS     r1,#0xd2
        0x0080f176:    2001        .       MOVS     r0,#1
        0x0080f178:    f7fffbcc    ....    BL       WDG_SystemReset ; 0x80e914
        0x0080f17c:    e001        ..      B        0x80f182 ; periph_handle_conn_state_evt + 132
;;;143                }
;;;144                else
;;;145                {
;;;146                    le_adv_start();
        0x0080f17e:    f442f7a2    B...    BL       le_adv_start ; 0x520c6
;;;147                }
;;;148            }
;;;149            break;
        0x0080f182:    e033        3.      B        0x80f1ec ; periph_handle_conn_state_evt + 238
;;;150    
;;;151        case GAP_CONN_STATE_CONNECTED:
;;;152            {
;;;153                uint16_t conn_interval;
;;;154                uint16_t conn_latency;
;;;155                uint16_t conn_supervision_timeout;
;;;156                uint8_t  remote_bd[6];
;;;157                T_GAP_REMOTE_ADDR_TYPE remote_bd_type;
;;;158    
;;;159                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
        0x0080f184:    4632        2F      MOV      r2,r6
        0x0080f186:    a90a        ..      ADD      r1,sp,#0x28
        0x0080f188:    f2402072    @.r     MOV      r0,#0x272
        0x0080f18c:    f43ef477    >.w.    BL       le_get_conn_param ; 0x4da7e
;;;160                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_latency, conn_id);
        0x0080f190:    4632        2F      MOV      r2,r6
        0x0080f192:    a909        ..      ADD      r1,sp,#0x24
        0x0080f194:    f2402073    @.s     MOV      r0,#0x273
        0x0080f198:    f43ef471    >.q.    BL       le_get_conn_param ; 0x4da7e
;;;161                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
        0x0080f19c:    4632        2F      MOV      r2,r6
        0x0080f19e:    a908        ..      ADD      r1,sp,#0x20
        0x0080f1a0:    f44f701d    O..p    MOV      r0,#0x274
        0x0080f1a4:    f43ef46b    >.k.    BL       le_get_conn_param ; 0x4da7e
;;;162                le_get_conn_addr(conn_id, remote_bd, &remote_bd_type);
        0x0080f1a8:    aa05        ..      ADD      r2,sp,#0x14
        0x0080f1aa:    a906        ..      ADD      r1,sp,#0x18
        0x0080f1ac:    4630        0F      MOV      r0,r6
        0x0080f1ae:    f43ef51e    >...    BL       le_get_conn_addr ; 0x4dbee
;;;163                APP_PRINT_INFO5("GAP_CONN_STATE_CONNECTED:remote_bd %s, remote_addr_type %d, conn_interval 0x%x, conn_latency 0x%x, conn_supervision_timeout 0x%x",
        0x0080f1b2:    bf00        ..      NOP      
        0x0080f1b4:    bf00        ..      NOP      
        0x0080f1b6:    a906        ..      ADD      r1,sp,#0x18
        0x0080f1b8:    48aa        .H      LDR      r0,[pc,#680] ; [0x80f464] = 0x21300000
        0x0080f1ba:    f7f8de0d    ....    BL       trace_bdaddr ; 0x7dd8
        0x0080f1be:    4607        .F      MOV      r7,r0
        0x0080f1c0:    f8bd0020    .. .    LDRH     r0,[sp,#0x20]
        0x0080f1c4:    f8bd1024    ..$.    LDRH     r1,[sp,#0x24]
        0x0080f1c8:    f8bd2028    ..(     LDRH     r2,[sp,#0x28]
        0x0080f1cc:    f89d3014    ...0    LDRB     r3,[sp,#0x14]
        0x0080f1d0:    e9cd3200    ...2    STRD     r3,r2,[sp,#0]
        0x0080f1d4:    e9cd1002    ....    STRD     r1,r0,[sp,#8]
        0x0080f1d8:    463b        ;F      MOV      r3,r7
        0x0080f1da:    2205        ."      MOVS     r2,#5
        0x0080f1dc:    49a2        .I      LDR      r1,[pc,#648] ; [0x80f468] = 0x8800230
        0x0080f1de:    4894        .H      LDR      r0,[pc,#592] ; [0x80f430] = 0x21103002
        0x0080f1e0:    f7f8dc3d    ..=.    BL       log_buffer ; 0x7a5e
        0x0080f1e4:    bf00        ..      NOP      
        0x0080f1e6:    bf00        ..      NOP      
;;;164                                TRACE_BDADDR(remote_bd), remote_bd_type,
;;;165                                conn_interval, conn_latency, conn_supervision_timeout);
;;;166            }
;;;167            break;
        0x0080f1e8:    e000        ..      B        0x80f1ec ; periph_handle_conn_state_evt + 238
;;;168    
;;;169        default:
;;;170            break;
        0x0080f1ea:    bf00        ..      NOP      
        0x0080f1ec:    bf00        ..      NOP      
;;;171        }
;;;172        gap_conn_state = new_state;
        0x0080f1ee:    4898        .H      LDR      r0,[pc,#608] ; [0x80f450] = 0x207e42
        0x0080f1f0:    7004        .p      STRB     r4,[r0,#0]
;;;173    }
        0x0080f1f2:    b00b        ..      ADD      sp,sp,#0x2c
        0x0080f1f4:    bdf0        ..      POP      {r4-r7,pc}
    periph_handle_dev_state_evt
;;; ..\..\..\src\app\ota\ota_application.c (83)
        0x0080f1f6:    b513        ..      PUSH     {r0,r1,r4,lr}
        0x0080f1f8:    b084        ..      SUB      sp,sp,#0x10
        0x0080f1fa:    460c        .F      MOV      r4,r1
;;;84         APP_PRINT_INFO4("periph_handle_dev_state_evt: init state %d, adv state %d, conn state %d, cause 0x%x",
        0x0080f1fc:    bf00        ..      NOP      
        0x0080f1fe:    bf00        ..      NOP      
        0x0080f200:    f89d0010    ....    LDRB     r0,[sp,#0x10]
        0x0080f204:    0980        ..      LSRS     r0,r0,#6
        0x0080f206:    f89d1010    ....    LDRB     r1,[sp,#0x10]
        0x0080f20a:    f3c10181    ....    UBFX     r1,r1,#2,#2
        0x0080f20e:    e9cd0401    ....    STRD     r0,r4,[sp,#4]
        0x0080f212:    9100        ..      STR      r1,[sp,#0]
        0x0080f214:    f89d0010    ....    LDRB     r0,[sp,#0x10]
        0x0080f218:    f0000301    ....    AND      r3,r0,#1
        0x0080f21c:    2204        ."      MOVS     r2,#4
        0x0080f21e:    4993        .I      LDR      r1,[pc,#588] ; [0x80f46c] = 0x88000e8
        0x0080f220:    4883        .H      LDR      r0,[pc,#524] ; [0x80f430] = 0x21103002
        0x0080f222:    f7f8dc1c    ....    BL       log_buffer ; 0x7a5e
        0x0080f226:    bf00        ..      NOP      
        0x0080f228:    bf00        ..      NOP      
;;;85                         new_state.gap_init_state, new_state.gap_adv_state,
;;;86                         new_state.gap_conn_state, cause);
;;;87         if (gap_cur_state.gap_init_state != new_state.gap_init_state)
        0x0080f22a:    4891        .H      LDR      r0,[pc,#580] ; [0x80f470] = 0x207e41
        0x0080f22c:    7800        .x      LDRB     r0,[r0,#0]
        0x0080f22e:    f0000001    ....    AND      r0,r0,#1
        0x0080f232:    f89d1010    ....    LDRB     r1,[sp,#0x10]
        0x0080f236:    f0010101    ....    AND      r1,r1,#1
        0x0080f23a:    4288        .B      CMP      r0,r1
        0x0080f23c:    d006        ..      BEQ      0x80f24c ; periph_handle_dev_state_evt + 86
;;;88         {
;;;89             if (new_state.gap_init_state == GAP_INIT_STATE_STACK_READY)
        0x0080f23e:    f89d0010    ....    LDRB     r0,[sp,#0x10]
        0x0080f242:    f0000001    ....    AND      r0,r0,#1
        0x0080f246:    b108        ..      CBZ      r0,0x80f24c ; periph_handle_dev_state_evt + 86
;;;90             {
;;;91                 /*stack ready*/
;;;92                 le_adv_start();
        0x0080f248:    f442f73d    B.=.    BL       le_adv_start ; 0x520c6
;;;93             }
;;;94         }
;;;95     
;;;96         if (gap_cur_state.gap_adv_state != new_state.gap_adv_state)
        0x0080f24c:    4888        .H      LDR      r0,[pc,#544] ; [0x80f470] = 0x207e41
        0x0080f24e:    7800        .x      LDRB     r0,[r0,#0]
        0x0080f250:    f3c00081    ....    UBFX     r0,r0,#2,#2
        0x0080f254:    f89d1010    ....    LDRB     r1,[sp,#0x10]
        0x0080f258:    f3c10181    ....    UBFX     r1,r1,#2,#2
        0x0080f25c:    4288        .B      CMP      r0,r1
        0x0080f25e:    d02a        *.      BEQ      0x80f2b6 ; periph_handle_dev_state_evt + 192
;;;97         {
;;;98             if (new_state.gap_adv_state == GAP_ADV_STATE_IDLE)
        0x0080f260:    f89d0010    ....    LDRB     r0,[sp,#0x10]
        0x0080f264:    f3c00081    ....    UBFX     r0,r0,#2,#2
        0x0080f268:    b9b0        ..      CBNZ     r0,0x80f298 ; periph_handle_dev_state_evt + 162
;;;99             {
;;;100                if (new_state.gap_adv_sub_state == GAP_ADV_TO_IDLE_CAUSE_CONN)
        0x0080f26a:    f89d0010    ....    LDRB     r0,[sp,#0x10]
        0x0080f26e:    f3c00040    ..@.    UBFX     r0,r0,#1,#1
        0x0080f272:    b140        @.      CBZ      r0,0x80f286 ; periph_handle_dev_state_evt + 144
;;;101                {
;;;102                    APP_PRINT_INFO0("GAP adv stoped: because connection created");
        0x0080f274:    bf00        ..      NOP      
        0x0080f276:    bf00        ..      NOP      
        0x0080f278:    2200        ."      MOVS     r2,#0
        0x0080f27a:    497e        ~I      LDR      r1,[pc,#504] ; [0x80f474] = 0x8800140
        0x0080f27c:    486c        lH      LDR      r0,[pc,#432] ; [0x80f430] = 0x21103002
        0x0080f27e:    f7f8dbee    ....    BL       log_buffer ; 0x7a5e
        0x0080f282:    bf00        ..      NOP      
        0x0080f284:    e017        ..      B        0x80f2b6 ; periph_handle_dev_state_evt + 192
;;;103                }
;;;104                else
;;;105                {
;;;106                    APP_PRINT_INFO0("GAP adv stoped");
        0x0080f286:    bf00        ..      NOP      
        0x0080f288:    bf00        ..      NOP      
        0x0080f28a:    2200        ."      MOVS     r2,#0
        0x0080f28c:    497a        zI      LDR      r1,[pc,#488] ; [0x80f478] = 0x8800170
        0x0080f28e:    4868        hH      LDR      r0,[pc,#416] ; [0x80f430] = 0x21103002
        0x0080f290:    f7f8dbe5    ....    BL       log_buffer ; 0x7a5e
        0x0080f294:    bf00        ..      NOP      
        0x0080f296:    e00e        ..      B        0x80f2b6 ; periph_handle_dev_state_evt + 192
;;;107                }
;;;108            }
;;;109            else if (new_state.gap_adv_state == GAP_ADV_STATE_ADVERTISING)
        0x0080f298:    f89d0010    ....    LDRB     r0,[sp,#0x10]
        0x0080f29c:    f3c00081    ....    UBFX     r0,r0,#2,#2
        0x0080f2a0:    2802        .(      CMP      r0,#2
        0x0080f2a2:    d108        ..      BNE      0x80f2b6 ; periph_handle_dev_state_evt + 192
;;;110            {
;;;111                APP_PRINT_INFO0("GAP adv start");
        0x0080f2a4:    bf00        ..      NOP      
        0x0080f2a6:    bf00        ..      NOP      
        0x0080f2a8:    2200        ."      MOVS     r2,#0
        0x0080f2aa:    4974        tI      LDR      r1,[pc,#464] ; [0x80f47c] = 0x8800184
        0x0080f2ac:    4860        `H      LDR      r0,[pc,#384] ; [0x80f430] = 0x21103002
        0x0080f2ae:    f7f8dbd6    ....    BL       log_buffer ; 0x7a5e
        0x0080f2b2:    bf00        ..      NOP      
        0x0080f2b4:    bf00        ..      NOP      
;;;112            }
;;;113        }
;;;114    
;;;115        if (gap_cur_state.gap_conn_state != new_state.gap_conn_state)
        0x0080f2b6:    486e        nH      LDR      r0,[pc,#440] ; [0x80f470] = 0x207e41
        0x0080f2b8:    7800        .x      LDRB     r0,[r0,#0]
        0x0080f2ba:    0980        ..      LSRS     r0,r0,#6
        0x0080f2bc:    f89d1010    ....    LDRB     r1,[sp,#0x10]
        0x0080f2c0:    ebb01f91    ....    CMP      r0,r1,LSR #6
        0x0080f2c4:    d00f        ..      BEQ      0x80f2e6 ; periph_handle_dev_state_evt + 240
;;;116        {
;;;117            APP_PRINT_INFO2("conn state: %d -> %d",
        0x0080f2c6:    bf00        ..      NOP      
        0x0080f2c8:    bf00        ..      NOP      
        0x0080f2ca:    f89d0010    ....    LDRB     r0,[sp,#0x10]
        0x0080f2ce:    0980        ..      LSRS     r0,r0,#6
        0x0080f2d0:    9000        ..      STR      r0,[sp,#0]
        0x0080f2d2:    4867        gH      LDR      r0,[pc,#412] ; [0x80f470] = 0x207e41
        0x0080f2d4:    7800        .x      LDRB     r0,[r0,#0]
        0x0080f2d6:    0983        ..      LSRS     r3,r0,#6
        0x0080f2d8:    2202        ."      MOVS     r2,#2
        0x0080f2da:    4969        iI      LDR      r1,[pc,#420] ; [0x80f480] = 0x8800198
        0x0080f2dc:    4854        TH      LDR      r0,[pc,#336] ; [0x80f430] = 0x21103002
        0x0080f2de:    f7f8dbbe    ....    BL       log_buffer ; 0x7a5e
        0x0080f2e2:    bf00        ..      NOP      
        0x0080f2e4:    bf00        ..      NOP      
;;;118                            gap_cur_state.gap_conn_state,
;;;119                            new_state.gap_conn_state);
;;;120        }
;;;121        gap_cur_state = new_state;
        0x0080f2e6:    4862        bH      LDR      r0,[pc,#392] ; [0x80f470] = 0x207e41
        0x0080f2e8:    f89d1010    ....    LDRB     r1,[sp,#0x10]
        0x0080f2ec:    7001        .p      STRB     r1,[r0,#0]
;;;122    }
        0x0080f2ee:    b006        ..      ADD      sp,sp,#0x18
        0x0080f2f0:    bd10        ..      POP      {r4,pc}
    periph_handle_gap_msg
;;;123    
;;;124    void periph_handle_conn_state_evt(uint8_t conn_id, T_GAP_CONN_STATE new_state, uint16_t disc_cause)
;;;125    {
;;;126        APP_PRINT_INFO3("periph_handle_conn_state_evt: conn_id = %d old_state = %d new_state = %d",
;;;127                        conn_id, gap_conn_state, new_state);
;;;128        switch (new_state)
;;;129        {
;;;130        case GAP_CONN_STATE_DISCONNECTED:
;;;131            {
;;;132                if ((disc_cause != (HCI_ERR | HCI_ERR_REMOTE_USER_TERMINATE))
;;;133                    && (disc_cause != (HCI_ERR | HCI_ERR_LOCAL_HOST_TERMINATE)))
;;;134                {
;;;135                    APP_PRINT_ERROR1("connection lost: cause 0x%x", disc_cause);
;;;136                }
;;;137                APP_PRINT_INFO1("disc_cause is %d", disc_cause);
;;;138                if (g_switch_into_ota_pending)
;;;139                {
;;;140                    g_switch_into_ota_pending = false;
;;;141                    dfu_switch_to_ota_mode();
;;;142                    WDG_SystemReset(RESET_ALL_EXCEPT_AON, DFU_SWITCH_TO_OTA);
;;;143                }
;;;144                else
;;;145                {
;;;146                    le_adv_start();
;;;147                }
;;;148            }
;;;149            break;
;;;150    
;;;151        case GAP_CONN_STATE_CONNECTED:
;;;152            {
;;;153                uint16_t conn_interval;
;;;154                uint16_t conn_latency;
;;;155                uint16_t conn_supervision_timeout;
;;;156                uint8_t  remote_bd[6];
;;;157                T_GAP_REMOTE_ADDR_TYPE remote_bd_type;
;;;158    
;;;159                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
;;;160                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_latency, conn_id);
;;;161                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
;;;162                le_get_conn_addr(conn_id, remote_bd, &remote_bd_type);
;;;163                APP_PRINT_INFO5("GAP_CONN_STATE_CONNECTED:remote_bd %s, remote_addr_type %d, conn_interval 0x%x, conn_latency 0x%x, conn_supervision_timeout 0x%x",
;;;164                                TRACE_BDADDR(remote_bd), remote_bd_type,
;;;165                                conn_interval, conn_latency, conn_supervision_timeout);
;;;166            }
;;;167            break;
;;;168    
;;;169        default:
;;;170            break;
;;;171        }
;;;172        gap_conn_state = new_state;
;;;173    }
;;;174    
;;;175    /******************************************************************
;;;176     * @fn          peripheral_HandleBtGapAuthenStateChangeEvt
;;;177     * @brief      All the bonding state change  events are pre-handled in this function.
;;;178     *                Then the event handling function shall be called according to the newState.
;;;179     *
;;;180     * @param    newState  - new bonding state
;;;181     * @return     void
;;;182     */
;;;183    void periph_handle_authen_state_evt(uint8_t conn_id, uint8_t new_state, uint16_t cause)
;;;184    {
;;;185        APP_PRINT_INFO1("periph_handle_authen_state_evt:conn_id %d", conn_id);
;;;186    
;;;187        switch (new_state)
;;;188        {
;;;189        case GAP_AUTHEN_STATE_STARTED:
;;;190            {
;;;191                APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_STARTED");
;;;192            }
;;;193            break;
;;;194    
;;;195        case GAP_AUTHEN_STATE_COMPLETE:
;;;196            {
;;;197                if (cause == GAP_SUCCESS)
;;;198                {
;;;199                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair success");
;;;200    
;;;201                }
;;;202                else
;;;203                {
;;;204                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair failed");
;;;205                }
;;;206            }
;;;207            break;
;;;208    
;;;209        default:
;;;210            {
;;;211                APP_PRINT_ERROR1("app_handle_authen_state_evt: unknown newstate %d", new_state);
;;;212            }
;;;213            break;
;;;214        }
;;;215    }
;;;216    
;;;217    /******************************************************************
;;;218     * @fn          peripheral_HandleBtGapConnParaChangeEvt
;;;219     * @brief      All the connection parameter update change  events are pre-handled in this function.
;;;220     *                Then the event handling function shall be called according to the status.
;;;221     *
;;;222     * @param    status  - connection parameter result, 0 - success, otherwise fail.
;;;223     * @return     void
;;;224     */
;;;225    void periph_conn_param_update_evt(uint8_t conn_id, uint8_t status, uint16_t cause)
;;;226    {
;;;227        switch (status)
;;;228        {
;;;229        case GAP_CONN_PARAM_UPDATE_STATUS_SUCCESS:
;;;230            {
;;;231                uint16_t conn_interval;
;;;232                uint16_t conn_slave_latency;
;;;233                uint16_t conn_supervision_timeout;
;;;234    
;;;235                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
;;;236                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_slave_latency, conn_id);
;;;237                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
;;;238    
;;;239                APP_PRINT_INFO3("GAP_MSG_LE_CONN_PARAM_UPDATE update success, conn_interval = 0x%x, conn_slave_latency = 0x%x, conn_supervision_timeout = 0x%x",
;;;240                                conn_interval, conn_slave_latency, conn_supervision_timeout);
;;;241            }
;;;242            break;
;;;243    
;;;244        case GAP_CONN_PARAM_UPDATE_STATUS_FAIL:
;;;245            {
;;;246                APP_PRINT_ERROR1("GAP_MSG_LE_CONN_PARAM_UPDATE failed: cause 0x%x", cause);
;;;247            }
;;;248            break;
;;;249    
;;;250        case GAP_CONN_PARAM_UPDATE_STATUS_PENDING:
;;;251            {
;;;252                APP_PRINT_INFO0("GAP_MSG_LE_CONN_PARAM_UPDATE request success.");
;;;253            }
;;;254            break;
;;;255    
;;;256        default:
;;;257            break;
;;;258        }
;;;259    }
;;;260    
;;;261    /******************************************************************
;;;262     * @fn          peripheral_HandleBtGapMessage
;;;263     * @brief      All the bt gap msg  events are pre-handled in this function.
;;;264     *                Then the event handling function shall be called according to the subType
;;;265     *                of BEE_IO_MSG.
;;;266     *
;;;267     * @param    pBeeIoMsg  - pointer to bee io msg
;;;268     * @return     void
;;;269     */
;;;270    void periph_handle_gap_msg(T_IO_MSG *p_gap_msg)
;;;271    {
        0x0080f2f2:    b570        p.      PUSH     {r4-r6,lr}
        0x0080f2f4:    b086        ..      SUB      sp,sp,#0x18
        0x0080f2f6:    4605        .F      MOV      r5,r0
;;;272        T_LE_GAP_MSG gap_msg;
;;;273        uint8_t conn_id;
;;;274        memcpy(&gap_msg, &p_gap_msg->u.param, sizeof(p_gap_msg->u.param));
        0x0080f2f8:    6868        hh      LDR      r0,[r5,#4]
        0x0080f2fa:    9005        ..      STR      r0,[sp,#0x14]
;;;275    
;;;276        APP_PRINT_TRACE1("periph_handle_gap_msg subtype = %d", p_gap_msg->subtype);
        0x0080f2fc:    bf00        ..      NOP      
        0x0080f2fe:    bf00        ..      NOP      
        0x0080f300:    886b        k.      LDRH     r3,[r5,#2]
        0x0080f302:    2201        ."      MOVS     r2,#1
        0x0080f304:    495f        _I      LDR      r1,[pc,#380] ; [0x80f484] = 0x88004d0
        0x0080f306:    484a        JH      LDR      r0,[pc,#296] ; [0x80f430] = 0x21103002
        0x0080f308:    1c40        @.      ADDS     r0,r0,#1
        0x0080f30a:    f7f8dba8    ....    BL       log_buffer ; 0x7a5e
        0x0080f30e:    bf00        ..      NOP      
        0x0080f310:    bf00        ..      NOP      
;;;277        switch (p_gap_msg->subtype)
        0x0080f312:    8868        h.      LDRH     r0,[r5,#2]
        0x0080f314:    280b        .(      CMP      r0,#0xb
        0x0080f316:    d27d        }.      BCS      0x80f414 ; periph_handle_gap_msg + 290
        0x0080f318:    e8dff000    ....    TBB      [pc,r0]
    $d
        0x0080f31c:    c20c06cb    ....    DCD    3255568075
        0x0080f320:    582e15cb    ...X    DCD    1479415243
        0x0080f324:    001e416b    kA..    DCD    1982827
    $t
;;;278        {
;;;279        case GAP_MSG_LE_DEV_STATE_CHANGE:
;;;280            {
;;;281                periph_handle_dev_state_evt(gap_msg.msg_data.gap_dev_state_change.new_state,
        0x0080f328:    f8bd1016    ....    LDRH     r1,[sp,#0x16]
        0x0080f32c:    9805        ..      LDR      r0,[sp,#0x14]
        0x0080f32e:    f7ffff62    ..b.    BL       periph_handle_dev_state_evt ; 0x80f1f6
;;;282                                            gap_msg.msg_data.gap_dev_state_change.cause);
;;;283            }
;;;284            break;
        0x0080f332:    e0c9        ..      B        0x80f4c8 ; periph_handle_gap_msg + 470
;;;285    
;;;286        case GAP_MSG_LE_CONN_STATE_CHANGE:
;;;287            {
;;;288                periph_handle_conn_state_evt(gap_msg.msg_data.gap_conn_state_change.conn_id,
        0x0080f334:    f8bd2016    ...     LDRH     r2,[sp,#0x16]
        0x0080f338:    f89d1015    ....    LDRB     r1,[sp,#0x15]
        0x0080f33c:    f89d0014    ....    LDRB     r0,[sp,#0x14]
        0x0080f340:    f7fffedd    ....    BL       periph_handle_conn_state_evt ; 0x80f0fe
;;;289                                             (T_GAP_CONN_STATE)gap_msg.msg_data.gap_conn_state_change.new_state,
;;;290                                             gap_msg.msg_data.gap_conn_state_change.disc_cause);
;;;291            }
;;;292            break;
        0x0080f344:    e0c0        ..      B        0x80f4c8 ; periph_handle_gap_msg + 470
;;;293    
;;;294        case GAP_MSG_LE_AUTHEN_STATE_CHANGE:
;;;295            {
;;;296                periph_handle_authen_state_evt(gap_msg.msg_data.gap_authen_state.conn_id,
        0x0080f346:    f8bd2016    ...     LDRH     r2,[sp,#0x16]
        0x0080f34a:    f89d1015    ....    LDRB     r1,[sp,#0x15]
        0x0080f34e:    f89d0014    ....    LDRB     r0,[sp,#0x14]
        0x0080f352:    f7fffe96    ....    BL       periph_handle_authen_state_evt ; 0x80f082
;;;297                                               gap_msg.msg_data.gap_authen_state.new_state,
;;;298                                               gap_msg.msg_data.gap_authen_state.status);
;;;299            }
;;;300            break;
        0x0080f356:    e0b7        ..      B        0x80f4c8 ; periph_handle_gap_msg + 470
;;;301    
;;;302        case GAP_MSG_LE_BOND_JUST_WORK:
;;;303            {
;;;304                conn_id = gap_msg.msg_data.gap_bond_just_work_conf.conn_id;
        0x0080f358:    f89d4014    ...@    LDRB     r4,[sp,#0x14]
;;;305                le_bond_just_work_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
        0x0080f35c:    2101        .!      MOVS     r1,#1
        0x0080f35e:    4620         F      MOV      r0,r4
        0x0080f360:    f001fbdd    ....    BL       le_bond_just_work_confirm ; 0x810b1e
;;;306                APP_PRINT_INFO0("GAP_MSG_LE_BOND_JUST_WORK");
        0x0080f364:    bf00        ..      NOP      
        0x0080f366:    bf00        ..      NOP      
        0x0080f368:    2200        ."      MOVS     r2,#0
        0x0080f36a:    4947        GI      LDR      r1,[pc,#284] ; [0x80f488] = 0x88004f4
        0x0080f36c:    4830        0H      LDR      r0,[pc,#192] ; [0x80f430] = 0x21103002
        0x0080f36e:    f7f8db76    ..v.    BL       log_buffer ; 0x7a5e
        0x0080f372:    bf00        ..      NOP      
        0x0080f374:    bf00        ..      NOP      
;;;307            }
;;;308            break;
        0x0080f376:    e0a7        ..      B        0x80f4c8 ; periph_handle_gap_msg + 470
;;;309    
;;;310        case GAP_MSG_LE_BOND_PASSKEY_DISPLAY:
;;;311            {
;;;312                uint32_t display_value = 0;
        0x0080f378:    2000        .       MOVS     r0,#0
        0x0080f37a:    9004        ..      STR      r0,[sp,#0x10]
;;;313                conn_id = gap_msg.msg_data.gap_bond_passkey_display.conn_id;
        0x0080f37c:    f89d4014    ...@    LDRB     r4,[sp,#0x14]
;;;314                le_bond_get_display_key(conn_id, &display_value);
        0x0080f380:    a904        ..      ADD      r1,sp,#0x10
        0x0080f382:    4620         F      MOV      r0,r4
        0x0080f384:    f43df031    =.1.    BL       le_bond_get_display_key ; 0x4c3ea
;;;315                APP_PRINT_INFO1("GAP_MSG_LE_BOND_PASSKEY_DISPLAY:passkey %d", display_value);
        0x0080f388:    bf00        ..      NOP      
        0x0080f38a:    bf00        ..      NOP      
        0x0080f38c:    2201        ."      MOVS     r2,#1
        0x0080f38e:    493f        ?I      LDR      r1,[pc,#252] ; [0x80f48c] = 0x8800514
        0x0080f390:    4827        'H      LDR      r0,[pc,#156] ; [0x80f430] = 0x21103002
        0x0080f392:    9b04        ..      LDR      r3,[sp,#0x10]
        0x0080f394:    f7f8db63    ..c.    BL       log_buffer ; 0x7a5e
        0x0080f398:    bf00        ..      NOP      
        0x0080f39a:    bf00        ..      NOP      
;;;316            }
;;;317            break;
        0x0080f39c:    e094        ..      B        0x80f4c8 ; periph_handle_gap_msg + 470
;;;318    
;;;319        case GAP_MSG_LE_BOND_USER_CONFIRMATION:
;;;320            {
;;;321                uint32_t display_value = 0;
        0x0080f39e:    2000        .       MOVS     r0,#0
        0x0080f3a0:    9004        ..      STR      r0,[sp,#0x10]
;;;322                conn_id = gap_msg.msg_data.gap_bond_user_conf.conn_id;
        0x0080f3a2:    f89d4014    ...@    LDRB     r4,[sp,#0x14]
;;;323                le_bond_get_display_key(conn_id, &display_value);
        0x0080f3a6:    a904        ..      ADD      r1,sp,#0x10
        0x0080f3a8:    4620         F      MOV      r0,r4
        0x0080f3aa:    f43df01e    =...    BL       le_bond_get_display_key ; 0x4c3ea
;;;324                APP_PRINT_INFO1("GAP_MSG_LE_BOND_USER_CONFIRMATION: passkey %d", display_value);
        0x0080f3ae:    bf00        ..      NOP      
        0x0080f3b0:    bf00        ..      NOP      
        0x0080f3b2:    2201        ."      MOVS     r2,#1
        0x0080f3b4:    4936        6I      LDR      r1,[pc,#216] ; [0x80f490] = 0x8800544
        0x0080f3b6:    481e        .H      LDR      r0,[pc,#120] ; [0x80f430] = 0x21103002
        0x0080f3b8:    9b04        ..      LDR      r3,[sp,#0x10]
        0x0080f3ba:    f7f8db50    ..P.    BL       log_buffer ; 0x7a5e
        0x0080f3be:    bf00        ..      NOP      
        0x0080f3c0:    bf00        ..      NOP      
;;;325                le_bond_user_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
        0x0080f3c2:    2101        .!      MOVS     r1,#1
        0x0080f3c4:    4620         F      MOV      r0,r4
        0x0080f3c6:    f43df025    =.%.    BL       le_bond_user_confirm ; 0x4c414
;;;326            }
;;;327            break;
        0x0080f3ca:    e07d        }.      B        0x80f4c8 ; periph_handle_gap_msg + 470
;;;328    
;;;329        case GAP_MSG_LE_BOND_PASSKEY_INPUT:
;;;330            {
;;;331                uint32_t passkey = 888888;
        0x0080f3cc:    4e31        1N      LDR      r6,[pc,#196] ; [0x80f494] = 0xd9038
;;;332                conn_id = gap_msg.msg_data.gap_bond_passkey_input.conn_id;
        0x0080f3ce:    f89d4014    ...@    LDRB     r4,[sp,#0x14]
;;;333                APP_PRINT_INFO1("GAP_MSG_LE_BOND_PASSKEY_INPUT: conn_id %d", conn_id);
        0x0080f3d2:    bf00        ..      NOP      
        0x0080f3d4:    bf00        ..      NOP      
        0x0080f3d6:    4623        #F      MOV      r3,r4
        0x0080f3d8:    2201        ."      MOVS     r2,#1
        0x0080f3da:    492f        /I      LDR      r1,[pc,#188] ; [0x80f498] = 0x8800578
        0x0080f3dc:    4814        .H      LDR      r0,[pc,#80] ; [0x80f430] = 0x21103002
        0x0080f3de:    f7f8db3e    ..>.    BL       log_buffer ; 0x7a5e
        0x0080f3e2:    bf00        ..      NOP      
        0x0080f3e4:    bf00        ..      NOP      
;;;334                le_bond_passkey_input_confirm(conn_id, passkey, GAP_CFM_CAUSE_ACCEPT);
        0x0080f3e6:    2201        ."      MOVS     r2,#1
        0x0080f3e8:    4631        1F      MOV      r1,r6
        0x0080f3ea:    4620         F      MOV      r0,r4
        0x0080f3ec:    f43cf7c9    <...    BL       le_bond_passkey_input_confirm ; 0x4c382
;;;335            }
;;;336            break;
        0x0080f3f0:    e06a        j.      B        0x80f4c8 ; periph_handle_gap_msg + 470
;;;337    
;;;338        case GAP_MSG_LE_BOND_OOB_INPUT:
;;;339            {
;;;340                uint8_t oob_data[GAP_OOB_LEN] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
        0x0080f3f2:    2000        .       MOVS     r0,#0
        0x0080f3f4:    9001        ..      STR      r0,[sp,#4]
        0x0080f3f6:    9002        ..      STR      r0,[sp,#8]
        0x0080f3f8:    9003        ..      STR      r0,[sp,#0xc]
        0x0080f3fa:    9004        ..      STR      r0,[sp,#0x10]
;;;341                conn_id = gap_msg.msg_data.gap_bond_oob_input.conn_id;
        0x0080f3fc:    f89d4014    ...@    LDRB     r4,[sp,#0x14]
;;;342                APP_PRINT_INFO0("GAP_MSG_LE_BOND_OOB_INPUT");
        0x0080f400:    bf00        ..      NOP      
        0x0080f402:    bf00        ..      NOP      
        0x0080f404:    2200        ."      MOVS     r2,#0
        0x0080f406:    4925        %I      LDR      r1,[pc,#148] ; [0x80f49c] = 0x88005a8
        0x0080f408:    4809        .H      LDR      r0,[pc,#36] ; [0x80f430] = 0x21103002
        0x0080f40a:    f7f8db28    ..(.    BL       log_buffer ; 0x7a5e
        0x0080f40e:    bf00        ..      NOP      
        0x0080f410:    bf00        ..      NOP      
;;;343                le_bond_set_param(GAP_PARAM_BOND_OOB_DATA, GAP_OOB_LEN, oob_data);
        0x0080f412:    e000        ..      B        0x80f416 ; periph_handle_gap_msg + 292
        0x0080f414:    e04d        M.      B        0x80f4b2 ; periph_handle_gap_msg + 448
        0x0080f416:    aa01        ..      ADD      r2,sp,#4
        0x0080f418:    2110        .!      MOVS     r1,#0x10
        0x0080f41a:    f44f7004    O..p    MOV      r0,#0x210
        0x0080f41e:    f43cf6e6    <...    BL       le_bond_set_param ; 0x4c1ee
;;;344                le_bond_oob_input_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
        0x0080f422:    2101        .!      MOVS     r1,#1
        0x0080f424:    4620         F      MOV      r0,r4
        0x0080f426:    f43cf7c6    <...    BL       le_bond_oob_input_confirm ; 0x4c3b6
;;;345            }
;;;346            break;
        0x0080f42a:    e04d        M.      B        0x80f4c8 ; periph_handle_gap_msg + 470
    $d
        0x0080f42c:    088003e4    ....    DCD    142607332
        0x0080f430:    21103002    .0.!    DCD    554708994
        0x0080f434:    08800468    h...    DCD    142607464
        0x0080f438:    0880049c    ....    DCD    142607516
        0x0080f43c:    088002b4    ....    DCD    142607028
        0x0080f440:    088002e4    ....    DCD    142607076
        0x0080f444:    08800320     ...    DCD    142607136
        0x0080f448:    08800368    h...    DCD    142607208
        0x0080f44c:    088003b0    ....    DCD    142607280
        0x0080f450:    00207e42    B~ .    DCD    2129474
        0x0080f454:    088001b0    ....    DCD    142606768
        0x0080f458:    088001fc    ....    DCD    142606844
        0x0080f45c:    0880021c    ....    DCD    142606876
        0x0080f460:    00207e40    @~ .    DCD    2129472
        0x0080f464:    21300000    ..0!    DCD    556793856
        0x0080f468:    08800230    0...    DCD    142606896
        0x0080f46c:    088000e8    ....    DCD    142606568
        0x0080f470:    00207e41    A~ .    DCD    2129473
        0x0080f474:    08800140    @...    DCD    142606656
        0x0080f478:    08800170    p...    DCD    142606704
        0x0080f47c:    08800184    ....    DCD    142606724
        0x0080f480:    08800198    ....    DCD    142606744
        0x0080f484:    088004d0    ....    DCD    142607568
        0x0080f488:    088004f4    ....    DCD    142607604
        0x0080f48c:    08800514    ....    DCD    142607636
        0x0080f490:    08800544    D...    DCD    142607684
        0x0080f494:    000d9038    8...    DCD    888888
        0x0080f498:    08800578    x...    DCD    142607736
        0x0080f49c:    088005a8    ....    DCD    142607784
    $t
;;;347    
;;;348        case GAP_MSG_LE_CONN_PARAM_UPDATE:
;;;349            {
;;;350                periph_conn_param_update_evt(gap_msg.msg_data.gap_conn_param_update.conn_id,
        0x0080f4a0:    f8bd2016    ...     LDRH     r2,[sp,#0x16]
        0x0080f4a4:    f89d1015    ....    LDRB     r1,[sp,#0x15]
        0x0080f4a8:    f89d0014    ....    LDRB     r0,[sp,#0x14]
        0x0080f4ac:    f7fffda0    ....    BL       periph_conn_param_update_evt ; 0x80eff0
;;;351                                             gap_msg.msg_data.gap_conn_param_update.status,
;;;352                                             gap_msg.msg_data.gap_conn_param_update.cause);
;;;353            }
;;;354            break;
        0x0080f4b0:    e00a        ..      B        0x80f4c8 ; periph_handle_gap_msg + 470
;;;355    
;;;356        default:
;;;357            APP_PRINT_ERROR1("periph_handle_gap_msg: unknown subtype %d", p_gap_msg->subtype);
        0x0080f4b2:    bf00        ..      NOP      
        0x0080f4b4:    bf00        ..      NOP      
        0x0080f4b6:    886b        k.      LDRH     r3,[r5,#2]
        0x0080f4b8:    2201        ."      MOVS     r2,#1
        0x0080f4ba:    49d4        .I      LDR      r1,[pc,#848] ; [0x80f80c] = 0x88005c8
        0x0080f4bc:    48d4        .H      LDR      r0,[pc,#848] ; [0x80f810] = 0x21103000
        0x0080f4be:    f7f8dace    ....    BL       log_buffer ; 0x7a5e
        0x0080f4c2:    bf00        ..      NOP      
        0x0080f4c4:    bf00        ..      NOP      
;;;358            break;
        0x0080f4c6:    bf00        ..      NOP      
        0x0080f4c8:    bf00        ..      NOP      
;;;359        }
;;;360    }
        0x0080f4ca:    b006        ..      ADD      sp,sp,#0x18
        0x0080f4cc:    bd70        p.      POP      {r4-r6,pc}
    app_handle_io_msg
;;; ..\..\..\src\app\ota\ota_application.c (55)
        0x0080f4ce:    b513        ..      PUSH     {r0,r1,r4,lr}
;;;56         uint16_t msg_type = io_driver_msg_recv.type;
        0x0080f4d0:    f8bd4000    ...@    LDRH     r4,[sp,#0]
;;;57     
;;;58         switch (msg_type)
        0x0080f4d4:    b114        ..      CBZ      r4,0x80f4dc ; app_handle_io_msg + 14
        0x0080f4d6:    2c06        .,      CMP      r4,#6
        0x0080f4d8:    d105        ..      BNE      0x80f4e6 ; app_handle_io_msg + 24
        0x0080f4da:    e003        ..      B        0x80f4e4 ; app_handle_io_msg + 22
;;;59         {
;;;60         case IO_MSG_TYPE_BT_STATUS:
;;;61             {
;;;62                 periph_handle_gap_msg(&io_driver_msg_recv);
        0x0080f4dc:    4668        hF      MOV      r0,sp
        0x0080f4de:    f7ffff08    ....    BL       periph_handle_gap_msg ; 0x80f2f2
;;;63             }
;;;64             break;
        0x0080f4e2:    e001        ..      B        0x80f4e8 ; app_handle_io_msg + 26
        0x0080f4e4:    e000        ..      B        0x80f4e8 ; app_handle_io_msg + 26
        0x0080f4e6:    bf00        ..      NOP      
        0x0080f4e8:    bf00        ..      NOP      
;;;65         case IO_MSG_TYPE_GDMA:
;;;66             {
;;;67             }
;;;68             break;
;;;69         default:
;;;70             break;
;;;71         }
;;;72     }
        0x0080f4ea:    bd1c        ..      POP      {r2-r4,pc}
    app_gap_callback
;;;73     
;;;74     /******************************************************************
;;;75      * @fn          peripheral_HandleBtDevStateChangeEvt
;;;76      * @brief      All the gaprole_States_t events are pre-handled in this function.
;;;77      *                Then the event handling function shall be called according to the newState.
;;;78      *
;;;79      * @param    newState  - new gap state
;;;80      * @return     void
;;;81      */
;;;82     void periph_handle_dev_state_evt(T_GAP_DEV_STATE new_state, uint16_t cause)
;;;83     {
;;;84         APP_PRINT_INFO4("periph_handle_dev_state_evt: init state %d, adv state %d, conn state %d, cause 0x%x",
;;;85                         new_state.gap_init_state, new_state.gap_adv_state,
;;;86                         new_state.gap_conn_state, cause);
;;;87         if (gap_cur_state.gap_init_state != new_state.gap_init_state)
;;;88         {
;;;89             if (new_state.gap_init_state == GAP_INIT_STATE_STACK_READY)
;;;90             {
;;;91                 /*stack ready*/
;;;92                 le_adv_start();
;;;93             }
;;;94         }
;;;95     
;;;96         if (gap_cur_state.gap_adv_state != new_state.gap_adv_state)
;;;97         {
;;;98             if (new_state.gap_adv_state == GAP_ADV_STATE_IDLE)
;;;99             {
;;;100                if (new_state.gap_adv_sub_state == GAP_ADV_TO_IDLE_CAUSE_CONN)
;;;101                {
;;;102                    APP_PRINT_INFO0("GAP adv stoped: because connection created");
;;;103                }
;;;104                else
;;;105                {
;;;106                    APP_PRINT_INFO0("GAP adv stoped");
;;;107                }
;;;108            }
;;;109            else if (new_state.gap_adv_state == GAP_ADV_STATE_ADVERTISING)
;;;110            {
;;;111                APP_PRINT_INFO0("GAP adv start");
;;;112            }
;;;113        }
;;;114    
;;;115        if (gap_cur_state.gap_conn_state != new_state.gap_conn_state)
;;;116        {
;;;117            APP_PRINT_INFO2("conn state: %d -> %d",
;;;118                            gap_cur_state.gap_conn_state,
;;;119                            new_state.gap_conn_state);
;;;120        }
;;;121        gap_cur_state = new_state;
;;;122    }
;;;123    
;;;124    void periph_handle_conn_state_evt(uint8_t conn_id, T_GAP_CONN_STATE new_state, uint16_t disc_cause)
;;;125    {
;;;126        APP_PRINT_INFO3("periph_handle_conn_state_evt: conn_id = %d old_state = %d new_state = %d",
;;;127                        conn_id, gap_conn_state, new_state);
;;;128        switch (new_state)
;;;129        {
;;;130        case GAP_CONN_STATE_DISCONNECTED:
;;;131            {
;;;132                if ((disc_cause != (HCI_ERR | HCI_ERR_REMOTE_USER_TERMINATE))
;;;133                    && (disc_cause != (HCI_ERR | HCI_ERR_LOCAL_HOST_TERMINATE)))
;;;134                {
;;;135                    APP_PRINT_ERROR1("connection lost: cause 0x%x", disc_cause);
;;;136                }
;;;137                APP_PRINT_INFO1("disc_cause is %d", disc_cause);
;;;138                if (g_switch_into_ota_pending)
;;;139                {
;;;140                    g_switch_into_ota_pending = false;
;;;141                    dfu_switch_to_ota_mode();
;;;142                    WDG_SystemReset(RESET_ALL_EXCEPT_AON, DFU_SWITCH_TO_OTA);
;;;143                }
;;;144                else
;;;145                {
;;;146                    le_adv_start();
;;;147                }
;;;148            }
;;;149            break;
;;;150    
;;;151        case GAP_CONN_STATE_CONNECTED:
;;;152            {
;;;153                uint16_t conn_interval;
;;;154                uint16_t conn_latency;
;;;155                uint16_t conn_supervision_timeout;
;;;156                uint8_t  remote_bd[6];
;;;157                T_GAP_REMOTE_ADDR_TYPE remote_bd_type;
;;;158    
;;;159                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
;;;160                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_latency, conn_id);
;;;161                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
;;;162                le_get_conn_addr(conn_id, remote_bd, &remote_bd_type);
;;;163                APP_PRINT_INFO5("GAP_CONN_STATE_CONNECTED:remote_bd %s, remote_addr_type %d, conn_interval 0x%x, conn_latency 0x%x, conn_supervision_timeout 0x%x",
;;;164                                TRACE_BDADDR(remote_bd), remote_bd_type,
;;;165                                conn_interval, conn_latency, conn_supervision_timeout);
;;;166            }
;;;167            break;
;;;168    
;;;169        default:
;;;170            break;
;;;171        }
;;;172        gap_conn_state = new_state;
;;;173    }
;;;174    
;;;175    /******************************************************************
;;;176     * @fn          peripheral_HandleBtGapAuthenStateChangeEvt
;;;177     * @brief      All the bonding state change  events are pre-handled in this function.
;;;178     *                Then the event handling function shall be called according to the newState.
;;;179     *
;;;180     * @param    newState  - new bonding state
;;;181     * @return     void
;;;182     */
;;;183    void periph_handle_authen_state_evt(uint8_t conn_id, uint8_t new_state, uint16_t cause)
;;;184    {
;;;185        APP_PRINT_INFO1("periph_handle_authen_state_evt:conn_id %d", conn_id);
;;;186    
;;;187        switch (new_state)
;;;188        {
;;;189        case GAP_AUTHEN_STATE_STARTED:
;;;190            {
;;;191                APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_STARTED");
;;;192            }
;;;193            break;
;;;194    
;;;195        case GAP_AUTHEN_STATE_COMPLETE:
;;;196            {
;;;197                if (cause == GAP_SUCCESS)
;;;198                {
;;;199                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair success");
;;;200    
;;;201                }
;;;202                else
;;;203                {
;;;204                    APP_PRINT_INFO0("app_handle_authen_state_evt: GAP_AUTHEN_STATE_COMPLETE pair failed");
;;;205                }
;;;206            }
;;;207            break;
;;;208    
;;;209        default:
;;;210            {
;;;211                APP_PRINT_ERROR1("app_handle_authen_state_evt: unknown newstate %d", new_state);
;;;212            }
;;;213            break;
;;;214        }
;;;215    }
;;;216    
;;;217    /******************************************************************
;;;218     * @fn          peripheral_HandleBtGapConnParaChangeEvt
;;;219     * @brief      All the connection parameter update change  events are pre-handled in this function.
;;;220     *                Then the event handling function shall be called according to the status.
;;;221     *
;;;222     * @param    status  - connection parameter result, 0 - success, otherwise fail.
;;;223     * @return     void
;;;224     */
;;;225    void periph_conn_param_update_evt(uint8_t conn_id, uint8_t status, uint16_t cause)
;;;226    {
;;;227        switch (status)
;;;228        {
;;;229        case GAP_CONN_PARAM_UPDATE_STATUS_SUCCESS:
;;;230            {
;;;231                uint16_t conn_interval;
;;;232                uint16_t conn_slave_latency;
;;;233                uint16_t conn_supervision_timeout;
;;;234    
;;;235                le_get_conn_param(GAP_PARAM_CONN_INTERVAL, &conn_interval, conn_id);
;;;236                le_get_conn_param(GAP_PARAM_CONN_LATENCY, &conn_slave_latency, conn_id);
;;;237                le_get_conn_param(GAP_PARAM_CONN_TIMEOUT, &conn_supervision_timeout, conn_id);
;;;238    
;;;239                APP_PRINT_INFO3("GAP_MSG_LE_CONN_PARAM_UPDATE update success, conn_interval = 0x%x, conn_slave_latency = 0x%x, conn_supervision_timeout = 0x%x",
;;;240                                conn_interval, conn_slave_latency, conn_supervision_timeout);
;;;241            }
;;;242            break;
;;;243    
;;;244        case GAP_CONN_PARAM_UPDATE_STATUS_FAIL:
;;;245            {
;;;246                APP_PRINT_ERROR1("GAP_MSG_LE_CONN_PARAM_UPDATE failed: cause 0x%x", cause);
;;;247            }
;;;248            break;
;;;249    
;;;250        case GAP_CONN_PARAM_UPDATE_STATUS_PENDING:
;;;251            {
;;;252                APP_PRINT_INFO0("GAP_MSG_LE_CONN_PARAM_UPDATE request success.");
;;;253            }
;;;254            break;
;;;255    
;;;256        default:
;;;257            break;
;;;258        }
;;;259    }
;;;260    
;;;261    /******************************************************************
;;;262     * @fn          peripheral_HandleBtGapMessage
;;;263     * @brief      All the bt gap msg  events are pre-handled in this function.
;;;264     *                Then the event handling function shall be called according to the subType
;;;265     *                of BEE_IO_MSG.
;;;266     *
;;;267     * @param    pBeeIoMsg  - pointer to bee io msg
;;;268     * @return     void
;;;269     */
;;;270    void periph_handle_gap_msg(T_IO_MSG *p_gap_msg)
;;;271    {
;;;272        T_LE_GAP_MSG gap_msg;
;;;273        uint8_t conn_id;
;;;274        memcpy(&gap_msg, &p_gap_msg->u.param, sizeof(p_gap_msg->u.param));
;;;275    
;;;276        APP_PRINT_TRACE1("periph_handle_gap_msg subtype = %d", p_gap_msg->subtype);
;;;277        switch (p_gap_msg->subtype)
;;;278        {
;;;279        case GAP_MSG_LE_DEV_STATE_CHANGE:
;;;280            {
;;;281                periph_handle_dev_state_evt(gap_msg.msg_data.gap_dev_state_change.new_state,
;;;282                                            gap_msg.msg_data.gap_dev_state_change.cause);
;;;283            }
;;;284            break;
;;;285    
;;;286        case GAP_MSG_LE_CONN_STATE_CHANGE:
;;;287            {
;;;288                periph_handle_conn_state_evt(gap_msg.msg_data.gap_conn_state_change.conn_id,
;;;289                                             (T_GAP_CONN_STATE)gap_msg.msg_data.gap_conn_state_change.new_state,
;;;290                                             gap_msg.msg_data.gap_conn_state_change.disc_cause);
;;;291            }
;;;292            break;
;;;293    
;;;294        case GAP_MSG_LE_AUTHEN_STATE_CHANGE:
;;;295            {
;;;296                periph_handle_authen_state_evt(gap_msg.msg_data.gap_authen_state.conn_id,
;;;297                                               gap_msg.msg_data.gap_authen_state.new_state,
;;;298                                               gap_msg.msg_data.gap_authen_state.status);
;;;299            }
;;;300            break;
;;;301    
;;;302        case GAP_MSG_LE_BOND_JUST_WORK:
;;;303            {
;;;304                conn_id = gap_msg.msg_data.gap_bond_just_work_conf.conn_id;
;;;305                le_bond_just_work_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
;;;306                APP_PRINT_INFO0("GAP_MSG_LE_BOND_JUST_WORK");
;;;307            }
;;;308            break;
;;;309    
;;;310        case GAP_MSG_LE_BOND_PASSKEY_DISPLAY:
;;;311            {
;;;312                uint32_t display_value = 0;
;;;313                conn_id = gap_msg.msg_data.gap_bond_passkey_display.conn_id;
;;;314                le_bond_get_display_key(conn_id, &display_value);
;;;315                APP_PRINT_INFO1("GAP_MSG_LE_BOND_PASSKEY_DISPLAY:passkey %d", display_value);
;;;316            }
;;;317            break;
;;;318    
;;;319        case GAP_MSG_LE_BOND_USER_CONFIRMATION:
;;;320            {
;;;321                uint32_t display_value = 0;
;;;322                conn_id = gap_msg.msg_data.gap_bond_user_conf.conn_id;
;;;323                le_bond_get_display_key(conn_id, &display_value);
;;;324                APP_PRINT_INFO1("GAP_MSG_LE_BOND_USER_CONFIRMATION: passkey %d", display_value);
;;;325                le_bond_user_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
;;;326            }
;;;327            break;
;;;328    
;;;329        case GAP_MSG_LE_BOND_PASSKEY_INPUT:
;;;330            {
;;;331                uint32_t passkey = 888888;
;;;332                conn_id = gap_msg.msg_data.gap_bond_passkey_input.conn_id;
;;;333                APP_PRINT_INFO1("GAP_MSG_LE_BOND_PASSKEY_INPUT: conn_id %d", conn_id);
;;;334                le_bond_passkey_input_confirm(conn_id, passkey, GAP_CFM_CAUSE_ACCEPT);
;;;335            }
;;;336            break;
;;;337    
;;;338        case GAP_MSG_LE_BOND_OOB_INPUT:
;;;339            {
;;;340                uint8_t oob_data[GAP_OOB_LEN] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
;;;341                conn_id = gap_msg.msg_data.gap_bond_oob_input.conn_id;
;;;342                APP_PRINT_INFO0("GAP_MSG_LE_BOND_OOB_INPUT");
;;;343                le_bond_set_param(GAP_PARAM_BOND_OOB_DATA, GAP_OOB_LEN, oob_data);
;;;344                le_bond_oob_input_confirm(conn_id, GAP_CFM_CAUSE_ACCEPT);
;;;345            }
;;;346            break;
;;;347    
;;;348        case GAP_MSG_LE_CONN_PARAM_UPDATE:
;;;349            {
;;;350                periph_conn_param_update_evt(gap_msg.msg_data.gap_conn_param_update.conn_id,
;;;351                                             gap_msg.msg_data.gap_conn_param_update.status,
;;;352                                             gap_msg.msg_data.gap_conn_param_update.cause);
;;;353            }
;;;354            break;
;;;355    
;;;356        default:
;;;357            APP_PRINT_ERROR1("periph_handle_gap_msg: unknown subtype %d", p_gap_msg->subtype);
;;;358            break;
;;;359        }
;;;360    }
;;;361    
;;;362    T_APP_RESULT app_gap_callback(uint8_t cb_type, void *p_cb_data)
;;;363    {
        0x0080f4ec:    e92d41fc    -..A    PUSH     {r2-r8,lr}
        0x0080f4f0:    4605        .F      MOV      r5,r0
        0x0080f4f2:    460e        .F      MOV      r6,r1
;;;364        T_APP_RESULT result = APP_RESULT_SUCCESS;
        0x0080f4f4:    2700        .'      MOVS     r7,#0
;;;365        T_LE_CB_DATA *p_data = (T_LE_CB_DATA *)p_cb_data;
        0x0080f4f6:    4634        4F      MOV      r4,r6
;;;366    
;;;367        switch (cb_type)
        0x0080f4f8:    2d01        .-      CMP      r5,#1
        0x0080f4fa:    d024        $.      BEQ      0x80f546 ; app_gap_callback + 90
        0x0080f4fc:    2d14        .-      CMP      r5,#0x14
        0x0080f4fe:    d002        ..      BEQ      0x80f506 ; app_gap_callback + 26
        0x0080f500:    2d20         -      CMP      r5,#0x20
        0x0080f502:    d130        0.      BNE      0x80f566 ; app_gap_callback + 122
        0x0080f504:    e012        ..      B        0x80f52c ; app_gap_callback + 64
;;;368        {
;;;369        case GAP_MSG_LE_DATA_LEN_CHANGE_INFO:
;;;370            APP_PRINT_INFO3("GAP_MSG_LE_DATA_LEN_CHANGE_INFO: conn_id %d, tx octets 0x%x, max_tx_time 0x%x",
        0x0080f506:    bf00        ..      NOP      
        0x0080f508:    bf00        ..      NOP      
        0x0080f50a:    6820         h      LDR      r0,[r4,#0]
        0x0080f50c:    8880        ..      LDRH     r0,[r0,#4]
        0x0080f50e:    6821        !h      LDR      r1,[r4,#0]
        0x0080f510:    8849        I.      LDRH     r1,[r1,#2]
        0x0080f512:    e9cd1000    ....    STRD     r1,r0,[sp,#0]
        0x0080f516:    6820         h      LDR      r0,[r4,#0]
        0x0080f518:    7803        .x      LDRB     r3,[r0,#0]
        0x0080f51a:    2203        ."      MOVS     r2,#3
        0x0080f51c:    49bd        .I      LDR      r1,[pc,#756] ; [0x80f814] = 0x88005f8
        0x0080f51e:    48bc        .H      LDR      r0,[pc,#752] ; [0x80f810] = 0x21103000
        0x0080f520:    1c80        ..      ADDS     r0,r0,#2
        0x0080f522:    f7f8da9c    ....    BL       log_buffer ; 0x7a5e
        0x0080f526:    bf00        ..      NOP      
        0x0080f528:    bf00        ..      NOP      
;;;371                            p_data->p_le_data_len_change_info->conn_id,
;;;372                            p_data->p_le_data_len_change_info->max_tx_octets,
;;;373                            p_data->p_le_data_len_change_info->max_tx_time);
;;;374            break;
        0x0080f52a:    e028        (.      B        0x80f57e ; app_gap_callback + 146
;;;375    
;;;376        case GAP_MSG_LE_BOND_MODIFY_INFO:
;;;377            APP_PRINT_INFO1("GAP_MSG_LE_BOND_MODIFY_INFO: type 0x%x",
        0x0080f52c:    bf00        ..      NOP      
        0x0080f52e:    bf00        ..      NOP      
        0x0080f530:    6820         h      LDR      r0,[r4,#0]
        0x0080f532:    7803        .x      LDRB     r3,[r0,#0]
        0x0080f534:    2201        ."      MOVS     r2,#1
        0x0080f536:    49b8        .I      LDR      r1,[pc,#736] ; [0x80f818] = 0x880064c
        0x0080f538:    48b5        .H      LDR      r0,[pc,#724] ; [0x80f810] = 0x21103000
        0x0080f53a:    1c80        ..      ADDS     r0,r0,#2
        0x0080f53c:    f7f8da8f    ....    BL       log_buffer ; 0x7a5e
        0x0080f540:    bf00        ..      NOP      
        0x0080f542:    bf00        ..      NOP      
;;;378                            p_data->p_le_bond_modify_info->type);
;;;379            break;
        0x0080f544:    e01b        ..      B        0x80f57e ; app_gap_callback + 146
;;;380    
;;;381        case GAP_MSG_LE_MODIFY_WHITE_LIST:
;;;382            APP_PRINT_INFO2("GAP_MSG_LE_MODIFY_WHITE_LIST: operation %d, cause 0x%x",
        0x0080f546:    bf00        ..      NOP      
        0x0080f548:    bf00        ..      NOP      
        0x0080f54a:    6820         h      LDR      r0,[r4,#0]
        0x0080f54c:    8840        @.      LDRH     r0,[r0,#2]
        0x0080f54e:    9000        ..      STR      r0,[sp,#0]
        0x0080f550:    6820         h      LDR      r0,[r4,#0]
        0x0080f552:    7803        .x      LDRB     r3,[r0,#0]
        0x0080f554:    2202        ."      MOVS     r2,#2
        0x0080f556:    49b1        .I      LDR      r1,[pc,#708] ; [0x80f81c] = 0x8800678
        0x0080f558:    48ad        .H      LDR      r0,[pc,#692] ; [0x80f810] = 0x21103000
        0x0080f55a:    1c80        ..      ADDS     r0,r0,#2
        0x0080f55c:    f7f8da7f    ....    BL       log_buffer ; 0x7a5e
        0x0080f560:    bf00        ..      NOP      
        0x0080f562:    bf00        ..      NOP      
;;;383                            p_data->p_le_modify_white_list_rsp->operation,
;;;384                            p_data->p_le_modify_white_list_rsp->cause);
;;;385            break;
        0x0080f564:    e00b        ..      B        0x80f57e ; app_gap_callback + 146
;;;386    
;;;387        default:
;;;388            APP_PRINT_INFO1("app_gap_callback: unhandled cb_type 0x%x", cb_type);
        0x0080f566:    bf00        ..      NOP      
        0x0080f568:    bf00        ..      NOP      
        0x0080f56a:    462b        +F      MOV      r3,r5
        0x0080f56c:    2201        ."      MOVS     r2,#1
        0x0080f56e:    49ac        .I      LDR      r1,[pc,#688] ; [0x80f820] = 0x88006b4
        0x0080f570:    48a7        .H      LDR      r0,[pc,#668] ; [0x80f810] = 0x21103000
        0x0080f572:    1c80        ..      ADDS     r0,r0,#2
        0x0080f574:    f7f8da73    ..s.    BL       log_buffer ; 0x7a5e
        0x0080f578:    bf00        ..      NOP      
        0x0080f57a:    bf00        ..      NOP      
;;;389            break;
        0x0080f57c:    bf00        ..      NOP      
        0x0080f57e:    bf00        ..      NOP      
;;;390        }
;;;391        return result;
        0x0080f580:    4638        8F      MOV      r0,r7
;;;392    }
        0x0080f582:    e8bd81fc    ....    POP      {r2-r8,pc}
    app_profile_callback
;;;393    
;;;394    /******************************************************************
;;;395     * @fn          app_profile_callback
;;;396     * @brief      All the bt profile callbacks are handled in this function.
;;;397     *                Then the event handling function shall be called according to the serviceID
;;;398     *                of BEE_IO_MSG.
;;;399     *
;;;400     * @param    serviceID  -  service id of profile
;;;401     * @param    pData  - pointer to callback data
;;;402     * @return     void
;;;403     */
;;;404    T_APP_RESULT app_profile_callback(T_SERVER_ID service_id, void *p_data)
;;;405    {
        0x0080f586:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x0080f58a:    b086        ..      SUB      sp,sp,#0x18
        0x0080f58c:    4606        .F      MOV      r6,r0
        0x0080f58e:    460d        .F      MOV      r5,r1
;;;406        T_APP_RESULT app_result = APP_RESULT_SUCCESS;
        0x0080f590:    f04f0800    O...    MOV      r8,#0
;;;407        if (service_id == SERVICE_PROFILE_GENERAL_ID)
        0x0080f594:    2eff        ..      CMP      r6,#0xff
        0x0080f596:    d13d        =.      BNE      0x80f614 ; app_profile_callback + 142
;;;408        {
;;;409            T_SERVER_APP_CB_DATA *p_param = (T_SERVER_APP_CB_DATA *)p_data;
        0x0080f598:    462c        ,F      MOV      r4,r5
;;;410            switch (p_param->eventId)
        0x0080f59a:    7820         x      LDRB     r0,[r4,#0]
        0x0080f59c:    b110        ..      CBZ      r0,0x80f5a4 ; app_profile_callback + 30
        0x0080f59e:    2801        .(      CMP      r0,#1
        0x0080f5a0:    d135        5.      BNE      0x80f60e ; app_profile_callback + 136
        0x0080f5a2:    e00b        ..      B        0x80f5bc ; app_profile_callback + 54
;;;411            {
;;;412            case PROFILE_EVT_SRV_REG_COMPLETE:// srv register result event.
;;;413                APP_PRINT_INFO1("PROFILE_EVT_SRV_REG_COMPLETE: result %d",
        0x0080f5a4:    bf00        ..      NOP      
        0x0080f5a6:    bf00        ..      NOP      
        0x0080f5a8:    78a3        .x      LDRB     r3,[r4,#2]
        0x0080f5aa:    2201        ."      MOVS     r2,#1
        0x0080f5ac:    499d        .I      LDR      r1,[pc,#628] ; [0x80f824] = 0x88006e0
        0x0080f5ae:    4898        .H      LDR      r0,[pc,#608] ; [0x80f810] = 0x21103000
        0x0080f5b0:    1c80        ..      ADDS     r0,r0,#2
        0x0080f5b2:    f7f8da54    ..T.    BL       log_buffer ; 0x7a5e
        0x0080f5b6:    bf00        ..      NOP      
        0x0080f5b8:    bf00        ..      NOP      
;;;414                                p_param->event_data.service_reg_result);
;;;415                break;
        0x0080f5ba:    e029        ).      B        0x80f610 ; app_profile_callback + 138
;;;416    
;;;417            case PROFILE_EVT_SEND_DATA_COMPLETE:
;;;418                APP_PRINT_INFO5("PROFILE_EVT_SEND_DATA_COMPLETE: conn_id %d, cause 0x%x, service_id %d, attrib_idx 0x%x, credits = %d",
        0x0080f5bc:    bf00        ..      NOP      
        0x0080f5be:    bf00        ..      NOP      
        0x0080f5c0:    8860        `.      LDRH     r0,[r4,#2]
        0x0080f5c2:    88e1        ..      LDRH     r1,[r4,#6]
        0x0080f5c4:    7962        by      LDRB     r2,[r4,#5]
        0x0080f5c6:    8923        #.      LDRH     r3,[r4,#8]
        0x0080f5c8:    e9cd3200    ...2    STRD     r3,r2,[sp,#0]
        0x0080f5cc:    e9cd1002    ....    STRD     r1,r0,[sp,#8]
        0x0080f5d0:    7923        #y      LDRB     r3,[r4,#4]
        0x0080f5d2:    2205        ."      MOVS     r2,#5
        0x0080f5d4:    4994        .I      LDR      r1,[pc,#592] ; [0x80f828] = 0x880070c
        0x0080f5d6:    488e        .H      LDR      r0,[pc,#568] ; [0x80f810] = 0x21103000
        0x0080f5d8:    1c80        ..      ADDS     r0,r0,#2
        0x0080f5da:    f7f8da40    ..@.    BL       log_buffer ; 0x7a5e
        0x0080f5de:    bf00        ..      NOP      
        0x0080f5e0:    bf00        ..      NOP      
;;;419                                p_param->event_data.send_data_result.conn_id,
;;;420                                p_param->event_data.send_data_result.cause,
;;;421                                p_param->event_data.send_data_result.service_id,
;;;422                                p_param->event_data.send_data_result.attrib_idx,
;;;423                                p_param->event_data.send_data_result.credits);
;;;424                if (p_param->event_data.send_data_result.cause == GAP_SUCCESS)
        0x0080f5e2:    8920         .      LDRH     r0,[r4,#8]
        0x0080f5e4:    b948        H.      CBNZ     r0,0x80f5fa ; app_profile_callback + 116
;;;425                {
;;;426                    APP_PRINT_INFO0("PROFILE_EVT_SEND_DATA_COMPLETE success");
        0x0080f5e6:    bf00        ..      NOP      
        0x0080f5e8:    bf00        ..      NOP      
        0x0080f5ea:    2200        ."      MOVS     r2,#0
        0x0080f5ec:    498f        .I      LDR      r1,[pc,#572] ; [0x80f82c] = 0x8800774
        0x0080f5ee:    4888        .H      LDR      r0,[pc,#544] ; [0x80f810] = 0x21103000
        0x0080f5f0:    1c80        ..      ADDS     r0,r0,#2
        0x0080f5f2:    f7f8da34    ..4.    BL       log_buffer ; 0x7a5e
        0x0080f5f6:    bf00        ..      NOP      
        0x0080f5f8:    e008        ..      B        0x80f60c ; app_profile_callback + 134
;;;427                }
;;;428                else
;;;429                {
;;;430                    APP_PRINT_ERROR0("PROFILE_EVT_SEND_DATA_COMPLETE failed");
        0x0080f5fa:    bf00        ..      NOP      
        0x0080f5fc:    bf00        ..      NOP      
        0x0080f5fe:    2200        ."      MOVS     r2,#0
        0x0080f600:    498b        .I      LDR      r1,[pc,#556] ; [0x80f830] = 0x88007a0
        0x0080f602:    4883        .H      LDR      r0,[pc,#524] ; [0x80f810] = 0x21103000
        0x0080f604:    f7f8da2b    ..+.    BL       log_buffer ; 0x7a5e
        0x0080f608:    bf00        ..      NOP      
        0x0080f60a:    bf00        ..      NOP      
;;;431                }
;;;432                break;
        0x0080f60c:    e000        ..      B        0x80f610 ; app_profile_callback + 138
;;;433    
;;;434            default:
;;;435                break;
        0x0080f60e:    bf00        ..      NOP      
        0x0080f610:    bf00        ..      NOP      
;;;436            }
;;;437        }
        0x0080f612:    e0f7        ..      B        0x80f804 ; app_profile_callback + 638
;;;438        else if (service_id == g_bas_service_id)
        0x0080f614:    4887        .H      LDR      r0,[pc,#540] ; [0x80f834] = 0x207e3d
        0x0080f616:    7800        .x      LDRB     r0,[r0,#0]
        0x0080f618:    4286        .B      CMP      r6,r0
        0x0080f61a:    d13f        ?.      BNE      0x80f69c ; app_profile_callback + 278
;;;439        {
;;;440            T_BAS_CALLBACK_DATA *pBasCallbackData = (T_BAS_CALLBACK_DATA *)p_data;
        0x0080f61c:    462c        ,F      MOV      r4,r5
;;;441            switch (pBasCallbackData->msg_type)
        0x0080f61e:    7860        `x      LDRB     r0,[r4,#1]
        0x0080f620:    2801        .(      CMP      r0,#1
        0x0080f622:    d002        ..      BEQ      0x80f62a ; app_profile_callback + 164
        0x0080f624:    2802        .(      CMP      r0,#2
        0x0080f626:    d136        6.      BNE      0x80f696 ; app_profile_callback + 272
        0x0080f628:    e01a        ..      B        0x80f660 ; app_profile_callback + 218
;;;442            {
;;;443            case SERVICE_CALLBACK_TYPE_INDIFICATION_NOTIFICATION:
;;;444                {
;;;445                    if (pBasCallbackData->msg_data.notification_indification_index == BAS_NOTIFY_BATTERY_LEVEL_ENABLE)
        0x0080f62a:    78a0        .x      LDRB     r0,[r4,#2]
        0x0080f62c:    2801        .(      CMP      r0,#1
        0x0080f62e:    d109        ..      BNE      0x80f644 ; app_profile_callback + 190
;;;446                    {
;;;447                        APP_PRINT_INFO0("Battery level notification enable");
        0x0080f630:    bf00        ..      NOP      
        0x0080f632:    bf00        ..      NOP      
        0x0080f634:    2200        ."      MOVS     r2,#0
        0x0080f636:    4980        .I      LDR      r1,[pc,#512] ; [0x80f838] = 0x88007cc
        0x0080f638:    4875        uH      LDR      r0,[pc,#468] ; [0x80f810] = 0x21103000
        0x0080f63a:    1c80        ..      ADDS     r0,r0,#2
        0x0080f63c:    f7f8da0f    ....    BL       log_buffer ; 0x7a5e
        0x0080f640:    bf00        ..      NOP      
        0x0080f642:    e00c        ..      B        0x80f65e ; app_profile_callback + 216
;;;448                    }
;;;449                    else if (pBasCallbackData->msg_data.notification_indification_index ==
        0x0080f644:    78a0        .x      LDRB     r0,[r4,#2]
        0x0080f646:    2802        .(      CMP      r0,#2
        0x0080f648:    d109        ..      BNE      0x80f65e ; app_profile_callback + 216
;;;450                             BAS_NOTIFY_BATTERY_LEVEL_DISABLE)
;;;451                    {
;;;452                        APP_PRINT_INFO0("Battery level notification disable");
        0x0080f64a:    bf00        ..      NOP      
        0x0080f64c:    bf00        ..      NOP      
        0x0080f64e:    2200        ."      MOVS     r2,#0
        0x0080f650:    497a        zI      LDR      r1,[pc,#488] ; [0x80f83c] = 0x88007f4
        0x0080f652:    486f        oH      LDR      r0,[pc,#444] ; [0x80f810] = 0x21103000
        0x0080f654:    1c80        ..      ADDS     r0,r0,#2
        0x0080f656:    f7f8da02    ....    BL       log_buffer ; 0x7a5e
        0x0080f65a:    bf00        ..      NOP      
        0x0080f65c:    bf00        ..      NOP      
;;;453                    }
;;;454                }
;;;455                break;
        0x0080f65e:    e01b        ..      B        0x80f698 ; app_profile_callback + 274
;;;456            case SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE:
;;;457                {
;;;458                    /* update RCU battery level */
;;;459                    g_bat_vol = 150;
        0x0080f660:    2096        .       MOVS     r0,#0x96
        0x0080f662:    4977        wI      LDR      r1,[pc,#476] ; [0x80f840] = 0x207e44
        0x0080f664:    8008        ..      STRH     r0,[r1,#0]
;;;460                    g_bas_battery_level = 100;
        0x0080f666:    2064        d       MOVS     r0,#0x64
        0x0080f668:    4976        vI      LDR      r1,[pc,#472] ; [0x80f844] = 0x207e46
        0x0080f66a:    8008        ..      STRH     r0,[r1,#0]
;;;461    
;;;462                    APP_PRINT_INFO2("RCU_Battery_Level_Update BatVol is %d , BASBatteryLevel is %d\n", g_bat_vol,
        0x0080f66c:    bf00        ..      NOP      
        0x0080f66e:    bf00        ..      NOP      
        0x0080f670:    4608        .F      MOV      r0,r1
        0x0080f672:    8800        ..      LDRH     r0,[r0,#0]
        0x0080f674:    9000        ..      STR      r0,[sp,#0]
        0x0080f676:    4872        rH      LDR      r0,[pc,#456] ; [0x80f840] = 0x207e44
        0x0080f678:    8803        ..      LDRH     r3,[r0,#0]
        0x0080f67a:    2202        ."      MOVS     r2,#2
        0x0080f67c:    4972        rI      LDR      r1,[pc,#456] ; [0x80f848] = 0x880081c
        0x0080f67e:    4864        dH      LDR      r0,[pc,#400] ; [0x80f810] = 0x21103000
        0x0080f680:    1c80        ..      ADDS     r0,r0,#2
        0x0080f682:    f7f8d9ec    ....    BL       log_buffer ; 0x7a5e
        0x0080f686:    bf00        ..      NOP      
        0x0080f688:    bf00        ..      NOP      
;;;463                                    g_bas_battery_level);
;;;464    
;;;465                    bas_set_parameter(BAS_PARAM_BATTERY_LEVEL, 1, (uint8_t *)&g_bas_battery_level);
        0x0080f68a:    4a6e        nJ      LDR      r2,[pc,#440] ; [0x80f844] = 0x207e46
        0x0080f68c:    2101        .!      MOVS     r1,#1
        0x0080f68e:    4608        .F      MOV      r0,r1
        0x0080f690:    f000f96c    ..l.    BL       bas_set_parameter ; 0x80f96c
;;;466                }
;;;467                break;
        0x0080f694:    e000        ..      B        0x80f698 ; app_profile_callback + 274
;;;468            default:
;;;469                break;
        0x0080f696:    bf00        ..      NOP      
        0x0080f698:    bf00        ..      NOP      
;;;470            }
;;;471        }
        0x0080f69a:    e0b3        ..      B        0x80f804 ; app_profile_callback + 638
;;;472        else if (service_id == g_dis_service_id)
        0x0080f69c:    486b        kH      LDR      r0,[pc,#428] ; [0x80f84c] = 0x207e3e
        0x0080f69e:    7800        .x      LDRB     r0,[r0,#0]
        0x0080f6a0:    4286        .B      CMP      r6,r0
        0x0080f6a2:    d172        r.      BNE      0x80f78a ; app_profile_callback + 516
;;;473        {
;;;474            T_DIS_CALLBACK_DATA *pDisCallbackData = (T_DIS_CALLBACK_DATA *)p_data;
        0x0080f6a4:    462c        ,F      MOV      r4,r5
;;;475            switch (pDisCallbackData->msg_type)
        0x0080f6a6:    7820         x      LDRB     r0,[r4,#0]
        0x0080f6a8:    2802        .(      CMP      r0,#2
        0x0080f6aa:    d16f        o.      BNE      0x80f78c ; app_profile_callback + 518
;;;476            {
;;;477            case SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE:
;;;478                {
;;;479                    if (pDisCallbackData->msg_data.read_value_index == DIS_READ_MANU_NAME_INDEX)
        0x0080f6ac:    78a0        .x      LDRB     r0,[r4,#2]
        0x0080f6ae:    2801        .(      CMP      r0,#1
        0x0080f6b0:    d109        ..      BNE      0x80f6c6 ; app_profile_callback + 320
;;;480                    {
;;;481                        const uint8_t DISManufacturerName[] = "Realtek BT";
        0x0080f6b2:    a267        g.      ADR      r2,{pc}+0x19e ; 0x80f850
        0x0080f6b4:    ca07        ..      LDM      r2,{r0-r2}
        0x0080f6b6:    ab03        ..      ADD      r3,sp,#0xc
        0x0080f6b8:    c307        ..      STM      r3!,{r0-r2}
;;;482                        dis_set_parameter(DIS_PARAM_MANUFACTURER_NAME,
        0x0080f6ba:    aa03        ..      ADD      r2,sp,#0xc
        0x0080f6bc:    210b        .!      MOVS     r1,#0xb
        0x0080f6be:    2000        .       MOVS     r0,#0
        0x0080f6c0:    f000fa50    ..P.    BL       dis_set_parameter ; 0x80fb64
;;;483                                          sizeof(DISManufacturerName),
;;;484                                          (void *)DISManufacturerName);
;;;485                    }
        0x0080f6c4:    e076        v.      B        0x80f7b4 ; app_profile_callback + 558
;;;486                    else if (pDisCallbackData->msg_data.read_value_index == DIS_READ_MODEL_NUM_INDEX)
        0x0080f6c6:    78a0        .x      LDRB     r0,[r4,#2]
        0x0080f6c8:    2802        .(      CMP      r0,#2
        0x0080f6ca:    d10c        ..      BNE      0x80f6e6 ; app_profile_callback + 352
;;;487                    {
;;;488                        const uint8_t DISModelNumber[] = "Model Nbr 0.9";
        0x0080f6cc:    a263        c.      ADR      r2,{pc}+0x190 ; 0x80f85c
        0x0080f6ce:    e892000b    ....    LDM      r2,{r0,r1,r3}
        0x0080f6d2:    68d2        .h      LDR      r2,[r2,#0xc]
        0x0080f6d4:    af02        ..      ADD      r7,sp,#8
        0x0080f6d6:    c70b        ..      STM      r7!,{r0,r1,r3}
        0x0080f6d8:    9205        ..      STR      r2,[sp,#0x14]
;;;489                        dis_set_parameter(DIS_PARAM_MODEL_NUMBER,
        0x0080f6da:    aa02        ..      ADD      r2,sp,#8
        0x0080f6dc:    210e        .!      MOVS     r1,#0xe
        0x0080f6de:    2001        .       MOVS     r0,#1
        0x0080f6e0:    f000fa40    ..@.    BL       dis_set_parameter ; 0x80fb64
;;;490                                          sizeof(DISModelNumber),
;;;491                                          (void *)DISModelNumber);
;;;492                    }
        0x0080f6e4:    e066        f.      B        0x80f7b4 ; app_profile_callback + 558
;;;493                    else if (pDisCallbackData->msg_data.read_value_index == DIS_READ_SERIAL_NUM_INDEX)
        0x0080f6e6:    78a0        .x      LDRB     r0,[r4,#2]
        0x0080f6e8:    2803        .(      CMP      r0,#3
        0x0080f6ea:    d109        ..      BNE      0x80f700 ; app_profile_callback + 378
;;;494                    {
;;;495                        const uint8_t DISSerialNumber[] = "RTKBeeSerialNum";
        0x0080f6ec:    a35f        _.      ADR      r3,{pc}+0x180 ; 0x80f86c
        0x0080f6ee:    cb0f        ..      LDM      r3,{r0-r3}
        0x0080f6f0:    af02        ..      ADD      r7,sp,#8
        0x0080f6f2:    c70f        ..      STM      r7!,{r0-r3}
;;;496                        dis_set_parameter(DIS_PARAM_SERIAL_NUMBER,
        0x0080f6f4:    aa02        ..      ADD      r2,sp,#8
        0x0080f6f6:    2110        .!      MOVS     r1,#0x10
        0x0080f6f8:    2002        .       MOVS     r0,#2
        0x0080f6fa:    f000fa33    ..3.    BL       dis_set_parameter ; 0x80fb64
;;;497                                          sizeof(DISSerialNumber),
;;;498                                          (void *)DISSerialNumber);
;;;499                    }
        0x0080f6fe:    e059        Y.      B        0x80f7b4 ; app_profile_callback + 558
;;;500                    else if (pDisCallbackData->msg_data.read_value_index == DIS_READ_HARDWARE_REV_INDEX)
        0x0080f700:    78a0        .x      LDRB     r0,[r4,#2]
        0x0080f702:    2804        .(      CMP      r0,#4
        0x0080f704:    d10a        ..      BNE      0x80f71c ; app_profile_callback + 406
;;;501                    {
;;;502                        const uint8_t DISHardwareRev[] = "RTKBeeHardwareRev";
        0x0080f706:    2214        ."      MOVS     r2,#0x14
        0x0080f708:    a15c        \.      ADR      r1,{pc}+0x174 ; 0x80f87c
        0x0080f70a:    a801        ..      ADD      r0,sp,#4
        0x0080f70c:    f44af44c    J.L.    BL       __aeabi_memcpy4 ; 0x59fa8
;;;503                        dis_set_parameter(DIS_PARAM_HARDWARE_REVISION,
        0x0080f710:    aa01        ..      ADD      r2,sp,#4
        0x0080f712:    2112        .!      MOVS     r1,#0x12
        0x0080f714:    2003        .       MOVS     r0,#3
        0x0080f716:    f000fa25    ..%.    BL       dis_set_parameter ; 0x80fb64
;;;504                                          sizeof(DISHardwareRev),
;;;505                                          (void *)DISHardwareRev);
;;;506                    }
        0x0080f71a:    e04b        K.      B        0x80f7b4 ; app_profile_callback + 558
;;;507                    else if (pDisCallbackData->msg_data.read_value_index == DIS_READ_FIRMWARE_REV_INDEX)
        0x0080f71c:    78a0        .x      LDRB     r0,[r4,#2]
        0x0080f71e:    2805        .(      CMP      r0,#5
        0x0080f720:    d10a        ..      BNE      0x80f738 ; app_profile_callback + 434
;;;508                    {
;;;509                        const uint8_t DISFirmwareRev[] = "RTKBeeFirmwareRev";
        0x0080f722:    2214        ."      MOVS     r2,#0x14
        0x0080f724:    a15a        Z.      ADR      r1,{pc}+0x16c ; 0x80f890
        0x0080f726:    a801        ..      ADD      r0,sp,#4
        0x0080f728:    f44af43e    J.>.    BL       __aeabi_memcpy4 ; 0x59fa8
;;;510                        dis_set_parameter(DIS_PARAM_FIRMWARE_REVISION,
        0x0080f72c:    aa01        ..      ADD      r2,sp,#4
        0x0080f72e:    2112        .!      MOVS     r1,#0x12
        0x0080f730:    2004        .       MOVS     r0,#4
        0x0080f732:    f000fa17    ....    BL       dis_set_parameter ; 0x80fb64
;;;511                                          sizeof(DISFirmwareRev),
;;;512                                          (void *)DISFirmwareRev);
;;;513                    }
        0x0080f736:    e03d        =.      B        0x80f7b4 ; app_profile_callback + 558
;;;514                    else if (pDisCallbackData->msg_data.read_value_index == DIS_READ_SOFTWARE_REV_INDEX)
        0x0080f738:    78a0        .x      LDRB     r0,[r4,#2]
        0x0080f73a:    2806        .(      CMP      r0,#6
        0x0080f73c:    d10a        ..      BNE      0x80f754 ; app_profile_callback + 462
;;;515                    {
;;;516                        const uint8_t DISSoftwareRev[] = "RTKBeeSoftwareRev";
        0x0080f73e:    2214        ."      MOVS     r2,#0x14
        0x0080f740:    a158        X.      ADR      r1,{pc}+0x164 ; 0x80f8a4
        0x0080f742:    a801        ..      ADD      r0,sp,#4
        0x0080f744:    f44af430    J.0.    BL       __aeabi_memcpy4 ; 0x59fa8
;;;517                        dis_set_parameter(DIS_PARAM_SOFTWARE_REVISION,
        0x0080f748:    aa01        ..      ADD      r2,sp,#4
        0x0080f74a:    2112        .!      MOVS     r1,#0x12
        0x0080f74c:    2005        .       MOVS     r0,#5
        0x0080f74e:    f000fa09    ....    BL       dis_set_parameter ; 0x80fb64
;;;518                                          sizeof(DISSoftwareRev),
;;;519                                          (void *)DISSoftwareRev);
;;;520                    }
        0x0080f752:    e02f        /.      B        0x80f7b4 ; app_profile_callback + 558
;;;521                    else if (pDisCallbackData->msg_data.read_value_index == DIS_READ_SYSTEM_ID_INDEX)
        0x0080f754:    78a0        .x      LDRB     r0,[r4,#2]
        0x0080f756:    2807        .(      CMP      r0,#7
        0x0080f758:    d109        ..      BNE      0x80f76e ; app_profile_callback + 488
;;;522                    {
;;;523                        const uint8_t DISSystemID[DIS_SYSTEM_ID_LENGTH] = {0, 1, 2, 0, 0, 3, 4, 5};
        0x0080f75a:    a157        W.      ADR      r1,{pc}+0x15e ; 0x80f8b8
        0x0080f75c:    c903        ..      LDM      r1,{r0,r1}
        0x0080f75e:    e9cd0104    ....    STRD     r0,r1,[sp,#0x10]
;;;524                        dis_set_parameter(DIS_PARAM_SYSTEM_ID,
        0x0080f762:    aa04        ..      ADD      r2,sp,#0x10
        0x0080f764:    2108        .!      MOVS     r1,#8
        0x0080f766:    2006        .       MOVS     r0,#6
        0x0080f768:    f000f9fc    ....    BL       dis_set_parameter ; 0x80fb64
;;;525                                          sizeof(DISSystemID),
;;;526                                          (void *)DISSystemID);
;;;527                    }
        0x0080f76c:    e022        ".      B        0x80f7b4 ; app_profile_callback + 558
;;;528                    else if (pDisCallbackData->msg_data.read_value_index == DIS_READ_IEEE_CERT_STR_INDEX)
        0x0080f76e:    78a0        .x      LDRB     r0,[r4,#2]
        0x0080f770:    2808        .(      CMP      r0,#8
        0x0080f772:    d10c        ..      BNE      0x80f78e ; app_profile_callback + 520
;;;529                    {
;;;530                        const uint8_t DISIEEEDataList[] = "RTKBeeIEEEDatalist";
        0x0080f774:    2214        ."      MOVS     r2,#0x14
        0x0080f776:    a152        R.      ADR      r1,{pc}+0x14a ; 0x80f8c0
        0x0080f778:    a801        ..      ADD      r0,sp,#4
        0x0080f77a:    f44af415    J...    BL       __aeabi_memcpy4 ; 0x59fa8
;;;531                        dis_set_parameter(DIS_PARAM_IEEE_DATA_LIST,
        0x0080f77e:    aa01        ..      ADD      r2,sp,#4
        0x0080f780:    2113        .!      MOVS     r1,#0x13
        0x0080f782:    2007        .       MOVS     r0,#7
        0x0080f784:    f000f9ee    ....    BL       dis_set_parameter ; 0x80fb64
;;;532                                          sizeof(DISIEEEDataList),
;;;533                                          (void *)DISIEEEDataList);
;;;534                    }
        0x0080f788:    e014        ..      B        0x80f7b4 ; app_profile_callback + 558
        0x0080f78a:    e017        ..      B        0x80f7bc ; app_profile_callback + 566
        0x0080f78c:    e013        ..      B        0x80f7b6 ; app_profile_callback + 560
;;;535                    else if (pDisCallbackData->msg_data.read_value_index == DIS_READ_PNP_ID_INDEX)
        0x0080f78e:    78a0        .x      LDRB     r0,[r4,#2]
        0x0080f790:    2809        .(      CMP      r0,#9
        0x0080f792:    d10f        ..      BNE      0x80f7b4 ; app_profile_callback + 558
;;;536                    {
;;;537                        //uint8_t DISPnpID[DIS_PNP_ID_LENGTH] = {0x01,0xDA,0x0B,0x62,0x87,0x01,0x00};
;;;538                        uint16_t version = 0x03; //VERSION_BUILD;
        0x0080f794:    2703        .'      MOVS     r7,#3
;;;539    
;;;540                        uint8_t DISPnpID[DIS_PNP_ID_LENGTH] = {0x01, 0x5D, 0x00, 0x01, 0x00, (uint8_t)version, (uint8_t)(version >> 8)}; //VID_005D&PID_0001?
        0x0080f796:    a14f        O.      ADR      r1,{pc}+0x13e ; 0x80f8d4
        0x0080f798:    c903        ..      LDM      r1,{r0,r1}
        0x0080f79a:    e9cd0104    ....    STRD     r0,r1,[sp,#0x10]
        0x0080f79e:    f88d7015    ...p    STRB     r7,[sp,#0x15]
        0x0080f7a2:    1238        8.      ASRS     r0,r7,#8
        0x0080f7a4:    f88d0016    ....    STRB     r0,[sp,#0x16]
;;;541    
;;;542                        dis_set_parameter(DIS_PARAM_PNP_ID,
        0x0080f7a8:    aa04        ..      ADD      r2,sp,#0x10
        0x0080f7aa:    2107        .!      MOVS     r1,#7
        0x0080f7ac:    2008        .       MOVS     r0,#8
        0x0080f7ae:    f000f9d9    ....    BL       dis_set_parameter ; 0x80fb64
;;;543                                          sizeof(DISPnpID),
;;;544                                          DISPnpID);
;;;545                    }
        0x0080f7b2:    bf00        ..      NOP      
;;;546                }
;;;547                break;
        0x0080f7b4:    e000        ..      B        0x80f7b8 ; app_profile_callback + 562
        0x0080f7b6:    bf00        ..      NOP      
        0x0080f7b8:    bf00        ..      NOP      
;;;548            default:
;;;549                break;
;;;550            }
;;;551        }
        0x0080f7ba:    e023        #.      B        0x80f804 ; app_profile_callback + 638
;;;552        else if (service_id == g_ota_service_id)
        0x0080f7bc:    4847        GH      LDR      r0,[pc,#284] ; [0x80f8dc] = 0x207e3f
        0x0080f7be:    7800        .x      LDRB     r0,[r0,#0]
        0x0080f7c0:    4286        .B      CMP      r6,r0
        0x0080f7c2:    d11f        ..      BNE      0x80f804 ; app_profile_callback + 638
;;;553        {
;;;554    
;;;555            T_OTA_CALLBACK_DATA *pOTACallbackData = (T_OTA_CALLBACK_DATA *)p_data;
        0x0080f7c4:    462c        ,F      MOV      r4,r5
;;;556            switch (pOTACallbackData->msg_type)
        0x0080f7c6:    7820         x      LDRB     r0,[r4,#0]
        0x0080f7c8:    2803        .(      CMP      r0,#3
        0x0080f7ca:    d118        ..      BNE      0x80f7fe ; app_profile_callback + 632
;;;557            {
;;;558            case SERVICE_CALLBACK_TYPE_WRITE_CHAR_VALUE:
;;;559    
;;;560                if (OTA_WRITE_CHAR_VAL == pOTACallbackData->msg_data.write.opcode &&
        0x0080f7cc:    78a0        .x      LDRB     r0,[r4,#2]
        0x0080f7ce:    2801        .(      CMP      r0,#1
        0x0080f7d0:    d113        ..      BNE      0x80f7fa ; app_profile_callback + 628
;;;561                    OTA_VALUE_ENTER == pOTACallbackData->msg_data.write.u.value)
        0x0080f7d2:    7920         y      LDRB     r0,[r4,#4]
        0x0080f7d4:    2801        .(      CMP      r0,#1
        0x0080f7d6:    d110        ..      BNE      0x80f7fa ; app_profile_callback + 628
;;;562                {
;;;563    
;;;564                    /*battery level is above 60 percent*/
;;;565                    APP_PRINT_INFO0("Preparing switch into OTA mode\n");
        0x0080f7d8:    bf00        ..      NOP      
        0x0080f7da:    bf00        ..      NOP      
        0x0080f7dc:    2200        ."      MOVS     r2,#0
        0x0080f7de:    4940        @I      LDR      r1,[pc,#256] ; [0x80f8e0] = 0x8800860
        0x0080f7e0:    480b        .H      LDR      r0,[pc,#44] ; [0x80f810] = 0x21103000
        0x0080f7e2:    1c80        ..      ADDS     r0,r0,#2
        0x0080f7e4:    f7f8d93b    ..;.    BL       log_buffer ; 0x7a5e
        0x0080f7e8:    bf00        ..      NOP      
        0x0080f7ea:    bf00        ..      NOP      
;;;566                    /*prepare to enter OTA mode, before switch action, we should disconnect first.*/
;;;567                    g_switch_into_ota_pending = true;
        0x0080f7ec:    2001        .       MOVS     r0,#1
        0x0080f7ee:    493d        =I      LDR      r1,[pc,#244] ; [0x80f8e4] = 0x207e40
        0x0080f7f0:    7008        .p      STRB     r0,[r1,#0]
;;;568                    le_disconnect(0);
        0x0080f7f2:    2000        .       MOVS     r0,#0
        0x0080f7f4:    f43ef216    >...    BL       le_disconnect ; 0x4dc24
        0x0080f7f8:    e000        ..      B        0x80f7fc ; app_profile_callback + 630
;;;569                }
;;;570                else if (OTA_WRITE_IMAGE_COUNT_VAL == pOTACallbackData->msg_data.write.opcode)
        0x0080f7fa:    bf00        ..      NOP      
;;;571                {
;;;572    
;;;573                }
;;;574    
;;;575                break;
        0x0080f7fc:    e000        ..      B        0x80f800 ; app_profile_callback + 634
        0x0080f7fe:    bf00        ..      NOP      
        0x0080f800:    bf00        ..      NOP      
;;;576    
;;;577            default:
;;;578    
;;;579                break;
;;;580            }
;;;581        }
        0x0080f802:    bf00        ..      NOP      
;;;582        return app_result;
        0x0080f804:    4640        @F      MOV      r0,r8
;;;583    }
        0x0080f806:    b006        ..      ADD      sp,sp,#0x18
        0x0080f808:    e8bd81f0    ....    POP      {r4-r8,pc}
    $d
        0x0080f80c:    088005c8    ....    DCD    142607816
        0x0080f810:    21103000    .0.!    DCD    554708992
        0x0080f814:    088005f8    ....    DCD    142607864
        0x0080f818:    0880064c    L...    DCD    142607948
        0x0080f81c:    08800678    x...    DCD    142607992
        0x0080f820:    088006b4    ....    DCD    142608052
        0x0080f824:    088006e0    ....    DCD    142608096
        0x0080f828:    0880070c    ....    DCD    142608140
        0x0080f82c:    08800774    t...    DCD    142608244
        0x0080f830:    088007a0    ....    DCD    142608288
        0x0080f834:    00207e3d    =~ .    DCD    2129469
        0x0080f838:    088007cc    ....    DCD    142608332
        0x0080f83c:    088007f4    ....    DCD    142608372
        0x0080f840:    00207e44    D~ .    DCD    2129476
        0x0080f844:    00207e46    F~ .    DCD    2129478
        0x0080f848:    0880081c    ....    DCD    142608412
        0x0080f84c:    00207e3e    >~ .    DCD    2129470
        0x0080f850:    6c616552    Real    DCD    1818322258
        0x0080f854:    206b6574    tek     DCD    543909236
        0x0080f858:    00005442    BT..    DCD    21570
        0x0080f85c:    65646f4d    Mode    DCD    1701080909
        0x0080f860:    624e206c    l Nb    DCD    1649287276
        0x0080f864:    2e302072    r 0.    DCD    774905970
        0x0080f868:    00000039    9...    DCD    57
        0x0080f86c:    424b5452    RTKB    DCD    1112233042
        0x0080f870:    65536565    eeSe    DCD    1699964261
        0x0080f874:    6c616972    rial    DCD    1818323314
        0x0080f878:    006d754e    Num.    DCD    7173454
        0x0080f87c:    424b5452    RTKB    DCD    1112233042
        0x0080f880:    61486565    eeHa    DCD    1632134501
        0x0080f884:    61776472    rdwa    DCD    1635214450
        0x0080f888:    65526572    reRe    DCD    1699898738
        0x0080f88c:    00000076    v...    DCD    118
        0x0080f890:    424b5452    RTKB    DCD    1112233042
        0x0080f894:    69466565    eeFi    DCD    1766221157
        0x0080f898:    61776d72    rmwa    DCD    1635216754
        0x0080f89c:    65526572    reRe    DCD    1699898738
        0x0080f8a0:    00000076    v...    DCD    118
        0x0080f8a4:    424b5452    RTKB    DCD    1112233042
        0x0080f8a8:    6f536565    eeSo    DCD    1867736421
        0x0080f8ac:    61777466    ftwa    DCD    1635218534
        0x0080f8b0:    65526572    reRe    DCD    1699898738
        0x0080f8b4:    00000076    v...    DCD    118
        0x0080f8b8:    00020100    ....    DCD    131328
        0x0080f8bc:    05040300    ....    DCD    84148992
        0x0080f8c0:    424b5452    RTKB    DCD    1112233042
        0x0080f8c4:    45496565    eeIE    DCD    1162437989
        0x0080f8c8:    61444545    EEDa    DCD    1631864133
        0x0080f8cc:    696c6174    tali    DCD    1768710516
        0x0080f8d0:    00007473    st..    DCD    29811
        0x0080f8d4:    01005d01    .]..    DCD    16801025
        0x0080f8d8:    00000000    ....    DCD    0
        0x0080f8dc:    00207e3f    ?~ .    DCD    2129471
        0x0080f8e0:    08800860    `...    DCD    142608480
        0x0080f8e4:    00207e40    @~ .    DCD    2129472
    $t
    .text
    load_overlay
;;; .\..\..\..\src\mcu\rtl876x\overlay_mgr.c
;;;120    {
        0x0080f8e8:    b570        p.      PUSH     {r4-r6,lr}
        0x0080f8ea:    4605        .F      MOV      r5,r0
;;;121        const T_OVERLAY_SECTION *selected_scenario;
;;;122    
;;;123        if (scenario_idx >= OVERLAY_SCENARIO_NUM)
        0x0080f8ec:    2d03        .-      CMP      r5,#3
        0x0080f8ee:    db01        ..      BLT      0x80f8f4 ; load_overlay + 12
;;;124        {
;;;125            return false;
        0x0080f8f0:    2000        .       MOVS     r0,#0
        0x0080f8f2:    bd70        p.      POP      {r4-r6,pc}
;;;126        }
;;;127    
;;;128        selected_scenario = &overlay_sections[scenario_idx];
        0x0080f8f4:    eb0500c5    ....    ADD      r0,r5,r5,LSL #3
        0x0080f8f8:    491a        .I      LDR      r1,[pc,#104] ; [0x80f964] = 0x207d70
        0x0080f8fa:    eb010480    ....    ADD      r4,r1,r0,LSL #2
;;;129    
;;;130        if (memcmp(selected_scenario->signature, scenario_name, 8) == 0)
        0x0080f8fe:    2208        ."      MOVS     r2,#8
        0x0080f900:    4919        .I      LDR      r1,[pc,#100] ; [0x80f968] = 0x207e48
        0x0080f902:    6820         h      LDR      r0,[r4,#0]
        0x0080f904:    f44af27e    J.~.    BL       memcmp ; 0x59e04
        0x0080f908:    b908        ..      CBNZ     r0,0x80f90e ; load_overlay + 38
;;;131        {
;;;132            return true;
        0x0080f90a:    2001        .       MOVS     r0,#1
        0x0080f90c:    e7f1        ..      B        0x80f8f2 ; load_overlay + 10
;;;133        }
;;;134    
;;;135        /* load code */
;;;136        memcpy(selected_scenario->image_ro_base, selected_scenario->load_ro_base,
        0x0080f90e:    69a2        .i      LDR      r2,[r4,#0x18]
        0x0080f910:    6861        ah      LDR      r1,[r4,#4]
        0x0080f912:    68e0        .h      LDR      r0,[r4,#0xc]
        0x0080f914:    f44af2c1    J...    BL       __aeabi_memcpy ; 0x59e9a
;;;137               selected_scenario->ro_length);
;;;138        /* load rw data */
;;;139        memcpy(selected_scenario->image_rw_base, selected_scenario->load_rw_base,
        0x0080f918:    69e2        .i      LDR      r2,[r4,#0x1c]
        0x0080f91a:    68a1        .h      LDR      r1,[r4,#8]
        0x0080f91c:    6920         i      LDR      r0,[r4,#0x10]
        0x0080f91e:    f44af2bc    J...    BL       __aeabi_memcpy ; 0x59e9a
;;;140               selected_scenario->rw_length);
;;;141        /* clear zi data */
;;;142        memset(selected_scenario->image_zi_base, 0x0, selected_scenario->zi_length);
        0x0080f922:    6a21        !j      LDR      r1,[r4,#0x20]
        0x0080f924:    6960        `i      LDR      r0,[r4,#0x14]
        0x0080f926:    f44af379    J.y.    BL       __aeabi_memclr ; 0x5a01c
;;;143    
;;;144        memcpy(scenario_name, selected_scenario->signature, 8);
        0x0080f92a:    490f        .I      LDR      r1,[pc,#60] ; [0x80f968] = 0x207e48
        0x0080f92c:    6820         h      LDR      r0,[r4,#0]
        0x0080f92e:    6802        .h      LDR      r2,[r0,#0]
        0x0080f930:    600a        .`      STR      r2,[r1,#0]
        0x0080f932:    6840        @h      LDR      r0,[r0,#4]
        0x0080f934:    6048        H`      STR      r0,[r1,#4]
;;;145    
;;;146        return true;
        0x0080f936:    2001        .       MOVS     r0,#1
        0x0080f938:    e7db        ..      B        0x80f8f2 ; load_overlay + 10
    get_current_scenario_index
;;;147    }
;;;148    
;;;149    T_OVERLAY_SCENARIO_IDX get_current_scenario_index(void)
;;;150    {
        0x0080f93a:    b570        p.      PUSH     {r4-r6,lr}
;;;151        const T_OVERLAY_SECTION *selected_scenario;
;;;152    
;;;153        for (int i = 0; i < (int)OVERLAY_SCENARIO_NUM; ++i)
        0x0080f93c:    2400        .$      MOVS     r4,#0
        0x0080f93e:    e00d        ..      B        0x80f95c ; get_current_scenario_index + 34
        0x0080f940:    eb0400c4    ....    ADD      r0,r4,r4,LSL #3
        0x0080f944:    4907        .I      LDR      r1,[pc,#28] ; [0x80f964] = 0x207d70
        0x0080f946:    eb010580    ....    ADD      r5,r1,r0,LSL #2
        0x0080f94a:    2208        ."      MOVS     r2,#8
        0x0080f94c:    4906        .I      LDR      r1,[pc,#24] ; [0x80f968] = 0x207e48
        0x0080f94e:    6828        (h      LDR      r0,[r5,#0]
        0x0080f950:    f44af258    J.X.    BL       memcmp ; 0x59e04
        0x0080f954:    b908        ..      CBNZ     r0,0x80f95a ; get_current_scenario_index + 32
        0x0080f956:    b2e0        ..      UXTB     r0,r4
        0x0080f958:    bd70        p.      POP      {r4-r6,pc}
        0x0080f95a:    1c64        d.      ADDS     r4,r4,#1
        0x0080f95c:    2c03        .,      CMP      r4,#3
        0x0080f95e:    dbef        ..      BLT      0x80f940 ; get_current_scenario_index + 6
;;;154        {
;;;155            selected_scenario = &overlay_sections[i];
;;;156            if (memcmp(selected_scenario->signature, scenario_name, 8) == 0)
;;;157            {
;;;158                return (T_OVERLAY_SCENARIO_IDX)i;
;;;159            }
;;;160        }
;;;161    
;;;162        return OVERLAY_SCENARIO_NUM; //not found valid scenario
        0x0080f960:    2003        .       MOVS     r0,#3
        0x0080f962:    e7f9        ..      B        0x80f958 ; get_current_scenario_index + 30
    $d
        0x0080f964:    00207d70    p} .    DCD    2129264
        0x0080f968:    00207e48    H~ .    DCD    2129480
    $t
    .text
    bas_set_parameter
;;; .\..\..\..\src\ble\profile\server\bas.c
;;;137    {
        0x0080f96c:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x0080f970:    4604        .F      MOV      r4,r0
        0x0080f972:    460d        .F      MOV      r5,r1
        0x0080f974:    4616        .F      MOV      r6,r2
;;;138        bool ret = true;
        0x0080f976:    2701        .'      MOVS     r7,#1
;;;139    
;;;140        switch (param_type)
        0x0080f978:    2c01        .,      CMP      r4,#1
        0x0080f97a:    d00a        ..      BEQ      0x80f992 ; bas_set_parameter + 38
;;;141        {
;;;142        default:
;;;143            {
;;;144                ret = false;
        0x0080f97c:    2700        .'      MOVS     r7,#0
;;;145                PROFILE_PRINT_ERROR0("bas_set_parameter failed");
        0x0080f97e:    bf00        ..      NOP      
        0x0080f980:    bf00        ..      NOP      
        0x0080f982:    2200        ."      MOVS     r2,#0
        0x0080f984:    496c        lI      LDR      r1,[pc,#432] ; [0x80fb38] = 0x8800a48
        0x0080f986:    486d        mH      LDR      r0,[pc,#436] ; [0x80fb3c] = 0x21103300
        0x0080f988:    f7f8d869    ..i.    BL       log_buffer ; 0x7a5e
        0x0080f98c:    bf00        ..      NOP      
        0x0080f98e:    bf00        ..      NOP      
;;;146            }
;;;147            break;
        0x0080f990:    e007        ..      B        0x80f9a2 ; bas_set_parameter + 54
;;;148    
;;;149        case BAS_PARAM_BATTERY_LEVEL:
;;;150            {
;;;151                if (length != sizeof(uint8_t))
        0x0080f992:    2d01        .-      CMP      r5,#1
        0x0080f994:    d001        ..      BEQ      0x80f99a ; bas_set_parameter + 46
;;;152                {
;;;153                    ret = false;
        0x0080f996:    2700        .'      MOVS     r7,#0
        0x0080f998:    e002        ..      B        0x80f9a0 ; bas_set_parameter + 52
;;;154                }
;;;155                else
;;;156                {
;;;157                    battery_level = p_value[0];
        0x0080f99a:    7830        0x      LDRB     r0,[r6,#0]
        0x0080f99c:    4968        hI      LDR      r1,[pc,#416] ; [0x80fb40] = 0x207e50
        0x0080f99e:    7008        .p      STRB     r0,[r1,#0]
;;;158                }
;;;159            }
;;;160            break;
        0x0080f9a0:    bf00        ..      NOP      
        0x0080f9a2:    bf00        ..      NOP      
;;;161        }
;;;162    
;;;163        return ret;
        0x0080f9a4:    4638        8F      MOV      r0,r7
;;;164    }
        0x0080f9a6:    e8bd81f0    ....    POP      {r4-r8,pc}
    bas_battery_level_value_notify
;;;165    
;;;166    /**
;;;167     * @brief       Send notify battery level notification data .
;;;168     *
;;;169     * @param[in]   conn_id  Connection id.
;;;170     * @param[in]   service_id  Service id.
;;;171     * @param[in]   battery_level  Battery level value.
;;;172     * @return Operation result.
;;;173     * @retval true Operation success.
;;;174     * @retval false Operation failure.
;;;175     *
;;;176     * <b>Example usage</b>
;;;177     * \code{.c}
;;;178        void test(void)
;;;179        {
;;;180            uint8_t battery_level = 90;
;;;181            bas_battery_level_value_notify(conn_id, bas_id, battery_level);
;;;182        }
;;;183     * \endcode
;;;184     */
;;;185    bool bas_battery_level_value_notify(uint8_t conn_id, uint8_t service_id, uint8_t battery_level)
;;;186    {
        0x0080f9aa:    b537        7.      PUSH     {r0-r2,r4,r5,lr}
        0x0080f9ac:    b082        ..      SUB      sp,sp,#8
        0x0080f9ae:    4604        .F      MOV      r4,r0
        0x0080f9b0:    460d        .F      MOV      r5,r1
;;;187        return server_send_data(conn_id, service_id, GATT_SVC_BAS_BATTERY_LEVEL_INDEX, &battery_level,
        0x0080f9b2:    2000        .       MOVS     r0,#0
        0x0080f9b4:    2101        .!      MOVS     r1,#1
        0x0080f9b6:    ab04        ..      ADD      r3,sp,#0x10
        0x0080f9b8:    2202        ."      MOVS     r2,#2
        0x0080f9ba:    e9cd1000    ....    STRD     r1,r0,[sp,#0]
        0x0080f9be:    4629        )F      MOV      r1,r5
        0x0080f9c0:    4620         F      MOV      r0,r4
        0x0080f9c2:    f43ff6ef    ?...    BL       server_send_data ; 0x4f7a4
;;;188                                sizeof(battery_level), GATT_PDU_TYPE_ANY);
;;;189    }
        0x0080f9c6:    b005        ..      ADD      sp,sp,#0x14
        0x0080f9c8:    bd30        0.      POP      {r4,r5,pc}
    bas_battery_level_value_read_confirm
;;;190    
;;;191    /**
;;;192     * @brief       Confirm for read battery level value request.
;;;193     *
;;;194     * @param[in]   conn_id  Callback when service attribute was read/write.
;;;195     * @param[in]   service_id  Callback when service attribute was read/write.
;;;196     * @param[in]   battery_level  Callback when service attribute was read/write.
;;;197     * @return Operation result.
;;;198     * @retval true Operation success.
;;;199     * @retval false Operation failure.
;;;200     *
;;;201     * <b>Example usage</b>
;;;202     * \code{.c}
;;;203        void test(void)
;;;204        {
;;;205            uint8_t battery_level = 90;
;;;206            bas_battery_level_value_read_confirm(conn_id, bas_id, battery_level);
;;;207        }
;;;208     * \endcode
;;;209     */
;;;210    bool bas_battery_level_value_read_confirm(uint8_t conn_id, uint8_t service_id,
;;;211                                              uint8_t battery_level)
;;;212    {
        0x0080f9ca:    b537        7.      PUSH     {r0-r2,r4,r5,lr}
        0x0080f9cc:    b082        ..      SUB      sp,sp,#8
        0x0080f9ce:    4604        .F      MOV      r4,r0
        0x0080f9d0:    460d        .F      MOV      r5,r1
;;;213        if (bas_read_battery_level_pending == true)
        0x0080f9d2:    485c        \H      LDR      r0,[pc,#368] ; [0x80fb44] = 0x207e51
        0x0080f9d4:    7800        .x      LDRB     r0,[r0,#0]
        0x0080f9d6:    2801        .(      CMP      r0,#1
        0x0080f9d8:    d10d        ..      BNE      0x80f9f6 ; bas_battery_level_value_read_confirm + 44
;;;214        {
;;;215            bas_read_battery_level_pending = false;
        0x0080f9da:    2000        .       MOVS     r0,#0
        0x0080f9dc:    4959        YI      LDR      r1,[pc,#356] ; [0x80fb44] = 0x207e51
        0x0080f9de:    7008        .p      STRB     r0,[r1,#0]
;;;216            return server_attr_read_confirm(conn_id, service_id, GATT_SVC_BAS_BATTERY_LEVEL_INDEX,
        0x0080f9e0:    2101        .!      MOVS     r1,#1
        0x0080f9e2:    ab04        ..      ADD      r3,sp,#0x10
        0x0080f9e4:    2202        ."      MOVS     r2,#2
        0x0080f9e6:    e9cd1000    ....    STRD     r1,r0,[sp,#0]
        0x0080f9ea:    4629        )F      MOV      r1,r5
        0x0080f9ec:    4620         F      MOV      r0,r4
        0x0080f9ee:    f43ff650    ?.P.    BL       server_attr_read_confirm ; 0x4f692
        0x0080f9f2:    b005        ..      ADD      sp,sp,#0x14
        0x0080f9f4:    bd30        0.      POP      {r4,r5,pc}
;;;217                                            &battery_level, sizeof(battery_level), APP_RESULT_SUCCESS);
;;;218        }
;;;219        else
;;;220        {
;;;221            return false;
        0x0080f9f6:    2000        .       MOVS     r0,#0
        0x0080f9f8:    e7fb        ..      B        0x80f9f2 ; bas_battery_level_value_read_confirm + 40
    bas_attr_read_cb
;;;222        }
;;;223    }
;;;224    
;;;225    /**
;;;226     * @brief read characteristic data from service.
;;;227     *
;;;228     * @param conn_id           Connection ID.
;;;229     * @param service_id        ServiceID to be read.
;;;230     * @param attrib_index      Attribute index of getting characteristic data.
;;;231     * @param offset            Offset of characteritic to be read.
;;;232     * @param p_length          Length of getting characteristic data.
;;;233     * @param pp_value          Pointer to pointer of characteristic value to be read.
;;;234     * @return T_APP_RESULT
;;;235    */
;;;236    T_APP_RESULT bas_attr_read_cb(uint8_t conn_id, T_SERVER_ID service_id, uint16_t attrib_index,
;;;237                                  uint16_t offset, uint16_t *p_length, uint8_t **pp_value)
;;;238    {
        0x0080f9fa:    e92d4ff8    -..O    PUSH     {r3-r11,lr}
        0x0080f9fe:    4605        .F      MOV      r5,r0
        0x0080fa00:    460e        .F      MOV      r6,r1
        0x0080fa02:    4614        .F      MOV      r4,r2
        0x0080fa04:    461f        .F      MOV      r7,r3
        0x0080fa06:    e9dd8a0a    ....    LDRD     r8,r10,[sp,#0x28]
;;;239        T_APP_RESULT cause = APP_RESULT_SUCCESS;
        0x0080fa0a:    f04f0900    O...    MOV      r9,#0
;;;240        *p_length = 0;
        0x0080fa0e:    2000        .       MOVS     r0,#0
        0x0080fa10:    f8a80000    ....    STRH     r0,[r8,#0]
;;;241    
;;;242        PROFILE_PRINT_INFO2("bas_attr_read_cb attrib_index = %d offset %x", attrib_index, offset);
        0x0080fa14:    bf00        ..      NOP      
        0x0080fa16:    bf00        ..      NOP      
        0x0080fa18:    4623        #F      MOV      r3,r4
        0x0080fa1a:    2202        ."      MOVS     r2,#2
        0x0080fa1c:    494a        JI      LDR      r1,[pc,#296] ; [0x80fb48] = 0x8800a64
        0x0080fa1e:    4847        GH      LDR      r0,[pc,#284] ; [0x80fb3c] = 0x21103300
        0x0080fa20:    1c80        ..      ADDS     r0,r0,#2
        0x0080fa22:    9700        ..      STR      r7,[sp,#0]
        0x0080fa24:    f7f8d81b    ....    BL       log_buffer ; 0x7a5e
        0x0080fa28:    bf00        ..      NOP      
        0x0080fa2a:    bf00        ..      NOP      
;;;243    
;;;244        switch (attrib_index)
        0x0080fa2c:    2c02        .,      CMP      r4,#2
        0x0080fa2e:    d00c        ..      BEQ      0x80fa4a ; bas_attr_read_cb + 80
;;;245        {
;;;246        default:
;;;247            {
;;;248                PROFILE_PRINT_ERROR1("bas_attr_read_cb attrib_index = %d not found", attrib_index);
        0x0080fa30:    bf00        ..      NOP      
        0x0080fa32:    bf00        ..      NOP      
        0x0080fa34:    4623        #F      MOV      r3,r4
        0x0080fa36:    2201        ."      MOVS     r2,#1
        0x0080fa38:    4944        DI      LDR      r1,[pc,#272] ; [0x80fb4c] = 0x8800a94
        0x0080fa3a:    4840        @H      LDR      r0,[pc,#256] ; [0x80fb3c] = 0x21103300
        0x0080fa3c:    f7f8d80f    ....    BL       log_buffer ; 0x7a5e
        0x0080fa40:    bf00        ..      NOP      
        0x0080fa42:    bf00        ..      NOP      
;;;249                cause  = APP_RESULT_ATTR_NOT_FOUND;
        0x0080fa44:    f240490a    @..I    MOV      r9,#0x40a
;;;250            }
;;;251            break;
        0x0080fa48:    e01b        ..      B        0x80fa82 ; bas_attr_read_cb + 136
;;;252    
;;;253        case GATT_SVC_BAS_BATTERY_LEVEL_INDEX:
;;;254            {
;;;255                T_BAS_CALLBACK_DATA callback_data;
;;;256                callback_data.msg_type = SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE;
        0x0080fa4a:    2002        .       MOVS     r0,#2
        0x0080fa4c:    f88d0001    ....    STRB     r0,[sp,#1]
;;;257                callback_data.conn_id = conn_id;
        0x0080fa50:    f88d5000    ...P    STRB     r5,[sp,#0]
;;;258                callback_data.msg_data.read_value_index = BAS_READ_BATTERY_LEVEL;
        0x0080fa54:    2001        .       MOVS     r0,#1
        0x0080fa56:    f88d0002    ....    STRB     r0,[sp,#2]
;;;259                cause = pfn_bas_cb(service_id, (void *)&callback_data);
        0x0080fa5a:    4669        iF      MOV      r1,sp
        0x0080fa5c:    4630        0F      MOV      r0,r6
        0x0080fa5e:    4a3c        <J      LDR      r2,[pc,#240] ; [0x80fb50] = 0x207e54
        0x0080fa60:    6812        .h      LDR      r2,[r2,#0]
        0x0080fa62:    4790        .G      BLX      r2
        0x0080fa64:    4681        .F      MOV      r9,r0
;;;260                if (cause == APP_RESULT_PENDING)
        0x0080fa66:    f6405001    @..P    MOV      r0,#0xd01
        0x0080fa6a:    4581        .E      CMP      r9,r0
        0x0080fa6c:    d102        ..      BNE      0x80fa74 ; bas_attr_read_cb + 122
;;;261                {
;;;262                    bas_read_battery_level_pending = true;
        0x0080fa6e:    2001        .       MOVS     r0,#1
        0x0080fa70:    4934        4I      LDR      r1,[pc,#208] ; [0x80fb44] = 0x207e51
        0x0080fa72:    7008        .p      STRB     r0,[r1,#0]
;;;263                }
;;;264    
;;;265                *pp_value = &battery_level;
        0x0080fa74:    4832        2H      LDR      r0,[pc,#200] ; [0x80fb40] = 0x207e50
        0x0080fa76:    f8ca0000    ....    STR      r0,[r10,#0]
;;;266                *p_length = sizeof(battery_level);
        0x0080fa7a:    2001        .       MOVS     r0,#1
        0x0080fa7c:    f8a80000    ....    STRH     r0,[r8,#0]
;;;267            }
;;;268            break;
        0x0080fa80:    bf00        ..      NOP      
        0x0080fa82:    bf00        ..      NOP      
;;;269        }
;;;270        return (cause);
        0x0080fa84:    4648        HF      MOV      r0,r9
;;;271    }
        0x0080fa86:    e8bd8ff8    ....    POP      {r3-r11,pc}
    bas_cccd_update_cb
;;;272    
;;;273    /**
;;;274     * @brief update CCCD bits from stack.
;;;275     *
;;;276     * @param conn_id           Connection ID.
;;;277     * @param service_id        Service ID.
;;;278     * @param index             Attribute index of characteristic data.
;;;279     * @param ccc_bits          CCCD bits from stack.
;;;280     * @return None
;;;281    */
;;;282    void bas_cccd_update_cb(uint8_t conn_id, T_SERVER_ID service_id, uint16_t index, uint16_t ccc_bits)
;;;283    {
        0x0080fa8a:    e92d41fc    -..A    PUSH     {r2-r8,lr}
        0x0080fa8e:    4607        .F      MOV      r7,r0
        0x0080fa90:    460e        .F      MOV      r6,r1
        0x0080fa92:    4614        .F      MOV      r4,r2
        0x0080fa94:    461d        .F      MOV      r5,r3
;;;284        T_BAS_CALLBACK_DATA callback_data;
;;;285        callback_data.msg_type = SERVICE_CALLBACK_TYPE_INDIFICATION_NOTIFICATION;
        0x0080fa96:    2001        .       MOVS     r0,#1
        0x0080fa98:    f88d0005    ....    STRB     r0,[sp,#5]
;;;286        callback_data.conn_id = conn_id;
        0x0080fa9c:    f88d7004    ...p    STRB     r7,[sp,#4]
;;;287        bool handle = true;
        0x0080faa0:    4680        .F      MOV      r8,r0
;;;288        PROFILE_PRINT_INFO2("bas_cccd_update_cb index = %d ccc_bits %x", index, ccc_bits);
        0x0080faa2:    bf00        ..      NOP      
        0x0080faa4:    bf00        ..      NOP      
        0x0080faa6:    4623        #F      MOV      r3,r4
        0x0080faa8:    2202        ."      MOVS     r2,#2
        0x0080faaa:    492a        *I      LDR      r1,[pc,#168] ; [0x80fb54] = 0x8800ac4
        0x0080faac:    4823        #H      LDR      r0,[pc,#140] ; [0x80fb3c] = 0x21103300
        0x0080faae:    1c80        ..      ADDS     r0,r0,#2
        0x0080fab0:    9500        ..      STR      r5,[sp,#0]
        0x0080fab2:    f7f7dfd4    ....    BL       log_buffer ; 0x7a5e
        0x0080fab6:    bf00        ..      NOP      
        0x0080fab8:    bf00        ..      NOP      
;;;289    
;;;290        switch (index)
        0x0080faba:    2c03        .,      CMP      r4,#3
        0x0080fabc:    d10a        ..      BNE      0x80fad4 ; bas_cccd_update_cb + 74
;;;291        {
;;;292        case GATT_SVC_BAS_CHAR_CCCD_INDEX:
;;;293            {
;;;294                if (ccc_bits & GATT_CLIENT_CHAR_CONFIG_NOTIFY)
        0x0080fabe:    f0050001    ....    AND      r0,r5,#1
        0x0080fac2:    b118        ..      CBZ      r0,0x80facc ; bas_cccd_update_cb + 66
;;;295                {
;;;296                    callback_data.msg_data.notification_indification_index = BAS_NOTIFY_BATTERY_LEVEL_ENABLE;
        0x0080fac4:    2001        .       MOVS     r0,#1
        0x0080fac6:    f88d0006    ....    STRB     r0,[sp,#6]
        0x0080faca:    e002        ..      B        0x80fad2 ; bas_cccd_update_cb + 72
;;;297                }
;;;298                else
;;;299                {
;;;300                    callback_data.msg_data.notification_indification_index = BAS_NOTIFY_BATTERY_LEVEL_DISABLE;
        0x0080facc:    2002        .       MOVS     r0,#2
        0x0080face:    f88d0006    ....    STRB     r0,[sp,#6]
;;;301                }
;;;302                break;
        0x0080fad2:    e002        ..      B        0x80fada ; bas_cccd_update_cb + 80
        0x0080fad4:    f04f0800    O...    MOV      r8,#0
        0x0080fad8:    bf00        ..      NOP      
        0x0080fada:    bf00        ..      NOP      
;;;303            }
;;;304        default:
;;;305            {
;;;306                handle = false;
;;;307                break;
;;;308            }
;;;309    
;;;310        }
;;;311    
;;;312        if (pfn_bas_cb && (handle == true))
        0x0080fadc:    481c        .H      LDR      r0,[pc,#112] ; [0x80fb50] = 0x207e54
        0x0080fade:    6800        .h      LDR      r0,[r0,#0]
        0x0080fae0:    b138        8.      CBZ      r0,0x80faf2 ; bas_cccd_update_cb + 104
        0x0080fae2:    f1b80f01    ....    CMP      r8,#1
        0x0080fae6:    d104        ..      BNE      0x80faf2 ; bas_cccd_update_cb + 104
;;;313        {
;;;314            pfn_bas_cb(service_id, (void *)&callback_data);
        0x0080fae8:    a901        ..      ADD      r1,sp,#4
        0x0080faea:    4630        0F      MOV      r0,r6
        0x0080faec:    4a18        .J      LDR      r2,[pc,#96] ; [0x80fb50] = 0x207e54
        0x0080faee:    6812        .h      LDR      r2,[r2,#0]
        0x0080faf0:    4790        .G      BLX      r2
;;;315        }
;;;316    
;;;317        return;
;;;318    }
        0x0080faf2:    e8bd81fc    ....    POP      {r2-r8,pc}
    bas_add_service
;;;319    
;;;320    /**
;;;321     * @brief BAS Service Callbacks.
;;;322    */
;;;323    const T_FUN_GATT_SERVICE_CBS bas_cbs =
;;;324    {
;;;325        bas_attr_read_cb,  // Read callback function pointer
;;;326        NULL, // Write callback function pointer
;;;327        bas_cccd_update_cb  // CCCD update callback function pointer
;;;328    };
;;;329    
;;;330    /**
;;;331      * @brief       Add battery service to the BLE stack database.
;;;332      *
;;;333      *
;;;334      * @param[in]   p_func  Callback when service attribute was read, write or cccd update.
;;;335      * @return Service id generated by the BLE stack: @ref T_SERVER_ID.
;;;336      * @retval 0xFF Operation failure.
;;;337      * @retval Others Service id assigned by stack.
;;;338      *
;;;339      * <b>Example usage</b>
;;;340      * \code{.c}
;;;341         void profile_init()
;;;342         {
;;;343             server_init(1);
;;;344             bas_id = bas_add_service(app_handle_profile_message);
;;;345         }
;;;346      * \endcode
;;;347      */
;;;348    T_SERVER_ID bas_add_service(void *p_func)
;;;349    {
        0x0080faf6:    b53e        >.      PUSH     {r1-r5,lr}
        0x0080faf8:    4604        .F      MOV      r4,r0
;;;350        T_SERVER_ID service_id;
;;;351        if (false == server_add_service(&service_id,
        0x0080fafa:    4917        .I      LDR      r1,[pc,#92] ; [0x80fb58] = 0x81175c
        0x0080fafc:    e9d10101    ....    LDRD     r0,r1,[r1,#4]
        0x0080fb00:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
        0x0080fb04:    4814        .H      LDR      r0,[pc,#80] ; [0x80fb58] = 0x81175c
        0x0080fb06:    2270        p"      MOVS     r2,#0x70
        0x0080fb08:    4914        .I      LDR      r1,[pc,#80] ; [0x80fb5c] = 0x8116ec
        0x0080fb0a:    6803        .h      LDR      r3,[r0,#0]
        0x0080fb0c:    a802        ..      ADD      r0,sp,#8
        0x0080fb0e:    f43ff5ae    ?...    BL       server_add_service ; 0x4f66e
        0x0080fb12:    b960        `.      CBNZ     r0,0x80fb2e ; bas_add_service + 56
;;;352                                        (uint8_t *)bas_attr_tbl,
;;;353                                        bas_attr_tbl_size,
;;;354                                        bas_cbs))
;;;355        {
;;;356            PROFILE_PRINT_ERROR1("bas_add_service: service_id %d", service_id);
        0x0080fb14:    bf00        ..      NOP      
        0x0080fb16:    bf00        ..      NOP      
        0x0080fb18:    f89d3008    ...0    LDRB     r3,[sp,#8]
        0x0080fb1c:    2201        ."      MOVS     r2,#1
        0x0080fb1e:    4910        .I      LDR      r1,[pc,#64] ; [0x80fb60] = 0x8800af4
        0x0080fb20:    4806        .H      LDR      r0,[pc,#24] ; [0x80fb3c] = 0x21103300
        0x0080fb22:    f7f7df9c    ....    BL       log_buffer ; 0x7a5e
        0x0080fb26:    bf00        ..      NOP      
        0x0080fb28:    bf00        ..      NOP      
;;;357            service_id = 0xff;
        0x0080fb2a:    20ff        .       MOVS     r0,#0xff
        0x0080fb2c:    9002        ..      STR      r0,[sp,#8]
;;;358        }
;;;359        pfn_bas_cb = (P_FUN_SERVER_GENERAL_CB)p_func;
        0x0080fb2e:    4808        .H      LDR      r0,[pc,#32] ; [0x80fb50] = 0x207e54
        0x0080fb30:    6004        .`      STR      r4,[r0,#0]
;;;360        return service_id;
        0x0080fb32:    f89d0008    ....    LDRB     r0,[sp,#8]
;;;361    }
        0x0080fb36:    bd3e        >.      POP      {r1-r5,pc}
    $d
        0x0080fb38:    08800a48    H...    DCD    142608968
        0x0080fb3c:    21103300    .3.!    DCD    554709760
        0x0080fb40:    00207e50    P~ .    DCD    2129488
        0x0080fb44:    00207e51    Q~ .    DCD    2129489
        0x0080fb48:    08800a64    d...    DCD    142608996
        0x0080fb4c:    08800a94    ....    DCD    142609044
        0x0080fb50:    00207e54    T~ .    DCD    2129492
        0x0080fb54:    08800ac4    ....    DCD    142609092
        0x0080fb58:    0081175c    \...    DCD    8460124
        0x0080fb5c:    008116ec    ....    DCD    8460012
        0x0080fb60:    08800af4    ....    DCD    142609140
    $t
    .text
    dis_set_parameter
;;; .\..\..\..\src\ble\profile\server\dis.c
;;;422    {
        0x0080fb64:    e92d41f0    -..A    PUSH     {r4-r8,lr}
        0x0080fb68:    4605        .F      MOV      r5,r0
        0x0080fb6a:    460c        .F      MOV      r4,r1
        0x0080fb6c:    4616        .F      MOV      r6,r2
;;;423        bool ret = true;
        0x0080fb6e:    2701        .'      MOVS     r7,#1
;;;424    
;;;425        switch (param_type)
        0x0080fb70:    2d09        .-      CMP      r5,#9
        0x0080fb72:    d206        ..      BCS      0x80fb82 ; dis_set_parameter + 30
        0x0080fb74:    e8dff005    ....    TBB      [pc,r5]
    $d
        0x0080fb78:    281d1207    ...(    DCD    672993799
        0x0080fb7c:    52493e33    3>IR    DCD    1380531763
        0x0080fb80:    005d        ].      DCW    93
    $t
;;;426        {
;;;427        default:
;;;428            ret = false;
        0x0080fb82:    2700        .'      MOVS     r7,#0
;;;429            break;
        0x0080fb84:    e05e        ^.      B        0x80fc44 ; dis_set_parameter + 224
;;;430    
;;;431    #if DIS_CHAR_MANUFACTURER_NAME_SUPPORT
;;;432        case DIS_PARAM_MANUFACTURER_NAME:
;;;433            if (length > DIS_CHAR_MANUFACTURER_NAME_STR_MAX_LENGTH)
        0x0080fb86:    2c14        .,      CMP      r4,#0x14
        0x0080fb88:    dd00        ..      BLE      0x80fb8c ; dis_set_parameter + 40
;;;434            {
;;;435                length = DIS_CHAR_MANUFACTURER_NAME_STR_MAX_LENGTH;
        0x0080fb8a:    2414        .$      MOVS     r4,#0x14
;;;436            }
;;;437            dis_manufacturer_name_len = length;
        0x0080fb8c:    48a2        .H      LDR      r0,[pc,#648] ; [0x80fe18] = 0x207e70
        0x0080fb8e:    7004        .p      STRB     r4,[r0,#0]
;;;438            memcpy(dis_manufacturer_name, p_value, length);
        0x0080fb90:    4622        "F      MOV      r2,r4
        0x0080fb92:    4631        1F      MOV      r1,r6
        0x0080fb94:    48a1        .H      LDR      r0,[pc,#644] ; [0x80fe1c] = 0x207e5c
        0x0080fb96:    f44af180    J...    BL       __aeabi_memcpy ; 0x59e9a
;;;439            break;
        0x0080fb9a:    e053        S.      B        0x80fc44 ; dis_set_parameter + 224
;;;440    #endif
;;;441    
;;;442    #if DIS_CHAR_MODEL_NUMBER_SUPPORT
;;;443        case DIS_PARAM_MODEL_NUMBER:
;;;444            if (length > DIS_CHAR_MODEL_NUMBER_STR_MAX_LENGTH)
        0x0080fb9c:    2c14        .,      CMP      r4,#0x14
        0x0080fb9e:    dd00        ..      BLE      0x80fba2 ; dis_set_parameter + 62
;;;445            {
;;;446                length = DIS_CHAR_MODEL_NUMBER_STR_MAX_LENGTH;
        0x0080fba0:    2414        .$      MOVS     r4,#0x14
;;;447            }
;;;448            dis_model_number_len = length;
        0x0080fba2:    489f        .H      LDR      r0,[pc,#636] ; [0x80fe20] = 0x207e85
        0x0080fba4:    7004        .p      STRB     r4,[r0,#0]
;;;449            memcpy(dis_model_number, p_value, length);
        0x0080fba6:    4622        "F      MOV      r2,r4
        0x0080fba8:    4631        1F      MOV      r1,r6
        0x0080fbaa:    489e        .H      LDR      r0,[pc,#632] ; [0x80fe24] = 0x207e71
        0x0080fbac:    f44af175    J.u.    BL       __aeabi_memcpy ; 0x59e9a
;;;450            break;
        0x0080fbb0:    e048        H.      B        0x80fc44 ; dis_set_parameter + 224
;;;451    #endif
;;;452    
;;;453    #if DIS_CHAR_SERIAL_NUMBER_SUPPORT
;;;454        case DIS_PARAM_SERIAL_NUMBER:
;;;455            if (length > DIS_CHAR_SERIAL_NUMBER_STR_MAX_LENGTH)
        0x0080fbb2:    2c14        .,      CMP      r4,#0x14
        0x0080fbb4:    dd00        ..      BLE      0x80fbb8 ; dis_set_parameter + 84
;;;456            {
;;;457                length = DIS_CHAR_SERIAL_NUMBER_STR_MAX_LENGTH;
        0x0080fbb6:    2414        .$      MOVS     r4,#0x14
;;;458            }
;;;459            dis_serial_number_len = length;
        0x0080fbb8:    489b        .H      LDR      r0,[pc,#620] ; [0x80fe28] = 0x207e9a
        0x0080fbba:    7004        .p      STRB     r4,[r0,#0]
;;;460            memcpy(dis_serial_number, p_value, length);
        0x0080fbbc:    4622        "F      MOV      r2,r4
        0x0080fbbe:    4631        1F      MOV      r1,r6
        0x0080fbc0:    489a        .H      LDR      r0,[pc,#616] ; [0x80fe2c] = 0x207e86
        0x0080fbc2:    f44af16a    J.j.    BL       __aeabi_memcpy ; 0x59e9a
;;;461    
;;;462            break;
        0x0080fbc6:    e03d        =.      B        0x80fc44 ; dis_set_parameter + 224
;;;463    #endif
;;;464    
;;;465    #if DIS_CHAR_HARDWARE_REVISION_SUPPORT
;;;466        case DIS_PARAM_HARDWARE_REVISION:
;;;467            if (length > DIS_CHAR_HARDWARE_REVISION_STR_MAX_LENGTH)
        0x0080fbc8:    2c14        .,      CMP      r4,#0x14
        0x0080fbca:    dd00        ..      BLE      0x80fbce ; dis_set_parameter + 106
;;;468            {
;;;469                length = DIS_CHAR_HARDWARE_REVISION_STR_MAX_LENGTH;
        0x0080fbcc:    2414        .$      MOVS     r4,#0x14
;;;470            }
;;;471            dis_hardware_rev_len = length;
        0x0080fbce:    4898        .H      LDR      r0,[pc,#608] ; [0x80fe30] = 0x207eaf
        0x0080fbd0:    7004        .p      STRB     r4,[r0,#0]
;;;472            memcpy(dis_hardware_rev, p_value, length);
        0x0080fbd2:    4622        "F      MOV      r2,r4
        0x0080fbd4:    4631        1F      MOV      r1,r6
        0x0080fbd6:    4897        .H      LDR      r0,[pc,#604] ; [0x80fe34] = 0x207e9b
        0x0080fbd8:    f44af15f    J._.    BL       __aeabi_memcpy ; 0x59e9a
;;;473            break;
        0x0080fbdc:    e032        2.      B        0x80fc44 ; dis_set_parameter + 224
;;;474    #endif
;;;475    
;;;476    #if DIS_CHAR_FIRMWARE_REVISION_SUPPORT
;;;477        case DIS_PARAM_FIRMWARE_REVISION:
;;;478            if (length > DIS_CHAR_FIRMWARE_REVISION_STR_MAX_LENGTH)
        0x0080fbde:    2c14        .,      CMP      r4,#0x14
        0x0080fbe0:    dd00        ..      BLE      0x80fbe4 ; dis_set_parameter + 128
;;;479            {
;;;480                length = DIS_CHAR_FIRMWARE_REVISION_STR_MAX_LENGTH;
        0x0080fbe2:    2414        .$      MOVS     r4,#0x14
;;;481            }
;;;482            dis_firmware_rev_len = length;
        0x0080fbe4:    4894        .H      LDR      r0,[pc,#592] ; [0x80fe38] = 0x207ec4
        0x0080fbe6:    7004        .p      STRB     r4,[r0,#0]
;;;483            memcpy(dis_firmware_rev, p_value, length);
        0x0080fbe8:    4622        "F      MOV      r2,r4
        0x0080fbea:    4631        1F      MOV      r1,r6
        0x0080fbec:    4893        .H      LDR      r0,[pc,#588] ; [0x80fe3c] = 0x207eb0
        0x0080fbee:    f44af154    J.T.    BL       __aeabi_memcpy ; 0x59e9a
;;;484            break;
        0x0080fbf2:    e027        '.      B        0x80fc44 ; dis_set_parameter + 224
;;;485    #endif
;;;486    
;;;487    #if DIS_CHAR_SOFTWARE_REVISION_SUPPORT
;;;488        case DIS_PARAM_SOFTWARE_REVISION:
;;;489            if (length > DIS_CHAR_SOFTWARE_REVISION_STR_MAX_LENGTH)
        0x0080fbf4:    2c14        .,      CMP      r4,#0x14
        0x0080fbf6:    dd00        ..      BLE      0x80fbfa ; dis_set_parameter + 150
;;;490            {
;;;491                length = DIS_CHAR_SOFTWARE_REVISION_STR_MAX_LENGTH;
        0x0080fbf8:    2414        .$      MOVS     r4,#0x14
;;;492            }
;;;493            dis_software_rev_len = length;
        0x0080fbfa:    4891        .H      LDR      r0,[pc,#580] ; [0x80fe40] = 0x207ed9
        0x0080fbfc:    7004        .p      STRB     r4,[r0,#0]
;;;494            memcpy(dis_software_rev, p_value, length);
        0x0080fbfe:    4622        "F      MOV      r2,r4
        0x0080fc00:    4631        1F      MOV      r1,r6
        0x0080fc02:    4890        .H      LDR      r0,[pc,#576] ; [0x80fe44] = 0x207ec5
        0x0080fc04:    f44af149    J.I.    BL       __aeabi_memcpy ; 0x59e9a
;;;495            break;
        0x0080fc08:    e01c        ..      B        0x80fc44 ; dis_set_parameter + 224
;;;496    #endif
;;;497    
;;;498    #if DIS_CHAR_SYSTEM_ID_SUPPORT
;;;499        case DIS_PARAM_SYSTEM_ID:
;;;500            if (length > DIS_SYSTEM_ID_LENGTH)
        0x0080fc0a:    2c08        .,      CMP      r4,#8
        0x0080fc0c:    dd00        ..      BLE      0x80fc10 ; dis_set_parameter + 172
;;;501            {
;;;502                length = DIS_SYSTEM_ID_LENGTH;
        0x0080fc0e:    2408        .$      MOVS     r4,#8
;;;503            }
;;;504            memcpy(dis_system_id, p_value, length);
        0x0080fc10:    4622        "F      MOV      r2,r4
        0x0080fc12:    4631        1F      MOV      r1,r6
        0x0080fc14:    488c        .H      LDR      r0,[pc,#560] ; [0x80fe48] = 0x207ddc
        0x0080fc16:    f44af140    J.@.    BL       __aeabi_memcpy ; 0x59e9a
;;;505            break;
        0x0080fc1a:    e013        ..      B        0x80fc44 ; dis_set_parameter + 224
;;;506    #endif
;;;507    
;;;508    #if DIS_CHAR_IEEE_CERTIF_DATA_LIST_SUPPORT
;;;509        case DIS_PARAM_IEEE_DATA_LIST:
;;;510            if (length > DIS_CHAR_IEEE_CERTIF_DATA_LIST_MAX_LENGTH)
        0x0080fc1c:    2c1e        .,      CMP      r4,#0x1e
        0x0080fc1e:    dd00        ..      BLE      0x80fc22 ; dis_set_parameter + 190
;;;511            {
;;;512                length = DIS_CHAR_IEEE_CERTIF_DATA_LIST_MAX_LENGTH;
        0x0080fc20:    241e        .$      MOVS     r4,#0x1e
;;;513            }
;;;514            dis_ieee_data_list_len = length;
        0x0080fc22:    488a        .H      LDR      r0,[pc,#552] ; [0x80fe4c] = 0x207e09
        0x0080fc24:    7004        .p      STRB     r4,[r0,#0]
;;;515            memcpy(dis_ieee_data_list, p_value, length);
        0x0080fc26:    4622        "F      MOV      r2,r4
        0x0080fc28:    4631        1F      MOV      r1,r6
        0x0080fc2a:    4889        .H      LDR      r0,[pc,#548] ; [0x80fe50] = 0x207deb
        0x0080fc2c:    f44af135    J.5.    BL       __aeabi_memcpy ; 0x59e9a
;;;516            break;
        0x0080fc30:    e008        ..      B        0x80fc44 ; dis_set_parameter + 224
;;;517    #endif
;;;518    
;;;519    #if DIS_CHAR_PNP_ID_SUPPORT
;;;520        case DIS_PARAM_PNP_ID:
;;;521            if (length > DIS_PNP_ID_LENGTH)
        0x0080fc32:    2c07        .,      CMP      r4,#7
        0x0080fc34:    dd00        ..      BLE      0x80fc38 ; dis_set_parameter + 212
;;;522            {
;;;523                length = DIS_PNP_ID_LENGTH;
        0x0080fc36:    2407        .$      MOVS     r4,#7
;;;524            }
;;;525            memcpy(dis_pnp_id, p_value, length);
        0x0080fc38:    4622        "F      MOV      r2,r4
        0x0080fc3a:    4631        1F      MOV      r1,r6
        0x0080fc3c:    4885        .H      LDR      r0,[pc,#532] ; [0x80fe54] = 0x207de4
        0x0080fc3e:    f44af12c    J.,.    BL       __aeabi_memcpy ; 0x59e9a
;;;526            break;
        0x0080fc42:    bf00        ..      NOP      
        0x0080fc44:    bf00        ..      NOP      
;;;527    #endif
;;;528        }
;;;529    
;;;530        if (!ret)
        0x0080fc46:    b947        G.      CBNZ     r7,0x80fc5a ; dis_set_parameter + 246
;;;531        {
;;;532            PROFILE_PRINT_ERROR0("DIS parameter set failed");
        0x0080fc48:    bf00        ..      NOP      
        0x0080fc4a:    bf00        ..      NOP      
        0x0080fc4c:    2200        ."      MOVS     r2,#0
        0x0080fc4e:    4982        .I      LDR      r1,[pc,#520] ; [0x80fe58] = 0x8800b18
        0x0080fc50:    4882        .H      LDR      r0,[pc,#520] ; [0x80fe5c] = 0x21103300
        0x0080fc52:    f7f7df04    ....    BL       log_buffer ; 0x7a5e
        0x0080fc56:    bf00        ..      NOP      
        0x0080fc58:    bf00        ..      NOP      
;;;533        }
;;;534    
;;;535        return ret;
        0x0080fc5a:    4638        8F      MOV      r0,r7
;;;536    }
        0x0080fc5c:    e8bd81f0    ....    POP      {r4-r8,pc}
    dis_attr_read_cb
;;;537    
;;;538    /**
;;;539     * @brief Read characteristic data from service.
;;;540     *
;;;541     * @param[in]   conn_id  Connection id.
;;;542     * @param[in] service_id            ServiceID to be read.
;;;543     * @param[in] attrib_index          Attribute index of getting characteristic data.
;;;544     * @param[in] offset                offset of characteritic to be read.
;;;545     * @param[in,out] length_ptr            length of getting characteristic data.
;;;546     * @param[in,out] pp_value              pointer to pointer of characteristic value to be read.
;;;547     * @return T_APP_RESULT
;;;548    */
;;;549    T_APP_RESULT dis_attr_read_cb(uint8_t conn_id, T_SERVER_ID service_id, uint16_t attrib_index,
;;;550                                  uint16_t offset, uint16_t *length_ptr, uint8_t **pp_value)
;;;551    {
        0x0080fc60:    e92d47fc    -..G    PUSH     {r2-r10,lr}
        0x0080fc64:    4607        .F      MOV      r7,r0
        0x0080fc66:    4688        .F      MOV      r8,r1
        0x0080fc68:    4616        .F      MOV      r6,r2
        0x0080fc6a:    469a        .F      MOV      r10,r3
        0x0080fc6c:    e9dd450a    ...E    LDRD     r4,r5,[sp,#0x28]
;;;552        T_DIS_CALLBACK_DATA callback_data;
;;;553        T_APP_RESULT  cause  = APP_RESULT_SUCCESS;
        0x0080fc70:    f04f0900    O...    MOV      r9,#0
;;;554        *length_ptr = 0;
        0x0080fc74:    2000        .       MOVS     r0,#0
        0x0080fc76:    8020         .      STRH     r0,[r4,#0]
;;;555        callback_data.msg_type = SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE;
        0x0080fc78:    2002        .       MOVS     r0,#2
        0x0080fc7a:    f88d0004    ....    STRB     r0,[sp,#4]
;;;556        callback_data.conn_id = conn_id;
        0x0080fc7e:    f88d7005    ...p    STRB     r7,[sp,#5]
;;;557    
;;;558        switch (attrib_index)
        0x0080fc82:    1eb0        ..      SUBS     r0,r6,#2
        0x0080fc84:    2811        .(      CMP      r0,#0x11
        0x0080fc86:    d20a        ..      BCS      0x80fc9e ; dis_attr_read_cb + 62
        0x0080fc88:    e8dff000    ....    TBB      [pc,r0]
    $d
        0x0080fc8c:    09840923    #...    DCD    159648035
        0x0080fc90:    094d0931    1.M.    DCD    156043569
        0x0080fc94:    095b093f    ?.[.    DCD    156961087
        0x0080fc98:    09690916    ..i.    DCD    157878550
        0x0080fc9c:    0077        w.      DCW    119
    $t
;;;559        {
;;;560        default:
;;;561            PROFILE_PRINT_ERROR1("dis_attr_read_cb: attrib_index %d", attrib_index);
        0x0080fc9e:    bf00        ..      NOP      
        0x0080fca0:    bf00        ..      NOP      
        0x0080fca2:    4633        3F      MOV      r3,r6
        0x0080fca4:    2201        ."      MOVS     r2,#1
        0x0080fca6:    496e        nI      LDR      r1,[pc,#440] ; [0x80fe60] = 0x8800b34
        0x0080fca8:    486c        lH      LDR      r0,[pc,#432] ; [0x80fe5c] = 0x21103300
        0x0080fcaa:    f7f7ded8    ....    BL       log_buffer ; 0x7a5e
        0x0080fcae:    bf00        ..      NOP      
        0x0080fcb0:    bf00        ..      NOP      
;;;562            cause = APP_RESULT_ATTR_NOT_FOUND;
        0x0080fcb2:    f240490a    @..I    MOV      r9,#0x40a
;;;563            break;
        0x0080fcb6:    e07b        {.      B        0x80fdb0 ; dis_attr_read_cb + 336
;;;564    
;;;565    #if DIS_CHAR_SYSTEM_ID_SUPPORT
;;;566        case GATT_SVC_DIS_SYSTEM_ID_INDEX:
;;;567            callback_data.msg_data.read_value_index = DIS_READ_SYSTEM_ID_INDEX;
        0x0080fcb8:    2007        .       MOVS     r0,#7
        0x0080fcba:    f88d0006    ....    STRB     r0,[sp,#6]
;;;568            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080fcbe:    a901        ..      ADD      r1,sp,#4
        0x0080fcc0:    4640        @F      MOV      r0,r8
        0x0080fcc2:    4a68        hJ      LDR      r2,[pc,#416] ; [0x80fe64] = 0x207e58
        0x0080fcc4:    6812        .h      LDR      r2,[r2,#0]
        0x0080fcc6:    4790        .G      BLX      r2
;;;569            *pp_value    = (uint8_t *)&dis_system_id;
        0x0080fcc8:    485f        _H      LDR      r0,[pc,#380] ; [0x80fe48] = 0x207ddc
        0x0080fcca:    6028        (`      STR      r0,[r5,#0]
;;;570            *length_ptr = sizeof(dis_system_id);
        0x0080fccc:    2008        .       MOVS     r0,#8
        0x0080fcce:    8020         .      STRH     r0,[r4,#0]
;;;571            break;
        0x0080fcd0:    e06e        n.      B        0x80fdb0 ; dis_attr_read_cb + 336
;;;572    #endif
;;;573    
;;;574    #if DIS_CHAR_MANUFACTURER_NAME_SUPPORT
;;;575        case GATT_SVC_DIS_MANU_NAME_INDEX:
;;;576            callback_data.msg_data.read_value_index = DIS_READ_MANU_NAME_INDEX;
        0x0080fcd2:    2001        .       MOVS     r0,#1
        0x0080fcd4:    f88d0006    ....    STRB     r0,[sp,#6]
;;;577            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080fcd8:    a901        ..      ADD      r1,sp,#4
        0x0080fcda:    4640        @F      MOV      r0,r8
        0x0080fcdc:    4a61        aJ      LDR      r2,[pc,#388] ; [0x80fe64] = 0x207e58
        0x0080fcde:    6812        .h      LDR      r2,[r2,#0]
        0x0080fce0:    4790        .G      BLX      r2
;;;578            *pp_value    = (uint8_t *)&dis_manufacturer_name;
        0x0080fce2:    484e        NH      LDR      r0,[pc,#312] ; [0x80fe1c] = 0x207e5c
        0x0080fce4:    6028        (`      STR      r0,[r5,#0]
;;;579            *length_ptr = dis_manufacturer_name_len;
        0x0080fce6:    484c        LH      LDR      r0,[pc,#304] ; [0x80fe18] = 0x207e70
        0x0080fce8:    7800        .x      LDRB     r0,[r0,#0]
        0x0080fcea:    8020         .      STRH     r0,[r4,#0]
;;;580            break;
        0x0080fcec:    e060        `.      B        0x80fdb0 ; dis_attr_read_cb + 336
;;;581    #endif
;;;582    
;;;583    #if DIS_CHAR_SERIAL_NUMBER_SUPPORT
;;;584        case GATT_SVC_DIS_SERIAL_NUM_INDEX:
;;;585            callback_data.msg_data.read_value_index = DIS_READ_SERIAL_NUM_INDEX;
        0x0080fcee:    2003        .       MOVS     r0,#3
        0x0080fcf0:    f88d0006    ....    STRB     r0,[sp,#6]
;;;586            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080fcf4:    a901        ..      ADD      r1,sp,#4
        0x0080fcf6:    4640        @F      MOV      r0,r8
        0x0080fcf8:    4a5a        ZJ      LDR      r2,[pc,#360] ; [0x80fe64] = 0x207e58
        0x0080fcfa:    6812        .h      LDR      r2,[r2,#0]
        0x0080fcfc:    4790        .G      BLX      r2
;;;587            *pp_value    = (uint8_t *)&dis_serial_number;
        0x0080fcfe:    484b        KH      LDR      r0,[pc,#300] ; [0x80fe2c] = 0x207e86
        0x0080fd00:    6028        (`      STR      r0,[r5,#0]
;;;588            *length_ptr = dis_serial_number_len;
        0x0080fd02:    4849        IH      LDR      r0,[pc,#292] ; [0x80fe28] = 0x207e9a
        0x0080fd04:    7800        .x      LDRB     r0,[r0,#0]
        0x0080fd06:    8020         .      STRH     r0,[r4,#0]
;;;589            break;
        0x0080fd08:    e052        R.      B        0x80fdb0 ; dis_attr_read_cb + 336
;;;590    #endif
;;;591    
;;;592    #if DIS_CHAR_FIRMWARE_REVISION_SUPPORT
;;;593        case GATT_SVC_DIS_FIRMWARE_REV_INDEX:
;;;594            callback_data.msg_data.read_value_index = DIS_READ_FIRMWARE_REV_INDEX;
        0x0080fd0a:    2005        .       MOVS     r0,#5
        0x0080fd0c:    f88d0006    ....    STRB     r0,[sp,#6]
;;;595            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080fd10:    a901        ..      ADD      r1,sp,#4
        0x0080fd12:    4640        @F      MOV      r0,r8
        0x0080fd14:    4a53        SJ      LDR      r2,[pc,#332] ; [0x80fe64] = 0x207e58
        0x0080fd16:    6812        .h      LDR      r2,[r2,#0]
        0x0080fd18:    4790        .G      BLX      r2
;;;596            *pp_value    = (uint8_t *)&dis_firmware_rev;
        0x0080fd1a:    4848        HH      LDR      r0,[pc,#288] ; [0x80fe3c] = 0x207eb0
        0x0080fd1c:    6028        (`      STR      r0,[r5,#0]
;;;597            *length_ptr = dis_firmware_rev_len;
        0x0080fd1e:    4846        FH      LDR      r0,[pc,#280] ; [0x80fe38] = 0x207ec4
        0x0080fd20:    7800        .x      LDRB     r0,[r0,#0]
        0x0080fd22:    8020         .      STRH     r0,[r4,#0]
;;;598            break;
        0x0080fd24:    e044        D.      B        0x80fdb0 ; dis_attr_read_cb + 336
;;;599    #endif
;;;600    
;;;601    #if DIS_CHAR_HARDWARE_REVISION_SUPPORT
;;;602        case GATT_SVC_DIS_HARDWARE_REV_INDEX:
;;;603            callback_data.msg_data.read_value_index = DIS_READ_HARDWARE_REV_INDEX;
        0x0080fd26:    2004        .       MOVS     r0,#4
        0x0080fd28:    f88d0006    ....    STRB     r0,[sp,#6]
;;;604            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080fd2c:    a901        ..      ADD      r1,sp,#4
        0x0080fd2e:    4640        @F      MOV      r0,r8
        0x0080fd30:    4a4c        LJ      LDR      r2,[pc,#304] ; [0x80fe64] = 0x207e58
        0x0080fd32:    6812        .h      LDR      r2,[r2,#0]
        0x0080fd34:    4790        .G      BLX      r2
;;;605            *pp_value    = (uint8_t *)&dis_hardware_rev;
        0x0080fd36:    483f        ?H      LDR      r0,[pc,#252] ; [0x80fe34] = 0x207e9b
        0x0080fd38:    6028        (`      STR      r0,[r5,#0]
;;;606            *length_ptr = dis_hardware_rev_len;
        0x0080fd3a:    483d        =H      LDR      r0,[pc,#244] ; [0x80fe30] = 0x207eaf
        0x0080fd3c:    7800        .x      LDRB     r0,[r0,#0]
        0x0080fd3e:    8020         .      STRH     r0,[r4,#0]
;;;607            break;
        0x0080fd40:    e036        6.      B        0x80fdb0 ; dis_attr_read_cb + 336
;;;608    #endif
;;;609    
;;;610    #if DIS_CHAR_SOFTWARE_REVISION_SUPPORT
;;;611        case GATT_SVC_DIS_SOFTWARE_REV_INDEX:
;;;612            callback_data.msg_data.read_value_index = DIS_READ_SOFTWARE_REV_INDEX;
        0x0080fd42:    2006        .       MOVS     r0,#6
        0x0080fd44:    f88d0006    ....    STRB     r0,[sp,#6]
;;;613            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080fd48:    a901        ..      ADD      r1,sp,#4
        0x0080fd4a:    4640        @F      MOV      r0,r8
        0x0080fd4c:    4a45        EJ      LDR      r2,[pc,#276] ; [0x80fe64] = 0x207e58
        0x0080fd4e:    6812        .h      LDR      r2,[r2,#0]
        0x0080fd50:    4790        .G      BLX      r2
;;;614            *pp_value    = (uint8_t *)&dis_software_rev;
        0x0080fd52:    483c        <H      LDR      r0,[pc,#240] ; [0x80fe44] = 0x207ec5
        0x0080fd54:    6028        (`      STR      r0,[r5,#0]
;;;615            *length_ptr = dis_software_rev_len;
        0x0080fd56:    483a        :H      LDR      r0,[pc,#232] ; [0x80fe40] = 0x207ed9
        0x0080fd58:    7800        .x      LDRB     r0,[r0,#0]
        0x0080fd5a:    8020         .      STRH     r0,[r4,#0]
;;;616            break;
        0x0080fd5c:    e028        (.      B        0x80fdb0 ; dis_attr_read_cb + 336
;;;617    #endif
;;;618    
;;;619    #if DIS_CHAR_IEEE_CERTIF_DATA_LIST_SUPPORT
;;;620        case GATT_SVC_DIS_IEEE_CERT_STR_INDEX:
;;;621            callback_data.msg_data.read_value_index = DIS_READ_IEEE_CERT_STR_INDEX;
        0x0080fd5e:    2008        .       MOVS     r0,#8
        0x0080fd60:    f88d0006    ....    STRB     r0,[sp,#6]
;;;622            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080fd64:    a901        ..      ADD      r1,sp,#4
        0x0080fd66:    4640        @F      MOV      r0,r8
        0x0080fd68:    4a3e        >J      LDR      r2,[pc,#248] ; [0x80fe64] = 0x207e58
        0x0080fd6a:    6812        .h      LDR      r2,[r2,#0]
        0x0080fd6c:    4790        .G      BLX      r2
;;;623            *pp_value    = (uint8_t *)&dis_ieee_data_list;
        0x0080fd6e:    4838        8H      LDR      r0,[pc,#224] ; [0x80fe50] = 0x207deb
        0x0080fd70:    6028        (`      STR      r0,[r5,#0]
;;;624            *length_ptr = dis_ieee_data_list_len;
        0x0080fd72:    4836        6H      LDR      r0,[pc,#216] ; [0x80fe4c] = 0x207e09
        0x0080fd74:    7800        .x      LDRB     r0,[r0,#0]
        0x0080fd76:    8020         .      STRH     r0,[r4,#0]
;;;625            break;
        0x0080fd78:    e01a        ..      B        0x80fdb0 ; dis_attr_read_cb + 336
;;;626    #endif
;;;627    
;;;628    #if DIS_CHAR_PNP_ID_SUPPORT
;;;629        case GATT_SVC_DIS_PNP_ID_INDEX:
;;;630            callback_data.msg_data.read_value_index = DIS_READ_PNP_ID_INDEX;
        0x0080fd7a:    2009        .       MOVS     r0,#9
        0x0080fd7c:    f88d0006    ....    STRB     r0,[sp,#6]
;;;631            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080fd80:    a901        ..      ADD      r1,sp,#4
        0x0080fd82:    4640        @F      MOV      r0,r8
        0x0080fd84:    4a37        7J      LDR      r2,[pc,#220] ; [0x80fe64] = 0x207e58
        0x0080fd86:    6812        .h      LDR      r2,[r2,#0]
        0x0080fd88:    4790        .G      BLX      r2
;;;632            *pp_value    = (uint8_t *)&dis_pnp_id;
        0x0080fd8a:    4832        2H      LDR      r0,[pc,#200] ; [0x80fe54] = 0x207de4
        0x0080fd8c:    6028        (`      STR      r0,[r5,#0]
;;;633            *length_ptr = sizeof(dis_pnp_id);
        0x0080fd8e:    2007        .       MOVS     r0,#7
        0x0080fd90:    8020         .      STRH     r0,[r4,#0]
;;;634            break;
        0x0080fd92:    e00d        ..      B        0x80fdb0 ; dis_attr_read_cb + 336
;;;635    #endif
;;;636    
;;;637    #if DIS_CHAR_MODEL_NUMBER_SUPPORT
;;;638        case GATT_SVC_DIS_MODEL_NUM_INDEX:
;;;639            callback_data.msg_data.read_value_index = DIS_READ_MODEL_NUM_INDEX;
        0x0080fd94:    2002        .       MOVS     r0,#2
        0x0080fd96:    f88d0006    ....    STRB     r0,[sp,#6]
;;;640            pfn_dis_cb(service_id, (void *)&callback_data);
        0x0080fd9a:    a901        ..      ADD      r1,sp,#4
        0x0080fd9c:    4640        @F      MOV      r0,r8
        0x0080fd9e:    4a31        1J      LDR      r2,[pc,#196] ; [0x80fe64] = 0x207e58
        0x0080fda0:    6812        .h      LDR      r2,[r2,#0]
        0x0080fda2:    4790        .G      BLX      r2
;;;641            *pp_value    = (uint8_t *)&dis_model_number;
        0x0080fda4:    481f        .H      LDR      r0,[pc,#124] ; [0x80fe24] = 0x207e71
        0x0080fda6:    6028        (`      STR      r0,[r5,#0]
;;;642            *length_ptr = dis_model_number_len;
        0x0080fda8:    481d        .H      LDR      r0,[pc,#116] ; [0x80fe20] = 0x207e85
        0x0080fdaa:    7800        .x      LDRB     r0,[r0,#0]
        0x0080fdac:    8020         .      STRH     r0,[r4,#0]
;;;643            break;
        0x0080fdae:    bf00        ..      NOP      
        0x0080fdb0:    bf00        ..      NOP      
;;;644    #endif
;;;645    
;;;646        }
;;;647    
;;;648        PROFILE_PRINT_INFO2("dis_attr_read_cb: attrib_index %d, *length_ptr %d",
        0x0080fdb2:    bf00        ..      NOP      
        0x0080fdb4:    bf00        ..      NOP      
        0x0080fdb6:    8820         .      LDRH     r0,[r4,#0]
        0x0080fdb8:    4633        3F      MOV      r3,r6
        0x0080fdba:    2202        ."      MOVS     r2,#2
        0x0080fdbc:    492a        *I      LDR      r1,[pc,#168] ; [0x80fe68] = 0x8800b5c
        0x0080fdbe:    9000        ..      STR      r0,[sp,#0]
        0x0080fdc0:    4826        &H      LDR      r0,[pc,#152] ; [0x80fe5c] = 0x21103300
        0x0080fdc2:    1c80        ..      ADDS     r0,r0,#2
        0x0080fdc4:    f7f7de4b    ..K.    BL       log_buffer ; 0x7a5e
        0x0080fdc8:    bf00        ..      NOP      
        0x0080fdca:    bf00        ..      NOP      
;;;649                            attrib_index,
;;;650                            *length_ptr);
;;;651        return (cause);
        0x0080fdcc:    4648        HF      MOV      r0,r9
;;;652    }
        0x0080fdce:    e8bd87fc    ....    POP      {r2-r10,pc}
    dis_add_service
;;;653    
;;;654    const T_FUN_GATT_SERVICE_CBS dis_cbs =
;;;655    {
;;;656        dis_attr_read_cb,  // Read callback function pointer
;;;657        NULL, // Write callback function pointer
;;;658        NULL  // Authorization callback function pointer
;;;659    };
;;;660    
;;;661    /**
;;;662      * @brief Add device information service to the BLE stack database.
;;;663      *
;;;664      * @param[in]   p_func  Callback when service attribute was read, write or cccd update.
;;;665      * @return Service id generated by the BLE stack: @ref T_SERVER_ID.
;;;666      * @retval 0xFF Operation failure.
;;;667      * @retval others Service id assigned by stack.
;;;668      *
;;;669      * <b>Example usage</b>
;;;670      * \code{.c}
;;;671        void profile_init()
;;;672        {
;;;673            server_init(1);
;;;674            dis_id = dis_add_service(app_handle_profile_message);
;;;675        }
;;;676      * \endcode
;;;677      */
;;;678    T_SERVER_ID dis_add_service(void *p_func)
;;;679    {
        0x0080fdd2:    b53e        >.      PUSH     {r1-r5,lr}
        0x0080fdd4:    4604        .F      MOV      r4,r0
;;;680        T_SERVER_ID service_id;
;;;681        if (false == server_add_service(&service_id,
        0x0080fdd6:    4925        %I      LDR      r1,[pc,#148] ; [0x80fe6c] = 0x811980
        0x0080fdd8:    e9d10101    ....    LDRD     r0,r1,[r1,#4]
        0x0080fddc:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
        0x0080fde0:    4822        "H      LDR      r0,[pc,#136] ; [0x80fe6c] = 0x811980
        0x0080fde2:    f44f7205    O..r    MOV      r2,#0x214
        0x0080fde6:    4922        "I      LDR      r1,[pc,#136] ; [0x80fe70] = 0x811768
        0x0080fde8:    6803        .h      LDR      r3,[r0,#0]
        0x0080fdea:    a802        ..      ADD      r0,sp,#8
        0x0080fdec:    f43ff43f    ?.?.    BL       server_add_service ; 0x4f66e
        0x0080fdf0:    b960        `.      CBNZ     r0,0x80fe0c ; dis_add_service + 58
;;;682                                        (uint8_t *)dis_attr_tbl,
;;;683                                        dis_attr_tbl_size,
;;;684                                        dis_cbs))
;;;685        {
;;;686            PROFILE_PRINT_ERROR1("dis_add_service: service_id %d", service_id);
        0x0080fdf2:    bf00        ..      NOP      
        0x0080fdf4:    bf00        ..      NOP      
        0x0080fdf6:    f89d3008    ...0    LDRB     r3,[sp,#8]
        0x0080fdfa:    2201        ."      MOVS     r2,#1
        0x0080fdfc:    491d        .I      LDR      r1,[pc,#116] ; [0x80fe74] = 0x8800b94
        0x0080fdfe:    4817        .H      LDR      r0,[pc,#92] ; [0x80fe5c] = 0x21103300
        0x0080fe00:    f7f7de2d    ..-.    BL       log_buffer ; 0x7a5e
        0x0080fe04:    bf00        ..      NOP      
        0x0080fe06:    bf00        ..      NOP      
;;;687            service_id = 0xff;
        0x0080fe08:    20ff        .       MOVS     r0,#0xff
        0x0080fe0a:    9002        ..      STR      r0,[sp,#8]
;;;688        }
;;;689        pfn_dis_cb = (P_FUN_SERVER_GENERAL_CB)p_func;
        0x0080fe0c:    4815        .H      LDR      r0,[pc,#84] ; [0x80fe64] = 0x207e58
        0x0080fe0e:    6004        .`      STR      r4,[r0,#0]
;;;690        return service_id;
        0x0080fe10:    f89d0008    ....    LDRB     r0,[sp,#8]
;;;691    }
        0x0080fe14:    bd3e        >.      POP      {r1-r5,pc}
    $d
        0x0080fe16:    0000        ..      DCW    0
        0x0080fe18:    00207e70    p~ .    DCD    2129520
        0x0080fe1c:    00207e5c    \~ .    DCD    2129500
        0x0080fe20:    00207e85    .~ .    DCD    2129541
        0x0080fe24:    00207e71    q~ .    DCD    2129521
        0x0080fe28:    00207e9a    .~ .    DCD    2129562
        0x0080fe2c:    00207e86    .~ .    DCD    2129542
        0x0080fe30:    00207eaf    .~ .    DCD    2129583
        0x0080fe34:    00207e9b    .~ .    DCD    2129563
        0x0080fe38:    00207ec4    .~ .    DCD    2129604
        0x0080fe3c:    00207eb0    .~ .    DCD    2129584
        0x0080fe40:    00207ed9    .~ .    DCD    2129625
        0x0080fe44:    00207ec5    .~ .    DCD    2129605
        0x0080fe48:    00207ddc    .} .    DCD    2129372
        0x0080fe4c:    00207e09    .~ .    DCD    2129417
        0x0080fe50:    00207deb    .} .    DCD    2129387
        0x0080fe54:    00207de4    .} .    DCD    2129380
        0x0080fe58:    08800b18    ....    DCD    142609176
        0x0080fe5c:    21103300    .3.!    DCD    554709760
        0x0080fe60:    08800b34    4...    DCD    142609204
        0x0080fe64:    00207e58    X~ .    DCD    2129496
        0x0080fe68:    08800b5c    \...    DCD    142609244
        0x0080fe6c:    00811980    ....    DCD    8460672
        0x0080fe70:    00811768    h...    DCD    8460136
        0x0080fe74:    08800b94    ....    DCD    142609300
    $t
    .text
    ota_attr_write_cb
;;; .\..\..\..\src\ble\profile\server\ota_service.c
;;;363    {
        0x0080fe78:    e92d5fff    -.._    PUSH     {r0-r12,lr}
        0x0080fe7c:    4682        .F      MOV      r10,r0
        0x0080fe7e:    460f        .F      MOV      r7,r1
        0x0080fe80:    4615        .F      MOV      r5,r2
        0x0080fe82:    469b        .F      MOV      r11,r3
        0x0080fe84:    e9dd490f    ...I    LDRD     r4,r9,[sp,#0x3c]
        0x0080fe88:    9e0e        ..      LDR      r6,[sp,#0x38]
;;;364        T_OTA_CALLBACK_DATA callback_data;
;;;365        T_APP_RESULT  wCause = APP_RESULT_SUCCESS;
        0x0080fe8a:    f04f0800    O...    MOV      r8,#0
;;;366    
;;;367        if (BLE_SERVICE_CHAR_OTA_INDEX == attrib_index)
        0x0080fe8e:    2d02        .-      CMP      r5,#2
        0x0080fe90:    d118        ..      BNE      0x80fec4 ; ota_attr_write_cb + 76
;;;368        {
;;;369            /* Make sure written value size is valid. */
;;;370            if ((length != sizeof(uint8_t)) || (p_value == NULL))
        0x0080fe92:    2e01        ..      CMP      r6,#1
        0x0080fe94:    d100        ..      BNE      0x80fe98 ; ota_attr_write_cb + 32
        0x0080fe96:    b914        ..      CBNZ     r4,0x80fe9e ; ota_attr_write_cb + 38
;;;371            {
;;;372                wCause  = APP_RESULT_INVALID_VALUE_SIZE;
        0x0080fe98:    f240480d    @..H    MOV      r8,#0x40d
        0x0080fe9c:    e05f        _.      B        0x80ff5e ; ota_attr_write_cb + 230
;;;373            }
;;;374            else
;;;375            {
;;;376                /* Notify Application. */
;;;377                callback_data.msg_type = SERVICE_CALLBACK_TYPE_WRITE_CHAR_VALUE;
        0x0080fe9e:    2003        .       MOVS     r0,#3
        0x0080fea0:    f88d0004    ....    STRB     r0,[sp,#4]
;;;378                callback_data.msg_data.write.opcode = OTA_WRITE_CHAR_VAL;
        0x0080fea4:    2001        .       MOVS     r0,#1
        0x0080fea6:    f88d0006    ....    STRB     r0,[sp,#6]
;;;379                callback_data.msg_data.write.u.value = p_value[0];
        0x0080feaa:    7821        !x      LDRB     r1,[r4,#0]
        0x0080feac:    f88d1008    ....    STRB     r1,[sp,#8]
;;;380    
;;;381                if (pfnOTAExtendedCB)
        0x0080feb0:    48f7        .H      LDR      r0,[pc,#988] ; [0x810290] = 0x207edc
        0x0080feb2:    6800        .h      LDR      r0,[r0,#0]
        0x0080feb4:    2800        .(      CMP      r0,#0
        0x0080feb6:    d052        R.      BEQ      0x80ff5e ; ota_attr_write_cb + 230
;;;382                {
;;;383                    pfnOTAExtendedCB(service_id, (void *)&callback_data);
        0x0080feb8:    a901        ..      ADD      r1,sp,#4
        0x0080feba:    4638        8F      MOV      r0,r7
        0x0080febc:    4af4        .J      LDR      r2,[pc,#976] ; [0x810290] = 0x207edc
        0x0080febe:    6812        .h      LDR      r2,[r2,#0]
        0x0080fec0:    4790        .G      BLX      r2
        0x0080fec2:    e04c        L.      B        0x80ff5e ; ota_attr_write_cb + 230
;;;384                }
;;;385            }
;;;386        }
;;;387        else if (BLE_SERVICE_CHAR_IMAGE_COUNT_INDEX == attrib_index)
        0x0080fec4:    2d10        .-      CMP      r5,#0x10
        0x0080fec6:    d123        #.      BNE      0x80ff10 ; ota_attr_write_cb + 152
;;;388        {
;;;389            /* Make sure written value size is valid. */
;;;390            if ((length != OTA_UPDATE_IMAGE_INFO_LEN) || (p_value == NULL))
        0x0080fec8:    2e05        ..      CMP      r6,#5
        0x0080feca:    d100        ..      BNE      0x80fece ; ota_attr_write_cb + 86
        0x0080fecc:    b914        ..      CBNZ     r4,0x80fed4 ; ota_attr_write_cb + 92
;;;391            {
;;;392                wCause  = APP_RESULT_INVALID_VALUE_SIZE;
        0x0080fece:    f240480d    @..H    MOV      r8,#0x40d
        0x0080fed2:    e044        D.      B        0x80ff5e ; ota_attr_write_cb + 230
;;;393            }
;;;394            else
;;;395            {
;;;396                /* Notify Application. */
;;;397                callback_data.msg_type = SERVICE_CALLBACK_TYPE_WRITE_CHAR_VALUE;
        0x0080fed4:    2003        .       MOVS     r0,#3
        0x0080fed6:    f88d0004    ....    STRB     r0,[sp,#4]
;;;398                callback_data.msg_data.write.opcode = OTA_WRITE_IMAGE_COUNT_VAL;
        0x0080feda:    2002        .       MOVS     r0,#2
        0x0080fedc:    f88d0006    ....    STRB     r0,[sp,#6]
;;;399                callback_data.msg_data.write.u.update_image_info.image_count = p_value[0];
        0x0080fee0:    7821        !x      LDRB     r1,[r4,#0]
        0x0080fee2:    f88d1008    ....    STRB     r1,[sp,#8]
;;;400                callback_data.msg_data.write.u.update_image_info.update_patch_version = CHAR2SHORT(&p_value[1]);
        0x0080fee6:    78a1        .x      LDRB     r1,[r4,#2]
        0x0080fee8:    7860        `x      LDRB     r0,[r4,#1]
        0x0080feea:    f361201f    a..     BFI      r0,r1,#8,#24
        0x0080feee:    f8ad000a    ....    STRH     r0,[sp,#0xa]
;;;401                callback_data.msg_data.write.u.update_image_info.update_app_version = CHAR2SHORT(&p_value[3]);
        0x0080fef2:    7921        !y      LDRB     r1,[r4,#4]
        0x0080fef4:    78e0        .x      LDRB     r0,[r4,#3]
        0x0080fef6:    f361201f    a..     BFI      r0,r1,#8,#24
        0x0080fefa:    f8ad000c    ....    STRH     r0,[sp,#0xc]
;;;402    
;;;403                if (pfnOTAExtendedCB)
        0x0080fefe:    48e4        .H      LDR      r0,[pc,#912] ; [0x810290] = 0x207edc
        0x0080ff00:    6800        .h      LDR      r0,[r0,#0]
        0x0080ff02:    b360        `.      CBZ      r0,0x80ff5e ; ota_attr_write_cb + 230
;;;404                {
;;;405                    pfnOTAExtendedCB(service_id, (void *)&callback_data);
        0x0080ff04:    a901        ..      ADD      r1,sp,#4
        0x0080ff06:    4638        8F      MOV      r0,r7
        0x0080ff08:    4ae1        .J      LDR      r2,[pc,#900] ; [0x810290] = 0x207edc
        0x0080ff0a:    6812        .h      LDR      r2,[r2,#0]
        0x0080ff0c:    4790        .G      BLX      r2
        0x0080ff0e:    e026        &.      B        0x80ff5e ; ota_attr_write_cb + 230
;;;406                }
;;;407            }
;;;408        }
;;;409        else if (BLE_SERVICE_CHAR_TEST_MODE_INDEX == attrib_index)
        0x0080ff10:    2d0c        .-      CMP      r5,#0xc
        0x0080ff12:    d117        ..      BNE      0x80ff44 ; ota_attr_write_cb + 204
;;;410        {
;;;411            /* Make sure written value size is valid. */
;;;412            if ((length != sizeof(uint8_t)) || (p_value == NULL))
        0x0080ff14:    2e01        ..      CMP      r6,#1
        0x0080ff16:    d100        ..      BNE      0x80ff1a ; ota_attr_write_cb + 162
        0x0080ff18:    b914        ..      CBNZ     r4,0x80ff20 ; ota_attr_write_cb + 168
;;;413            {
;;;414                wCause  = APP_RESULT_INVALID_VALUE_SIZE;
        0x0080ff1a:    f240480d    @..H    MOV      r8,#0x40d
        0x0080ff1e:    e01e        ..      B        0x80ff5e ; ota_attr_write_cb + 230
;;;415            }
;;;416            else
;;;417            {
;;;418                /* Notify Application. */
;;;419                callback_data.msg_type = SERVICE_CALLBACK_TYPE_WRITE_CHAR_VALUE;
        0x0080ff20:    2003        .       MOVS     r0,#3
        0x0080ff22:    f88d0004    ....    STRB     r0,[sp,#4]
;;;420                callback_data.msg_data.write.opcode = OTA_WRITE_TEST_MODE_CHAR_VAL;
        0x0080ff26:    2002        .       MOVS     r0,#2
        0x0080ff28:    f88d0006    ....    STRB     r0,[sp,#6]
;;;421                callback_data.msg_data.write.u.value = p_value[0];
        0x0080ff2c:    7821        !x      LDRB     r1,[r4,#0]
        0x0080ff2e:    f88d1008    ....    STRB     r1,[sp,#8]
;;;422    
;;;423                if (pfnOTAExtendedCB)
        0x0080ff32:    48d7        .H      LDR      r0,[pc,#860] ; [0x810290] = 0x207edc
        0x0080ff34:    6800        .h      LDR      r0,[r0,#0]
        0x0080ff36:    b190        ..      CBZ      r0,0x80ff5e ; ota_attr_write_cb + 230
;;;424                {
;;;425                    pfnOTAExtendedCB(service_id, (void *)&callback_data);
        0x0080ff38:    a901        ..      ADD      r1,sp,#4
        0x0080ff3a:    4638        8F      MOV      r0,r7
        0x0080ff3c:    4ad4        .J      LDR      r2,[pc,#848] ; [0x810290] = 0x207edc
        0x0080ff3e:    6812        .h      LDR      r2,[r2,#0]
        0x0080ff40:    4790        .G      BLX      r2
        0x0080ff42:    e00c        ..      B        0x80ff5e ; ota_attr_write_cb + 230
;;;426                }
;;;427            }
;;;428        }
;;;429        else
;;;430        {
;;;431            PROFILE_PRINT_INFO2("--> OTA_AttrWrite Error  iAttribIndex = 0x%x wLength=%d",
        0x0080ff44:    bf00        ..      NOP      
        0x0080ff46:    bf00        ..      NOP      
        0x0080ff48:    462b        +F      MOV      r3,r5
        0x0080ff4a:    2202        ."      MOVS     r2,#2
        0x0080ff4c:    49d1        .I      LDR      r1,[pc,#836] ; [0x810294] = 0x8800bb8
        0x0080ff4e:    48d2        .H      LDR      r0,[pc,#840] ; [0x810298] = 0x21103302
        0x0080ff50:    9600        ..      STR      r6,[sp,#0]
        0x0080ff52:    f7f7dd84    ....    BL       log_buffer ; 0x7a5e
        0x0080ff56:    bf00        ..      NOP      
        0x0080ff58:    bf00        ..      NOP      
;;;432                                attrib_index,
;;;433                                length);
;;;434            wCause = APP_RESULT_ATTR_NOT_FOUND;
        0x0080ff5a:    f240480a    @..H    MOV      r8,#0x40a
;;;435        }
;;;436        return wCause;
        0x0080ff5e:    4640        @F      MOV      r0,r8
;;;437    
;;;438    }
        0x0080ff60:    b004        ..      ADD      sp,sp,#0x10
        0x0080ff62:    e8bd9ff0    ....    POP      {r4-r12,pc}
    ota_attr_read_cb
;;;439    
;;;440    
;;;441    /**
;;;442     * @brief read characteristic data from service.
;;;443     *
;;;444     * @param ServiceId          ServiceID of characteristic data.
;;;445     * @param iAttribIndex       Attribute index of getting characteristic data.
;;;446     * @param iOffset            Used for Blob Read.
;;;447     * @param piLength           length of getting characteristic data.
;;;448     * @param ppValue            data got from service.
;;;449     * @return Profile procedure result
;;;450    */
;;;451    T_APP_RESULT ota_attr_read_cb(uint8_t conn_id, T_SERVER_ID service_id, uint16_t attrib_index,
;;;452                                  uint16_t offset, uint16_t *p_length, uint8_t **pp_value)
;;;453    {
        0x0080ff66:    e92d4ff0    -..O    PUSH     {r4-r11,lr}
        0x0080ff6a:    b087        ..      SUB      sp,sp,#0x1c
        0x0080ff6c:    4689        .F      MOV      r9,r1
        0x0080ff6e:    4690        .F      MOV      r8,r2
        0x0080ff70:    e9dd6710    ...g    LDRD     r6,r7,[sp,#0x40]
;;;454        T_APP_RESULT  wCause = APP_RESULT_SUCCESS;
        0x0080ff74:    f04f0a00    O...    MOV      r10,#0
;;;455        T_OTA_CALLBACK_DATA callback_data;
;;;456        bool defer_handle = false;
        0x0080ff78:    2000        .       MOVS     r0,#0
        0x0080ff7a:    9003        ..      STR      r0,[sp,#0xc]
;;;457    
;;;458        switch (attrib_index)
        0x0080ff7c:    f1b80f0a    ....    CMP      r8,#0xa
        0x0080ff80:    d07d        }.      BEQ      0x81007e ; ota_attr_read_cb + 280
        0x0080ff82:    dc09        ..      BGT      0x80ff98 ; ota_attr_read_cb + 50
        0x0080ff84:    f1b80f04    ....    CMP      r8,#4
        0x0080ff88:    d019        ..      BEQ      0x80ffbe ; ota_attr_read_cb + 88
        0x0080ff8a:    f1b80f06    ....    CMP      r8,#6
        0x0080ff8e:    d030        0.      BEQ      0x80fff2 ; ota_attr_read_cb + 140
        0x0080ff90:    f1b80f08    ....    CMP      r8,#8
        0x0080ff94:    d106        ..      BNE      0x80ffa4 ; ota_attr_read_cb + 62
        0x0080ff96:    e04f        O.      B        0x810038 ; ota_attr_read_cb + 210
        0x0080ff98:    f1b80f0e    ....    CMP      r8,#0xe
        0x0080ff9c:    d073        s.      BEQ      0x810086 ; ota_attr_read_cb + 288
        0x0080ff9e:    f1b80f12    ....    CMP      r8,#0x12
        0x0080ffa2:    d06e        n.      BEQ      0x810082 ; ota_attr_read_cb + 284
;;;459        {
;;;460        default:
;;;461            PROFILE_PRINT_INFO1("<-- OTA_AttrRead, Attr not found, index=%d", attrib_index);
        0x0080ffa4:    bf00        ..      NOP      
        0x0080ffa6:    bf00        ..      NOP      
        0x0080ffa8:    4643        CF      MOV      r3,r8
        0x0080ffaa:    2201        ."      MOVS     r2,#1
        0x0080ffac:    49bb        .I      LDR      r1,[pc,#748] ; [0x81029c] = 0x8800bf4
        0x0080ffae:    48ba        .H      LDR      r0,[pc,#744] ; [0x810298] = 0x21103302
        0x0080ffb0:    f7f7dd55    ..U.    BL       log_buffer ; 0x7a5e
        0x0080ffb4:    bf00        ..      NOP      
        0x0080ffb6:    bf00        ..      NOP      
;;;462            wCause  = APP_RESULT_ATTR_NOT_FOUND;
        0x0080ffb8:    f2404a0a    @..J    MOV      r10,#0x40a
;;;463            break;
        0x0080ffbc:    e137        7.      B        0x81022e ; ota_attr_read_cb + 712
;;;464        case BLE_SERVICE_CHAR_MAC_ADDRESS_INDEX:
;;;465            {
;;;466                gap_get_param(GAP_PARAM_BD_ADDR, mac_addr);
        0x0080ffbe:    49b8        .I      LDR      r1,[pc,#736] ; [0x8102a0] = 0x207ee0
        0x0080ffc0:    f44f7000    O..p    MOV      r0,#0x200
        0x0080ffc4:    f43cf037    <.7.    BL       gap_get_param ; 0x4c036
;;;467                uint8_t addr[6];
;;;468                for (int i = 0; i < 6; i++)
        0x0080ffc8:    2000        .       MOVS     r0,#0
        0x0080ffca:    e006        ..      B        0x80ffda ; ota_attr_read_cb + 116
        0x0080ffcc:    f1c00105    ....    RSB      r1,r0,#5
        0x0080ffd0:    4ab3        .J      LDR      r2,[pc,#716] ; [0x8102a0] = 0x207ee0
        0x0080ffd2:    5c51        Q\      LDRB     r1,[r2,r1]
        0x0080ffd4:    aa01        ..      ADD      r2,sp,#4
        0x0080ffd6:    5411        .T      STRB     r1,[r2,r0]
        0x0080ffd8:    1c40        @.      ADDS     r0,r0,#1
        0x0080ffda:    2806        .(      CMP      r0,#6
        0x0080ffdc:    dbf6        ..      BLT      0x80ffcc ; ota_attr_read_cb + 102
;;;469                {
;;;470                    addr[i] = mac_addr[5 - i];
;;;471                }
;;;472                memcpy(mac_addr, addr, 6);
        0x0080ffde:    48b0        .H      LDR      r0,[pc,#704] ; [0x8102a0] = 0x207ee0
        0x0080ffe0:    9901        ..      LDR      r1,[sp,#4]
        0x0080ffe2:    6001        .`      STR      r1,[r0,#0]
        0x0080ffe4:    f8bd1008    ....    LDRH     r1,[sp,#8]
        0x0080ffe8:    8081        ..      STRH     r1,[r0,#4]
;;;473                *pp_value  = (uint8_t *)mac_addr;
        0x0080ffea:    6038        8`      STR      r0,[r7,#0]
;;;474                *p_length = sizeof(mac_addr);
        0x0080ffec:    2006        .       MOVS     r0,#6
        0x0080ffee:    8030        0.      STRH     r0,[r6,#0]
;;;475            }
;;;476            break;
        0x0080fff0:    e11d        ..      B        0x81022e ; ota_attr_read_cb + 712
;;;477        case BLE_SERVICE_CHAR_PATCH_INDEX:
;;;478            {
;;;479                T_IMG_HEADER_FORMAT *p_header;
;;;480                uint32_t addr = get_header_addr_by_img_id(RomPatch);
        0x0080fff2:    f2427092    B..p    MOV      r0,#0x2792
        0x0080fff6:    f7fcdbf5    ....    BL       get_header_addr_by_img_id ; 0xc7e4
        0x0080fffa:    4604        .F      MOV      r4,r0
;;;481                PROFILE_PRINT_INFO1("patch_addr = %x", addr);
        0x0080fffc:    bf00        ..      NOP      
        0x0080fffe:    bf00        ..      NOP      
        0x00810000:    4623        #F      MOV      r3,r4
        0x00810002:    2201        ."      MOVS     r2,#1
        0x00810004:    49a7        .I      LDR      r1,[pc,#668] ; [0x8102a4] = 0x8800c24
        0x00810006:    48a4        .H      LDR      r0,[pc,#656] ; [0x810298] = 0x21103302
        0x00810008:    f7f7dd29    ..).    BL       log_buffer ; 0x7a5e
        0x0081000c:    bf00        ..      NOP      
        0x0081000e:    bf00        ..      NOP      
;;;482                p_header = (T_IMG_HEADER_FORMAT *)addr;
        0x00810010:    4625        %F      MOV      r5,r4
;;;483    
;;;484                patch_version = p_header->git_ver.ver_info.version;
        0x00810012:    49a5        .I      LDR      r1,[pc,#660] ; [0x8102a8] = 0x207ee8
        0x00810014:    6e28        (n      LDR      r0,[r5,#0x60]
        0x00810016:    6008        .`      STR      r0,[r1,#0]
;;;485    
;;;486                PROFILE_PRINT_INFO1("patch_version = %x", patch_version);
        0x00810018:    bf00        ..      NOP      
        0x0081001a:    bf00        ..      NOP      
        0x0081001c:    4608        .F      MOV      r0,r1
        0x0081001e:    2201        ."      MOVS     r2,#1
        0x00810020:    49a2        .I      LDR      r1,[pc,#648] ; [0x8102ac] = 0x8800c38
        0x00810022:    6803        .h      LDR      r3,[r0,#0]
        0x00810024:    489c        .H      LDR      r0,[pc,#624] ; [0x810298] = 0x21103302
        0x00810026:    f7f7dd1a    ....    BL       log_buffer ; 0x7a5e
        0x0081002a:    bf00        ..      NOP      
        0x0081002c:    bf00        ..      NOP      
;;;487                *pp_value  = (uint8_t *)&patch_version;
        0x0081002e:    489e        .H      LDR      r0,[pc,#632] ; [0x8102a8] = 0x207ee8
        0x00810030:    6038        8`      STR      r0,[r7,#0]
;;;488                *p_length = sizeof(patch_version);
        0x00810032:    2004        .       MOVS     r0,#4
        0x00810034:    8030        0.      STRH     r0,[r6,#0]
;;;489            }
;;;490            break;
        0x00810036:    e0fa        ..      B        0x81022e ; ota_attr_read_cb + 712
;;;491    
;;;492        case BLE_SERVICE_CHAR_APP_VERSION_INDEX:
;;;493            {
;;;494                T_IMG_HEADER_FORMAT *p_header;
;;;495                uint32_t addr = get_header_addr_by_img_id(AppPatch);
        0x00810038:    f2427093    B..p    MOV      r0,#0x2793
        0x0081003c:    f7fcdbd2    ....    BL       get_header_addr_by_img_id ; 0xc7e4
        0x00810040:    4604        .F      MOV      r4,r0
;;;496                PROFILE_PRINT_INFO1("app_addr = %x", addr);
        0x00810042:    bf00        ..      NOP      
        0x00810044:    bf00        ..      NOP      
        0x00810046:    4623        #F      MOV      r3,r4
        0x00810048:    2201        ."      MOVS     r2,#1
        0x0081004a:    4999        .I      LDR      r1,[pc,#612] ; [0x8102b0] = 0x8800c50
        0x0081004c:    4892        .H      LDR      r0,[pc,#584] ; [0x810298] = 0x21103302
        0x0081004e:    f7f7dd06    ....    BL       log_buffer ; 0x7a5e
        0x00810052:    bf00        ..      NOP      
        0x00810054:    bf00        ..      NOP      
;;;497                p_header = (T_IMG_HEADER_FORMAT *)addr;
        0x00810056:    4625        %F      MOV      r5,r4
;;;498    
;;;499                app_version = p_header->git_ver.ver_info.version;
        0x00810058:    4996        .I      LDR      r1,[pc,#600] ; [0x8102b4] = 0x207ef0
        0x0081005a:    6e28        (n      LDR      r0,[r5,#0x60]
        0x0081005c:    6008        .`      STR      r0,[r1,#0]
;;;500    
;;;501                PROFILE_PRINT_INFO1("app_version = %x", app_version);
        0x0081005e:    bf00        ..      NOP      
        0x00810060:    bf00        ..      NOP      
        0x00810062:    4608        .F      MOV      r0,r1
        0x00810064:    2201        ."      MOVS     r2,#1
        0x00810066:    4994        .I      LDR      r1,[pc,#592] ; [0x8102b8] = 0x8800c64
        0x00810068:    6803        .h      LDR      r3,[r0,#0]
        0x0081006a:    488b        .H      LDR      r0,[pc,#556] ; [0x810298] = 0x21103302
        0x0081006c:    f7f7dcf7    ....    BL       log_buffer ; 0x7a5e
        0x00810070:    bf00        ..      NOP      
        0x00810072:    bf00        ..      NOP      
;;;502                *pp_value  = (uint8_t *)&app_version;
        0x00810074:    488f        .H      LDR      r0,[pc,#572] ; [0x8102b4] = 0x207ef0
        0x00810076:    6038        8`      STR      r0,[r7,#0]
;;;503                *p_length = sizeof(app_version);
        0x00810078:    2004        .       MOVS     r0,#4
        0x0081007a:    8030        0.      STRH     r0,[r6,#0]
;;;504            }
;;;505            break;
        0x0081007c:    e0d7        ..      B        0x81022e ; ota_attr_read_cb + 712
        0x0081007e:    e001        ..      B        0x810084 ; ota_attr_read_cb + 286
        0x00810080:    e001        ..      B        0x810086 ; ota_attr_read_cb + 288
        0x00810082:    e051        Q.      B        0x810128 ; ota_attr_read_cb + 450
;;;506    
;;;507        case BLE_SERVICE_CHAR_PATCH_EXTENSION_INDEX:        //not used in bee2
;;;508            {
;;;509    
;;;510            }
;;;511            break;
        0x00810084:    e0d3        ..      B        0x81022e ; ota_attr_read_cb + 712
;;;512        case BLE_SERVICE_CHAR_DEVICE_INFO_INDEX:
;;;513            {
;;;514                static T_DFU_DEVICE_INFO DeviceInfo;
;;;515                T_IMG_HEADER_FORMAT *p_header;
;;;516                uint32_t addr = get_header_addr_by_img_id(OTA);
        0x00810086:    f2427090    B..p    MOV      r0,#0x2790
        0x0081008a:    f7fcdbab    ....    BL       get_header_addr_by_img_id ; 0xc7e4
        0x0081008e:    4604        .F      MOV      r4,r0
;;;517                p_header = (T_IMG_HEADER_FORMAT *)addr;
        0x00810090:    4625        %F      MOV      r5,r4
;;;518                DeviceInfo.secure_version = p_header->ctrl_header.secure_version;
        0x00810092:    7868        hx      LDRB     r0,[r5,#1]
        0x00810094:    4989        .I      LDR      r1,[pc,#548] ; [0x8102bc] = 0x207ef4
        0x00810096:    7088        .p      STRB     r0,[r1,#2]
;;;519    
;;;520    #ifdef SDK_8772
;;;521                DeviceInfo.ictype = 9;
;;;522    #else
;;;523                DeviceInfo.ictype = 5;
        0x00810098:    2005        .       MOVS     r0,#5
        0x0081009a:    7008        .p      STRB     r0,[r1,#0]
;;;524    #endif
;;;525    
;;;526                DeviceInfo.ota_version = 0x1;
        0x0081009c:    2001        .       MOVS     r0,#1
        0x0081009e:    7048        Hp      STRB     r0,[r1,#1]
;;;527                DeviceInfo.secure_version = p_header->ctrl_header.secure_version;
        0x008100a0:    7868        hx      LDRB     r0,[r5,#1]
        0x008100a2:    7088        .p      STRB     r0,[r1,#2]
;;;528                DeviceInfo.mode.buffercheck = DFU_BUFFER_CHECK_ENABLE;
        0x008100a4:    4886        .H      LDR      r0,[pc,#536] ; [0x8102c0] = 0x207e3c
        0x008100a6:    7800        .x      LDRB     r0,[r0,#0]
        0x008100a8:    78c9        .x      LDRB     r1,[r1,#3]
        0x008100aa:    f3600100    `...    BFI      r1,r0,#0,#1
        0x008100ae:    4883        .H      LDR      r0,[pc,#524] ; [0x8102bc] = 0x207ef4
        0x008100b0:    70c1        .p      STRB     r1,[r0,#3]
;;;529                DeviceInfo.mode.aesflg = OTP->ota_with_encryption_data;
        0x008100b2:    4884        .H      LDR      r0,[pc,#528] ; [0x8102c4] = 0x200314
        0x008100b4:    7800        .x      LDRB     r0,[r0,#0]
        0x008100b6:    0940        @.      LSRS     r0,r0,#5
        0x008100b8:    4980        .I      LDR      r1,[pc,#512] ; [0x8102bc] = 0x207ef4
        0x008100ba:    78c9        .x      LDRB     r1,[r1,#3]
        0x008100bc:    f3600141    `.A.    BFI      r1,r0,#1,#1
        0x008100c0:    487e        ~H      LDR      r0,[pc,#504] ; [0x8102bc] = 0x207ef4
        0x008100c2:    70c1        .p      STRB     r1,[r0,#3]
;;;530                DeviceInfo.mode.aesmode = 1;
        0x008100c4:    78c0        .x      LDRB     r0,[r0,#3]
        0x008100c6:    f0200004     ...    BIC      r0,r0,#4
        0x008100ca:    1d00        ..      ADDS     r0,r0,#4
        0x008100cc:    497b        {I      LDR      r1,[pc,#492] ; [0x8102bc] = 0x207ef4
        0x008100ce:    70c8        .p      STRB     r0,[r1,#3]
;;;531                // DeviceInfo.mode.verify_algo = 0;//crc    need to delete this feature;
;;;532                DeviceInfo.mode.copy_img = 0;
        0x008100d0:    4608        .F      MOV      r0,r1
        0x008100d2:    78c0        .x      LDRB     r0,[r0,#3]
        0x008100d4:    f0200008     ...    BIC      r0,r0,#8
        0x008100d8:    70c8        .p      STRB     r0,[r1,#3]
;;;533                DeviceInfo.mode.multi_img = is_ota_support_bank_switch() & 0x01;
        0x008100da:    f7fcdbb2    ....    BL       is_ota_support_bank_switch ; 0xc842
        0x008100de:    4977        wI      LDR      r1,[pc,#476] ; [0x8102bc] = 0x207ef4
        0x008100e0:    78c9        .x      LDRB     r1,[r1,#3]
        0x008100e2:    f3601104    `...    BFI      r1,r0,#4,#1
        0x008100e6:    4875        uH      LDR      r0,[pc,#468] ; [0x8102bc] = 0x207ef4
        0x008100e8:    70c1        .p      STRB     r1,[r0,#3]
;;;534                DeviceInfo.maxbuffersize = DFU_TEMP_BUFFER_SIZE;
        0x008100ea:    f44f6000    O..`    MOV      r0,#0x800
        0x008100ee:    4973        sI      LDR      r1,[pc,#460] ; [0x8102bc] = 0x207ef4
        0x008100f0:    8088        ..      STRH     r0,[r1,#4]
;;;535    
;;;536                /* prepare img_indicator, if modify here need to sync with vaule
;;;537                    of BLE_SERVICE_CHAR_IMAGE_VERSION_INDEX */
;;;538                if (is_ota_support_bank_switch())
        0x008100f2:    f7fcdba6    ....    BL       is_ota_support_bank_switch ; 0xc842
        0x008100f6:    b170        p.      CBZ      r0,0x810116 ; ota_attr_read_cb + 432
;;;539                {
;;;540                    if ((addr & 0xffffff) == OTA_BANK0_ADDR)
        0x008100f8:    f024407f    $..@    BIC      r0,r4,#0xff000000
        0x008100fc:    4972        rI      LDR      r1,[pc,#456] ; [0x8102c8] = 0x802000
        0x008100fe:    4288        .B      CMP      r0,r1
        0x00810100:    d104        ..      BNE      0x81010c ; ota_attr_read_cb + 422
;;;541                    {
;;;542                        DeviceInfo.img_indicator = ((IMAGE_LOCATION_BANK0 << (OTA_HEADER * 2))
        0x00810102:    f44f60a2    O..`    MOV      r0,#0x510
        0x00810106:    496d        mI      LDR      r1,[pc,#436] ; [0x8102bc] = 0x207ef4
        0x00810108:    6088        .`      STR      r0,[r1,#8]
        0x0081010a:    e008        ..      B        0x81011e ; ota_attr_read_cb + 440
;;;543                                                    /*| (IMAGE_LOCATION_BANK0 << (SECURE_BOOT * 2))*/
;;;544                                                    | (IMAGE_LOCATION_BANK0 << (ROM_PATCH * 2))
;;;545                                                    | (IMAGE_LOCATION_BANK0 << (APP_IMG * 2))
;;;546                                                   );
;;;547                    }
;;;548                    else
;;;549                    {
;;;550                        DeviceInfo.img_indicator = ((IMAGE_LOCATION_BANK1 << (OTA_HEADER * 2))
        0x0081010c:    f44f6022    O."`    MOV      r0,#0xa20
        0x00810110:    496a        jI      LDR      r1,[pc,#424] ; [0x8102bc] = 0x207ef4
        0x00810112:    6088        .`      STR      r0,[r1,#8]
        0x00810114:    e003        ..      B        0x81011e ; ota_attr_read_cb + 440
;;;551                                                    /*| (IMAGE_LOCATION_BANK1 << (SECURE_BOOT * 2))*/
;;;552                                                    | (IMAGE_LOCATION_BANK1 << (ROM_PATCH * 2))
;;;553                                                    | (IMAGE_LOCATION_BANK1 << (APP_IMG * 2))
;;;554                                                   );
;;;555                    }
;;;556                }
;;;557                else
;;;558                {
;;;559                    DeviceInfo.img_indicator = ((IMAGE_FIX_BANK_EXIST << (OTA_HEADER * 2))
        0x00810116:    f44f607f    O..`    MOV      r0,#0xff0
        0x0081011a:    4968        hI      LDR      r1,[pc,#416] ; [0x8102bc] = 0x207ef4
        0x0081011c:    6088        .`      STR      r0,[r1,#8]
;;;560                                                | (IMAGE_FIX_BANK_EXIST << (SECURE_BOOT * 2))
;;;561                                                | (IMAGE_FIX_BANK_EXIST << (ROM_PATCH * 2))
;;;562                                                | (IMAGE_FIX_BANK_EXIST << (APP_IMG * 2))
;;;563                                               );
;;;564                }
;;;565                *pp_value  = (uint8_t *)&DeviceInfo;
        0x0081011e:    4867        gH      LDR      r0,[pc,#412] ; [0x8102bc] = 0x207ef4
        0x00810120:    6038        8`      STR      r0,[r7,#0]
;;;566                *p_length = sizeof(T_DFU_DEVICE_INFO);
        0x00810122:    200c        .       MOVS     r0,#0xc
        0x00810124:    8030        0.      STRH     r0,[r6,#0]
;;;567            }
;;;568            break;
        0x00810126:    e082        ..      B        0x81022e ; ota_attr_read_cb + 712
;;;569        case BLE_SERVICE_CHAR_IMAGE_VERSION_INDEX:
;;;570            {
;;;571                T_IMG_HEADER_FORMAT *p_imgheader;
;;;572                static uint32_t version[5] = {0};
;;;573                uint32_t image_addr;
;;;574    
;;;575                T_OTA_HEADER_FORMAT *p_otaheader;
;;;576                image_addr = get_header_addr_by_img_id(OTA);
        0x00810128:    f2427090    B..p    MOV      r0,#0x2790
        0x0081012c:    f7fcdb5a    ..Z.    BL       get_header_addr_by_img_id ; 0xc7e4
        0x00810130:    4605        .F      MOV      r5,r0
;;;577                PROFILE_PRINT_INFO1("ota header addr = %x", image_addr);
        0x00810132:    bf00        ..      NOP      
        0x00810134:    bf00        ..      NOP      
        0x00810136:    462b        +F      MOV      r3,r5
        0x00810138:    2201        ."      MOVS     r2,#1
        0x0081013a:    4964        dI      LDR      r1,[pc,#400] ; [0x8102cc] = 0x8800c78
        0x0081013c:    4856        VH      LDR      r0,[pc,#344] ; [0x810298] = 0x21103302
        0x0081013e:    f7f7dc8e    ....    BL       log_buffer ; 0x7a5e
        0x00810142:    bf00        ..      NOP      
        0x00810144:    bf00        ..      NOP      
;;;578                p_otaheader = (T_OTA_HEADER_FORMAT *)image_addr;
        0x00810146:    46ab        .F      MOV      r11,r5
;;;579                if (p_otaheader)
        0x00810148:    f1bb0500    ....    SUBS     r5,r11,#0
        0x0081014c:    d003        ..      BEQ      0x810156 ; ota_attr_read_cb + 496
;;;580                {
;;;581                    version[0] = p_otaheader->ver_val;
        0x0081014e:    4960        `I      LDR      r1,[pc,#384] ; [0x8102d0] = 0x207f00
        0x00810150:    f8db0194    ....    LDR      r0,[r11,#0x194]
        0x00810154:    6008        .`      STR      r0,[r1,#0]
;;;582                }
;;;583    
;;;584                if (is_ota_support_bank_switch())
        0x00810156:    f7fcdb74    ..t.    BL       is_ota_support_bank_switch ; 0xc842
        0x0081015a:    b348        H.      CBZ      r0,0x8101b0 ; ota_attr_read_cb + 586
;;;585                {
;;;586                    image_addr = get_header_addr_by_img_id(RomPatch);
        0x0081015c:    f2427092    B..p    MOV      r0,#0x2792
        0x00810160:    f7fcdb40    ..@.    BL       get_header_addr_by_img_id ; 0xc7e4
        0x00810164:    4605        .F      MOV      r5,r0
;;;587                    p_imgheader = (T_IMG_HEADER_FORMAT *)image_addr;
        0x00810166:    462c        ,F      MOV      r4,r5
;;;588                    if (p_imgheader)
        0x00810168:    b114        ..      CBZ      r4,0x810170 ; ota_attr_read_cb + 522
;;;589                    {
;;;590                        version[1] = p_imgheader->git_ver.ver_info.version;
        0x0081016a:    4959        YI      LDR      r1,[pc,#356] ; [0x8102d0] = 0x207f00
        0x0081016c:    6e20         n      LDR      r0,[r4,#0x60]
        0x0081016e:    6048        H`      STR      r0,[r1,#4]
;;;591                    }
;;;592    
;;;593                    image_addr = get_header_addr_by_img_id(AppPatch);
        0x00810170:    f2427093    B..p    MOV      r0,#0x2793
        0x00810174:    f7fcdb36    ..6.    BL       get_header_addr_by_img_id ; 0xc7e4
        0x00810178:    4605        .F      MOV      r5,r0
;;;594                    p_imgheader = (T_IMG_HEADER_FORMAT *)image_addr;
        0x0081017a:    462c        ,F      MOV      r4,r5
;;;595                    if (p_imgheader)
        0x0081017c:    b114        ..      CBZ      r4,0x810184 ; ota_attr_read_cb + 542
;;;596                    {
;;;597                        version[2] = p_imgheader->git_ver.ver_info.version;
        0x0081017e:    4954        TI      LDR      r1,[pc,#336] ; [0x8102d0] = 0x207f00
        0x00810180:    6e20         n      LDR      r0,[r4,#0x60]
        0x00810182:    6088        .`      STR      r0,[r1,#8]
;;;598                    }
;;;599                    PROFILE_PRINT_INFO3("OTA Header V_0x%X, Patch V_0x%X, APP V_0x%X",
        0x00810184:    bf00        ..      NOP      
        0x00810186:    bf00        ..      NOP      
        0x00810188:    4851        QH      LDR      r0,[pc,#324] ; [0x8102d0] = 0x207f00
        0x0081018a:    6880        .h      LDR      r0,[r0,#8]
        0x0081018c:    4950        PI      LDR      r1,[pc,#320] ; [0x8102d0] = 0x207f00
        0x0081018e:    6849        Ih      LDR      r1,[r1,#4]
        0x00810190:    e9cd1000    ....    STRD     r1,r0,[sp,#0]
        0x00810194:    484e        NH      LDR      r0,[pc,#312] ; [0x8102d0] = 0x207f00
        0x00810196:    2203        ."      MOVS     r2,#3
        0x00810198:    494e        NI      LDR      r1,[pc,#312] ; [0x8102d4] = 0x8800c90
        0x0081019a:    6803        .h      LDR      r3,[r0,#0]
        0x0081019c:    483e        >H      LDR      r0,[pc,#248] ; [0x810298] = 0x21103302
        0x0081019e:    f7f7dc5e    ..^.    BL       log_buffer ; 0x7a5e
        0x008101a2:    bf00        ..      NOP      
        0x008101a4:    bf00        ..      NOP      
;;;600                                        version[0], version[1], version[2]);
;;;601    
;;;602                    *pp_value  = (uint8_t *)version;
        0x008101a6:    484a        JH      LDR      r0,[pc,#296] ; [0x8102d0] = 0x207f00
        0x008101a8:    6038        8`      STR      r0,[r7,#0]
;;;603                    *p_length = 12;
        0x008101aa:    200c        .       MOVS     r0,#0xc
        0x008101ac:    8030        0.      STRH     r0,[r6,#0]
        0x008101ae:    e035        5.      B        0x81021c ; ota_attr_read_cb + 694
;;;604                }
;;;605                else
;;;606                {
;;;607                    image_addr = get_header_addr_by_img_id(SecureBoot);
        0x008101b0:    f2427091    B..p    MOV      r0,#0x2791
        0x008101b4:    f7fcdb16    ....    BL       get_header_addr_by_img_id ; 0xc7e4
        0x008101b8:    4605        .F      MOV      r5,r0
;;;608                    p_imgheader = (T_IMG_HEADER_FORMAT *)image_addr;
        0x008101ba:    462c        ,F      MOV      r4,r5
;;;609                    if (p_imgheader)
        0x008101bc:    b114        ..      CBZ      r4,0x8101c4 ; ota_attr_read_cb + 606
;;;610                    {
;;;611                        version[1] = p_imgheader->git_ver.ver_info.version;
        0x008101be:    4944        DI      LDR      r1,[pc,#272] ; [0x8102d0] = 0x207f00
        0x008101c0:    6e20         n      LDR      r0,[r4,#0x60]
        0x008101c2:    6048        H`      STR      r0,[r1,#4]
;;;612                    }
;;;613    
;;;614                    image_addr = get_header_addr_by_img_id(RomPatch);
        0x008101c4:    f2427092    B..p    MOV      r0,#0x2792
        0x008101c8:    f7fcdb0c    ....    BL       get_header_addr_by_img_id ; 0xc7e4
        0x008101cc:    4605        .F      MOV      r5,r0
;;;615                    p_imgheader = (T_IMG_HEADER_FORMAT *)image_addr;
        0x008101ce:    462c        ,F      MOV      r4,r5
;;;616                    if (p_imgheader)
        0x008101d0:    b114        ..      CBZ      r4,0x8101d8 ; ota_attr_read_cb + 626
;;;617                    {
;;;618                        version[2] = p_imgheader->git_ver.ver_info.version;
        0x008101d2:    493f        ?I      LDR      r1,[pc,#252] ; [0x8102d0] = 0x207f00
        0x008101d4:    6e20         n      LDR      r0,[r4,#0x60]
        0x008101d6:    6088        .`      STR      r0,[r1,#8]
;;;619                    }
;;;620    
;;;621                    image_addr = get_header_addr_by_img_id(AppPatch);
        0x008101d8:    f2427093    B..p    MOV      r0,#0x2793
        0x008101dc:    f7fcdb02    ....    BL       get_header_addr_by_img_id ; 0xc7e4
        0x008101e0:    4605        .F      MOV      r5,r0
;;;622                    p_imgheader = (T_IMG_HEADER_FORMAT *)image_addr;
        0x008101e2:    462c        ,F      MOV      r4,r5
;;;623                    if (p_imgheader)
        0x008101e4:    b114        ..      CBZ      r4,0x8101ec ; ota_attr_read_cb + 646
;;;624                    {
;;;625                        version[3] = p_imgheader->git_ver.ver_info.version;
        0x008101e6:    493a        :I      LDR      r1,[pc,#232] ; [0x8102d0] = 0x207f00
        0x008101e8:    6e20         n      LDR      r0,[r4,#0x60]
        0x008101ea:    60c8        .`      STR      r0,[r1,#0xc]
;;;626                    }
;;;627                    PROFILE_PRINT_INFO4("OTA Header V_0x%X, Secure Boot V_0x%X, Patch V_0x%X, APP V_0x%X",
        0x008101ec:    bf00        ..      NOP      
        0x008101ee:    bf00        ..      NOP      
        0x008101f0:    4837        7H      LDR      r0,[pc,#220] ; [0x8102d0] = 0x207f00
        0x008101f2:    68c0        .h      LDR      r0,[r0,#0xc]
        0x008101f4:    4936        6I      LDR      r1,[pc,#216] ; [0x8102d0] = 0x207f00
        0x008101f6:    6889        .h      LDR      r1,[r1,#8]
        0x008101f8:    4a35        5J      LDR      r2,[pc,#212] ; [0x8102d0] = 0x207f00
        0x008101fa:    6852        Rh      LDR      r2,[r2,#4]
        0x008101fc:    e9cd2100    ...!    STRD     r2,r1,[sp,#0]
        0x00810200:    9002        ..      STR      r0,[sp,#8]
        0x00810202:    4833        3H      LDR      r0,[pc,#204] ; [0x8102d0] = 0x207f00
        0x00810204:    2204        ."      MOVS     r2,#4
        0x00810206:    4934        4I      LDR      r1,[pc,#208] ; [0x8102d8] = 0x8800cc0
        0x00810208:    6803        .h      LDR      r3,[r0,#0]
        0x0081020a:    4823        #H      LDR      r0,[pc,#140] ; [0x810298] = 0x21103302
        0x0081020c:    f7f7dc27    ..'.    BL       log_buffer ; 0x7a5e
        0x00810210:    bf00        ..      NOP      
        0x00810212:    bf00        ..      NOP      
;;;628                                        version[0], version[1], version[2], version[3]);
;;;629    
;;;630                    *pp_value  = (uint8_t *)version;
        0x00810214:    482e        .H      LDR      r0,[pc,#184] ; [0x8102d0] = 0x207f00
        0x00810216:    6038        8`      STR      r0,[r7,#0]
;;;631                    *p_length = 16;
        0x00810218:    2010        .       MOVS     r0,#0x10
        0x0081021a:    8030        0.      STRH     r0,[r6,#0]
;;;632                }
;;;633    
;;;634                /* Notify Application. */
;;;635                callback_data.msg_type = SERVICE_CALLBACK_TYPE_READ_CHAR_VALUE;
        0x0081021c:    2002        .       MOVS     r0,#2
        0x0081021e:    f88d0010    ....    STRB     r0,[sp,#0x10]
;;;636                callback_data.msg_data.read_value_index = OTA_READ_CHAR_IMAGE_VERSION_INDEX;
        0x00810222:    2006        .       MOVS     r0,#6
        0x00810224:    f88d0012    ....    STRB     r0,[sp,#0x12]
;;;637                /*defer processing before ota start*/
;;;638                defer_handle = true;
        0x00810228:    2001        .       MOVS     r0,#1
        0x0081022a:    9003        ..      STR      r0,[sp,#0xc]
;;;639            }
;;;640            break;
        0x0081022c:    bf00        ..      NOP      
        0x0081022e:    bf00        ..      NOP      
;;;641    #if (SUPPORT_OTA_PROTOCOL_TYPE_CHARACTERISTIC == 1)
;;;642        case BLE_SERVICE_CHAR_PROTOCOL_TYPE_INDEX:
;;;643            {
;;;644                protocol_type = 0x0012;
;;;645                *pp_value  = (uint8_t *)&protocol_type;
;;;646                *p_length = sizeof(protocol_type);
;;;647            }
;;;648            break;
;;;649    #endif
;;;650        }
;;;651    
;;;652        /* Notify Application. */
;;;653        if (pfnOTAExtendedCB && (defer_handle == true))
        0x00810230:    4817        .H      LDR      r0,[pc,#92] ; [0x810290] = 0x207edc
        0x00810232:    6800        .h      LDR      r0,[r0,#0]
        0x00810234:    b138        8.      CBZ      r0,0x810246 ; ota_attr_read_cb + 736
        0x00810236:    9803        ..      LDR      r0,[sp,#0xc]
        0x00810238:    2801        .(      CMP      r0,#1
        0x0081023a:    d104        ..      BNE      0x810246 ; ota_attr_read_cb + 736
;;;654        {
;;;655            pfnOTAExtendedCB(service_id, (void *)&callback_data);
        0x0081023c:    a904        ..      ADD      r1,sp,#0x10
        0x0081023e:    4648        HF      MOV      r0,r9
        0x00810240:    4a13        .J      LDR      r2,[pc,#76] ; [0x810290] = 0x207edc
        0x00810242:    6812        .h      LDR      r2,[r2,#0]
        0x00810244:    4790        .G      BLX      r2
;;;656        }
;;;657        return (wCause);
        0x00810246:    4650        PF      MOV      r0,r10
;;;658    }
        0x00810248:    b007        ..      ADD      sp,sp,#0x1c
        0x0081024a:    e8bd8ff0    ....    POP      {r4-r11,pc}
    ota_add_service
;;;659    
;;;660    
;;;661    /**
;;;662     * @brief OTA ble Service Callbacks.
;;;663    */
;;;664    const T_FUN_GATT_SERVICE_CBS OTAServiceCBs =
;;;665    {
;;;666        ota_attr_read_cb,   // Read callback function pointer
;;;667        ota_attr_write_cb,  // Write callback function pointer
;;;668        NULL                    // CCCD update callback function pointer
;;;669    };
;;;670    
;;;671    /**
;;;672     * @brief  add OTA ble service to application.
;;;673     *
;;;674     * @param  pFunc          pointer of app callback function called by profile.
;;;675     * @return service ID auto generated by profile layer.
;;;676     * @retval ServiceId
;;;677    */
;;;678    uint8_t ota_add_service(void *pFunc)
;;;679    {
        0x0081024e:    b53e        >.      PUSH     {r1-r5,lr}
        0x00810250:    4604        .F      MOV      r4,r0
;;;680        uint8_t ServiceId;
;;;681        if (false == server_add_service(&ServiceId,
        0x00810252:    4922        "I      LDR      r1,[pc,#136] ; [0x8102dc] = 0x811bb0
        0x00810254:    e9d10101    ....    LDRD     r0,r1,[r1,#4]
        0x00810258:    e9cd0100    ....    STRD     r0,r1,[sp,#0]
        0x0081025c:    481f        .H      LDR      r0,[pc,#124] ; [0x8102dc] = 0x811bb0
        0x0081025e:    f44f7205    O..r    MOV      r2,#0x214
        0x00810262:    491f        .I      LDR      r1,[pc,#124] ; [0x8102e0] = 0x81199c
        0x00810264:    6803        .h      LDR      r3,[r0,#0]
        0x00810266:    a802        ..      ADD      r0,sp,#8
        0x00810268:    f43ff201    ?...    BL       server_add_service ; 0x4f66e
        0x0081026c:    bbe0        ..      CBNZ     r0,0x8102e8 ; ota_add_service + 154
;;;682                                        (uint8_t *)gattOtaServiceTable,
;;;683                                        sizeof(gattOtaServiceTable),
;;;684                                        OTAServiceCBs))
;;;685        {
;;;686            PROFILE_PRINT_ERROR1("OTAService_AddService: ServiceId %d", ServiceId);
        0x0081026e:    bf00        ..      NOP      
        0x00810270:    bf00        ..      NOP      
        0x00810272:    f89d3008    ...0    LDRB     r3,[sp,#8]
        0x00810276:    2201        ."      MOVS     r2,#1
        0x00810278:    491a        .I      LDR      r1,[pc,#104] ; [0x8102e4] = 0x8800d04
        0x0081027a:    4807        .H      LDR      r0,[pc,#28] ; [0x810298] = 0x21103302
        0x0081027c:    1e80        ..      SUBS     r0,r0,#2
        0x0081027e:    f7f7dbee    ....    BL       log_buffer ; 0x7a5e
        0x00810282:    bf00        ..      NOP      
        0x00810284:    bf00        ..      NOP      
;;;687            ServiceId = 0xff;
        0x00810286:    20ff        .       MOVS     r0,#0xff
        0x00810288:    9002        ..      STR      r0,[sp,#8]
;;;688            return ServiceId;
        0x0081028a:    f89d0008    ....    LDRB     r0,[sp,#8]
        0x0081028e:    bd3e        >.      POP      {r1-r5,pc}
    $d
        0x00810290:    00207edc    .~ .    DCD    2129628
        0x00810294:    08800bb8    ....    DCD    142609336
        0x00810298:    21103302    .3.!    DCD    554709762
        0x0081029c:    08800bf4    ....    DCD    142609396
        0x008102a0:    00207ee0    .~ .    DCD    2129632
        0x008102a4:    08800c24    $...    DCD    142609444
        0x008102a8:    00207ee8    .~ .    DCD    2129640
        0x008102ac:    08800c38    8...    DCD    142609464
        0x008102b0:    08800c50    P...    DCD    142609488
        0x008102b4:    00207ef0    .~ .    DCD    2129648
        0x008102b8:    08800c64    d...    DCD    142609508
        0x008102bc:    00207ef4    .~ .    DCD    2129652
        0x008102c0:    00207e3c    <~ .    DCD    2129468
        0x008102c4:    00200314    .. .    DCD    2097940
        0x008102c8:    00802000    . ..    DCD    8396800
        0x008102cc:    08800c78    x...    DCD    142609528
        0x008102d0:    00207f00    .. .    DCD    2129664
        0x008102d4:    08800c90    ....    DCD    142609552
        0x008102d8:    08800cc0    ....    DCD    142609600
        0x008102dc:    00811bb0    ....    DCD    8461232
        0x008102e0:    0081199c    ....    DCD    8460700
        0x008102e4:    08800d04    ....    DCD    142609668
    $t
        0x008102e8:    e7ff        ..      B        0x8102ea ; ota_add_service + 156
;;;689        }
;;;690        pfnOTAExtendedCB = (P_FUN_SERVER_GENERAL_CB)pFunc;
        0x008102ea:    4802        .H      LDR      r0,[pc,#8] ; [0x8102f4] = 0x207edc
        0x008102ec:    6004        .`      STR      r4,[r0,#0]
;;;691        return ServiceId;
        0x008102ee:    f89d0008    ....    LDRB     r0,[sp,#8]
;;;692    }
        0x008102f2:    bd3e        >.      POP      {r1-r5,pc}
    $d
        0x008102f4:    00207edc    .~ .    DCD    2129628
    $t
    .text
    RCC_PeriphClockCmd
;;; .\..\..\..\src\mcu\peripheral\rtl876x_rcc.c
;;;66     {
        0x008102f8:    b570        p.      PUSH     {r4-r6,lr}
        0x008102fa:    4603        .F      MOV      r3,r0
;;;67         /* Check the parameters */
;;;68         assert_param(IS_APB_PERIPH(APBPeriph));
;;;69         assert_param(IS_APB_PERIPH_CLOCK(APBPeriph_Clock));
;;;70         assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;71     
;;;72         uint32_t apbRegOff = ((APBPeriph & (0x03 << 26)) >> 26);
        0x008102fc:    f3c36481    ...d    UBFX     r4,r3,#26,#2
;;;73         uint32_t clkRegOff = ((APBPeriph_Clock & (0x03 << 29)) >> 29);
        0x00810300:    f3c17041    ..Ap    UBFX     r0,r1,#29,#2
;;;74     
;;;75         /*Open clock gating first*/
;;;76         if (NewState == ENABLE)
        0x00810304:    2a01        .*      CMP      r2,#1
        0x00810306:    d14c        L.      BNE      0x8103a2 ; RCC_PeriphClockCmd + 170
;;;77         {
;;;78             if (APBPeriph_Clock == APBPeriph_KEYSCAN_CLOCK)
        0x00810308:    4df8        .M      LDR      r5,[pc,#992] ; [0x8106ec] = 0x60000040
        0x0081030a:    42a9        .B      CMP      r1,r5
        0x0081030c:    d10e        ..      BNE      0x81032c ; RCC_PeriphClockCmd + 52
;;;79             {
;;;80                 /*Open 5M clock source*/
;;;81                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
        0x0081030e:    4df8        .M      LDR      r5,[pc,#992] ; [0x8106f0] = 0x4000020c
        0x00810310:    682d        -h      LDR      r5,[r5,#0]
        0x00810312:    f0456580    E..e    ORR      r5,r5,#0x4000000
        0x00810316:    060e        ..      LSLS     r6,r1,#24
        0x00810318:    f8c6520c    ...R    STR      r5,[r6,#0x20c]
;;;82                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT29;
        0x0081031c:    060d        ..      LSLS     r5,r1,#24
        0x0081031e:    f8d5520c    ...R    LDR      r5,[r5,#0x20c]
        0x00810322:    f0455500    E..U    ORR      r5,r5,#0x20000000
        0x00810326:    f8c6520c    ...R    STR      r5,[r6,#0x20c]
        0x0081032a:    e03a        :.      B        0x8103a2 ; RCC_PeriphClockCmd + 170
;;;83             }
;;;84             else if (APBPeriph_Clock == APBPeriph_ADC_CLOCK)
        0x0081032c:    f1b14fc2    ...O    CMP      r1,#0x61000000
        0x00810330:    d10f        ..      BNE      0x810352 ; RCC_PeriphClockCmd + 90
;;;85             {
;;;86                 /*Open 10M clock source*/
;;;87                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
        0x00810332:    4def        .M      LDR      r5,[pc,#956] ; [0x8106f0] = 0x4000020c
        0x00810334:    682d        -h      LDR      r5,[r5,#0]
        0x00810336:    f0456580    E..e    ORR      r5,r5,#0x4000000
        0x0081033a:    f04f4680    O..F    MOV      r6,#0x40000000
        0x0081033e:    f8c6520c    ...R    STR      r5,[r6,#0x20c]
;;;88                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT28;
        0x00810342:    4635        5F      MOV      r5,r6
        0x00810344:    f8d5520c    ...R    LDR      r5,[r5,#0x20c]
        0x00810348:    f0455580    E..U    ORR      r5,r5,#0x10000000
        0x0081034c:    f8c6520c    ...R    STR      r5,[r6,#0x20c]
        0x00810350:    e027        '.      B        0x8103a2 ; RCC_PeriphClockCmd + 170
;;;89             }
;;;90             else if ((APBPeriph_Clock == APBPeriph_QDEC_CLOCK) || (APBPeriph_Clock == APBPeriph_SPI2W_CLOCK))
        0x00810352:    4de6        .M      LDR      r5,[pc,#920] ; [0x8106ec] = 0x60000040
        0x00810354:    3d30        0=      SUBS     r5,r5,#0x30
        0x00810356:    42a9        .B      CMP      r1,r5
        0x00810358:    d002        ..      BEQ      0x810360 ; RCC_PeriphClockCmd + 104
        0x0081035a:    4de6        .M      LDR      r5,[pc,#920] ; [0x8106f4] = 0x60010000
        0x0081035c:    42a9        .B      CMP      r1,r5
        0x0081035e:    d10f        ..      BNE      0x810380 ; RCC_PeriphClockCmd + 136
;;;91             {
;;;92                 /*Open 20M clock source*/
;;;93                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT26;
        0x00810360:    4de3        .M      LDR      r5,[pc,#908] ; [0x8106f0] = 0x4000020c
        0x00810362:    682d        -h      LDR      r5,[r5,#0]
        0x00810364:    f0456580    E..e    ORR      r5,r5,#0x4000000
        0x00810368:    f04f4680    O..F    MOV      r6,#0x40000000
        0x0081036c:    f8c6520c    ...R    STR      r5,[r6,#0x20c]
;;;94                 SYSBLKCTRL->u_20C.RSVD_20C |= BIT27;
        0x00810370:    4635        5F      MOV      r5,r6
        0x00810372:    f8d5520c    ...R    LDR      r5,[r5,#0x20c]
        0x00810376:    f0456500    E..e    ORR      r5,r5,#0x8000000
        0x0081037a:    f8c6520c    ...R    STR      r5,[r6,#0x20c]
        0x0081037e:    e010        ..      B        0x8103a2 ; RCC_PeriphClockCmd + 170
;;;95             }
;;;96             else if (APBPeriph_Clock == APBPeriph_TIMER_CLOCK)
        0x00810380:    4ddd        .M      LDR      r5,[pc,#884] ; [0x8106f8] = 0x20004000
        0x00810382:    42a9        .B      CMP      r1,r5
        0x00810384:    d10d        ..      BNE      0x8103a2 ; RCC_PeriphClockCmd + 170
;;;97             {
;;;98                 /* Enable TIM0~1 fixed 40M */
;;;99                 CLK_SOURCE_REG_2 |= BIT9;
        0x00810386:    4ddd        .M      LDR      r5,[pc,#884] ; [0x8106fc] = 0x40000360
        0x00810388:    682d        -h      LDR      r5,[r5,#0]
        0x0081038a:    f4457500    E..u    ORR      r5,r5,#0x200
        0x0081038e:    040e        ..      LSLS     r6,r1,#16
        0x00810390:    f8c65360    ..`S    STR      r5,[r6,#0x360]
;;;100                /* enable TIM2~7 ICG*/
;;;101                CLK_SOURCE_REG_0 |= BIT4;
        0x00810394:    040d        ..      LSLS     r5,r1,#16
        0x00810396:    f8d55348    ..HS    LDR      r5,[r5,#0x348]
        0x0081039a:    f0450510    E...    ORR      r5,r5,#0x10
        0x0081039e:    f8c65348    ..HS    STR      r5,[r6,#0x348]
;;;102            }
;;;103        }
;;;104    
;;;105        /* Special register handle */
;;;106        if (NewState == ENABLE)
        0x008103a2:    2a01        .*      CMP      r2,#1
        0x008103a4:    d112        ..      BNE      0x8103cc ; RCC_PeriphClockCmd + 212
;;;107        {
;;;108            if ((APBPeriph_Clock == APBPeriph_I2S0_CLOCK) || ((APBPeriph_Clock == APBPeriph_I2S1_CLOCK)) ||
        0x008103a6:    f5b17f90    ....    CMP      r1,#0x120
        0x008103aa:    d004        ..      BEQ      0x8103b6 ; RCC_PeriphClockCmd + 190
        0x008103ac:    f5b17fa0    ....    CMP      r1,#0x140
        0x008103b0:    d001        ..      BEQ      0x8103b6 ; RCC_PeriphClockCmd + 190
;;;109                (APBPeriph_Clock == APBPeriph_CODEC_CLOCK))
        0x008103b2:    2910        .)      CMP      r1,#0x10
        0x008103b4:    d11d        ..      BNE      0x8103f2 ; RCC_PeriphClockCmd + 250
;;;110            {
;;;111                SYSBLKCTRL->u_220 |= APBPeriph | APBPeriph_Clock;
        0x008103b6:    4dce        .M      LDR      r5,[pc,#824] ; [0x8106f0] = 0x4000020c
        0x008103b8:    3514        .5      ADDS     r5,r5,#0x14
        0x008103ba:    682d        -h      LDR      r5,[r5,#0]
        0x008103bc:    ea430601    C...    ORR      r6,r3,r1
        0x008103c0:    4335        5C      ORRS     r5,r5,r6
        0x008103c2:    f04f4680    O..F    MOV      r6,#0x40000000
        0x008103c6:    f8c65220    .. R    STR      r5,[r6,#0x220]
        0x008103ca:    bd70        p.      POP      {r4-r6,pc}
;;;112                return;
;;;113            }
;;;114        }
;;;115        else
;;;116        {
;;;117            if ((APBPeriph_Clock == APBPeriph_I2S0_CLOCK) || ((APBPeriph_Clock == APBPeriph_I2S1_CLOCK)) ||
        0x008103cc:    f5b17f90    ....    CMP      r1,#0x120
        0x008103d0:    d004        ..      BEQ      0x8103dc ; RCC_PeriphClockCmd + 228
        0x008103d2:    f5b17fa0    ....    CMP      r1,#0x140
        0x008103d6:    d001        ..      BEQ      0x8103dc ; RCC_PeriphClockCmd + 228
;;;118                (APBPeriph_Clock == APBPeriph_CODEC_CLOCK))
        0x008103d8:    2910        .)      CMP      r1,#0x10
        0x008103da:    d10a        ..      BNE      0x8103f2 ; RCC_PeriphClockCmd + 250
;;;119            {
;;;120                SYSBLKCTRL->u_220 &= ~(APBPeriph | APBPeriph_Clock);
        0x008103dc:    4dc4        .M      LDR      r5,[pc,#784] ; [0x8106f0] = 0x4000020c
        0x008103de:    3514        .5      ADDS     r5,r5,#0x14
        0x008103e0:    682d        -h      LDR      r5,[r5,#0]
        0x008103e2:    ea430601    C...    ORR      r6,r3,r1
        0x008103e6:    43b5        .C      BICS     r5,r5,r6
        0x008103e8:    f04f4680    O..F    MOV      r6,#0x40000000
        0x008103ec:    f8c65220    .. R    STR      r5,[r6,#0x220]
;;;121                return;
        0x008103f0:    e7eb        ..      B        0x8103ca ; RCC_PeriphClockCmd + 210
;;;122            }
;;;123        }
;;;124    
;;;125        /* clear flag */
;;;126        APBPeriph &= (~(0x03 << 26));
        0x008103f2:    f0236340    #.@c    BIC      r3,r3,#0xc000000
;;;127        APBPeriph_Clock &= (~(0x03 << 29));
        0x008103f6:    f02141c0    !..A    BIC      r1,r1,#0x60000000
;;;128    
;;;129        if (NewState == ENABLE)
        0x008103fa:    2a01        .*      CMP      r2,#1
        0x008103fc:    d124        $.      BNE      0x810448 ; RCC_PeriphClockCmd + 336
;;;130        {
;;;131            //enable peripheral
;;;132            *((uint32_t *)(&(SYSBLKCTRL->u_210.SOC_FUNC_EN)) + apbRegOff) |= APBPeriph;
        0x008103fe:    4dbc        .M      LDR      r5,[pc,#752] ; [0x8106f0] = 0x4000020c
        0x00810400:    1d2d        -.      ADDS     r5,r5,#4
        0x00810402:    f8555024    U.$P    LDR      r5,[r5,r4,LSL #2]
        0x00810406:    431d        .C      ORRS     r5,r5,r3
        0x00810408:    4eb9        .N      LDR      r6,[pc,#740] ; [0x8106f0] = 0x4000020c
        0x0081040a:    1d36        6.      ADDS     r6,r6,#4
        0x0081040c:    f8465024    F.$P    STR      r5,[r6,r4,LSL #2]
;;;133            //enable peripheral clock
;;;134            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) |= APBPeriph_Clock;
        0x00810410:    4db7        .M      LDR      r5,[pc,#732] ; [0x8106f0] = 0x4000020c
        0x00810412:    3524        $5      ADDS     r5,r5,#0x24
        0x00810414:    eb050580    ....    ADD      r5,r5,r0,LSL #2
        0x00810418:    f8556c04    U..l    LDR      r6,[r5,#-4]
        0x0081041c:    430e        .C      ORRS     r6,r6,r1
        0x0081041e:    4db4        .M      LDR      r5,[pc,#720] ; [0x8106f0] = 0x4000020c
        0x00810420:    3524        $5      ADDS     r5,r5,#0x24
        0x00810422:    eb050580    ....    ADD      r5,r5,r0,LSL #2
        0x00810426:    f8456c04    E..l    STR      r6,[r5,#-4]
;;;135            //enable peripheral clock in sleep mode
;;;136            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) |= (APBPeriph_Clock << 1);
        0x0081042a:    4db1        .M      LDR      r5,[pc,#708] ; [0x8106f0] = 0x4000020c
        0x0081042c:    3524        $5      ADDS     r5,r5,#0x24
        0x0081042e:    eb050580    ....    ADD      r5,r5,r0,LSL #2
        0x00810432:    f8555c04    U..\    LDR      r5,[r5,#-4]
        0x00810436:    ea450641    E.A.    ORR      r6,r5,r1,LSL #1
        0x0081043a:    4dad        .M      LDR      r5,[pc,#692] ; [0x8106f0] = 0x4000020c
        0x0081043c:    3524        $5      ADDS     r5,r5,#0x24
        0x0081043e:    eb050580    ....    ADD      r5,r5,r0,LSL #2
        0x00810442:    f8456c04    E..l    STR      r6,[r5,#-4]
        0x00810446:    e023        #.      B        0x810490 ; RCC_PeriphClockCmd + 408
;;;137        }
;;;138        else
;;;139        {
;;;140            //disable peripheral
;;;141            *((uint32_t *)(&(SYSBLKCTRL->u_210.SOC_FUNC_EN)) + apbRegOff) &= (~APBPeriph);
        0x00810448:    4da9        .M      LDR      r5,[pc,#676] ; [0x8106f0] = 0x4000020c
        0x0081044a:    1d2d        -.      ADDS     r5,r5,#4
        0x0081044c:    f8555024    U.$P    LDR      r5,[r5,r4,LSL #2]
        0x00810450:    439d        .C      BICS     r5,r5,r3
        0x00810452:    4ea7        .N      LDR      r6,[pc,#668] ; [0x8106f0] = 0x4000020c
        0x00810454:    1d36        6.      ADDS     r6,r6,#4
        0x00810456:    f8465024    F.$P    STR      r5,[r6,r4,LSL #2]
;;;142            //disable peripheral clock
;;;143            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) &= (~APBPeriph_Clock);
        0x0081045a:    4da5        .M      LDR      r5,[pc,#660] ; [0x8106f0] = 0x4000020c
        0x0081045c:    3524        $5      ADDS     r5,r5,#0x24
        0x0081045e:    eb050580    ....    ADD      r5,r5,r0,LSL #2
        0x00810462:    f8555c04    U..\    LDR      r5,[r5,#-4]
        0x00810466:    438d        .C      BICS     r5,r5,r1
        0x00810468:    4ea1        .N      LDR      r6,[pc,#644] ; [0x8106f0] = 0x4000020c
        0x0081046a:    3624        $6      ADDS     r6,r6,#0x24
        0x0081046c:    eb060680    ....    ADD      r6,r6,r0,LSL #2
        0x00810470:    f8465c04    F..\    STR      r5,[r6,#-4]
;;;144            //disable peripheral clock in sleep mode
;;;145            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) &= (~(APBPeriph_Clock << 1));
        0x00810474:    4d9e        .M      LDR      r5,[pc,#632] ; [0x8106f0] = 0x4000020c
        0x00810476:    3524        $5      ADDS     r5,r5,#0x24
        0x00810478:    eb050580    ....    ADD      r5,r5,r0,LSL #2
        0x0081047c:    f8555c04    U..\    LDR      r5,[r5,#-4]
        0x00810480:    ea250641    %.A.    BIC      r6,r5,r1,LSL #1
        0x00810484:    4d9a        .M      LDR      r5,[pc,#616] ; [0x8106f0] = 0x4000020c
        0x00810486:    3524        $5      ADDS     r5,r5,#0x24
        0x00810488:    eb050580    ....    ADD      r5,r5,r0,LSL #2
        0x0081048c:    f8456c04    E..l    STR      r6,[r5,#-4]
;;;146        }
;;;147    
;;;148        return;
        0x00810490:    bf00        ..      NOP      
        0x00810492:    e79a        ..      B        0x8103ca ; RCC_PeriphClockCmd + 210
    RCC_SPIClkDivConfig
;;;149    }
;;;150    
;;;151    /**
;;;152      * @brief  SPI clock divider config.
;;;153      * @param  SPIx: where x can be 0 or 1 to select the SPI peripheral.
;;;154      * @param  ClockDiv: specifies the APB peripheral to gates its clock.
;;;155      *      this parameter can be one of the following values:
;;;156      *     @arg SPI_CLOCK_DIV_1
;;;157      *     @arg SPI_CLOCK_DIV_2
;;;158      *     @arg SPI_CLOCK_DIV_4
;;;159      *     @arg SPI_CLOCK_DIV_8
;;;160      * @retval None
;;;161      */
;;;162    void RCC_SPIClkDivConfig(SPI_TypeDef *SPIx, uint16_t ClockDiv)
;;;163    {
;;;164        assert_param(IS_SPI_DIV(ClockDiv));
;;;165    
;;;166        /* Config I2C clock divider */
;;;167        if (SPIx == SPI0)
        0x00810494:    4a9a        .J      LDR      r2,[pc,#616] ; [0x810700] = 0x40013000
        0x00810496:    4290        .B      CMP      r0,r2
        0x00810498:    d11e        ..      BNE      0x8104d8 ; RCC_SPIClkDivConfig + 68
;;;168        {
;;;169            /* disable clock first */
;;;170            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 &= ~SYSBLK_ACTCK_SPI0_EN_Msk;
        0x0081049a:    4a95        .J      LDR      r2,[pc,#596] ; [0x8106f0] = 0x4000020c
        0x0081049c:    3228        (2      ADDS     r2,r2,#0x28
        0x0081049e:    6812        .h      LDR      r2,[r2,#0]
        0x008104a0:    f4223280    "..2    BIC      r2,r2,#0x10000
        0x008104a4:    f04f4380    O..C    MOV      r3,#0x40000000
        0x008104a8:    f8c32234    ..4"    STR      r2,[r3,#0x234]
;;;171            //platform_delay_us(1);
;;;172    
;;;173            CLK_SOURCE_REG_1 &= ~(0x03 << 19);
        0x008104ac:    461a        .F      MOV      r2,r3
        0x008104ae:    f8d2235c    ..\#    LDR      r2,[r2,#0x35c]
        0x008104b2:    f42212c0    "...    BIC      r2,r2,#0x180000
        0x008104b6:    f8c3235c    ..\#    STR      r2,[r3,#0x35c]
;;;174            CLK_SOURCE_REG_1 |= (ClockDiv << 19);
        0x008104ba:    461a        .F      MOV      r2,r3
        0x008104bc:    f8d2235c    ..\#    LDR      r2,[r2,#0x35c]
        0x008104c0:    ea4242c1    B..B    ORR      r2,r2,r1,LSL #19
        0x008104c4:    f8c3235c    ..\#    STR      r2,[r3,#0x35c]
;;;175    
;;;176            //platform_delay_us(1);
;;;177            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= SYSBLK_ACTCK_SPI0_EN_Msk;
        0x008104c8:    461a        .F      MOV      r2,r3
        0x008104ca:    f8d22234    ..4"    LDR      r2,[r2,#0x234]
        0x008104ce:    f4423280    B..2    ORR      r2,r2,#0x10000
        0x008104d2:    f8c32234    ..4"    STR      r2,[r3,#0x234]
        0x008104d6:    e01f        ..      B        0x810518 ; RCC_SPIClkDivConfig + 132
;;;178        }
;;;179        else if (SPIx == SPI1)
        0x008104d8:    4a8a        .J      LDR      r2,[pc,#552] ; [0x810704] = 0x40013400
        0x008104da:    4290        .B      CMP      r0,r2
        0x008104dc:    d11c        ..      BNE      0x810518 ; RCC_SPIClkDivConfig + 132
;;;180        {
;;;181            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 &= ~SYSBLK_ACTCK_SPI1_EN_Msk;
        0x008104de:    4a84        .J      LDR      r2,[pc,#528] ; [0x8106f0] = 0x4000020c
        0x008104e0:    3228        (2      ADDS     r2,r2,#0x28
        0x008104e2:    6812        .h      LDR      r2,[r2,#0]
        0x008104e4:    f4222280    ".."    BIC      r2,r2,#0x40000
        0x008104e8:    0503        ..      LSLS     r3,r0,#20
        0x008104ea:    f8c32234    ..4"    STR      r2,[r3,#0x234]
;;;182            //platform_delay_us(1);
;;;183    
;;;184            CLK_SOURCE_REG_1 &= ~(0x03 << 21);
        0x008104ee:    0502        ..      LSLS     r2,r0,#20
        0x008104f0:    f8d2235c    ..\#    LDR      r2,[r2,#0x35c]
        0x008104f4:    f42202c0    "...    BIC      r2,r2,#0x600000
        0x008104f8:    f8c3235c    ..\#    STR      r2,[r3,#0x35c]
;;;185            CLK_SOURCE_REG_1 |= (ClockDiv << 21);
        0x008104fc:    0502        ..      LSLS     r2,r0,#20
        0x008104fe:    f8d2235c    ..\#    LDR      r2,[r2,#0x35c]
        0x00810502:    ea425241    B.AR    ORR      r2,r2,r1,LSL #21
        0x00810506:    f8c3235c    ..\#    STR      r2,[r3,#0x35c]
;;;186    
;;;187            //platform_delay_us(1);
;;;188            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= SYSBLK_ACTCK_SPI1_EN_Msk;
        0x0081050a:    0502        ..      LSLS     r2,r0,#20
        0x0081050c:    f8d22234    ..4"    LDR      r2,[r2,#0x234]
        0x00810510:    f4422280    B.."    ORR      r2,r2,#0x40000
        0x00810514:    f8c32234    ..4"    STR      r2,[r3,#0x234]
;;;189        }
;;;190        return;
;;;191    }
        0x00810518:    4770        pG      BX       lr
    RCC_I2CClkDivConfig
;;;192    
;;;193    /**
;;;194      * @brief  I2C clock divider config.
;;;195      * @param  I2Cx: where x can be 0 or 1 to select the I2C peripheral.
;;;196      * @param  ClockDiv: specifies the APB peripheral to gates its clock.
;;;197      *      this parameter can be one of the following values:
;;;198      *     @arg I2C_CLOCK_DIV_1
;;;199      *     @arg I2C_CLOCK_DIV_2
;;;200      *     @arg I2C_CLOCK_DIV_4
;;;201      *     @arg I2C_CLOCK_DIV_8
;;;202      * @retval None
;;;203      */
;;;204    void RCC_I2CClkDivConfig(I2C_TypeDef *I2Cx, uint16_t ClockDiv)
;;;205    {
;;;206        assert_param(IS_I2C_DIV(ClockDiv));
;;;207    
;;;208        /* Config I2C clock divider */
;;;209        if (I2Cx == I2C0)
        0x0081051a:    4a7b        {J      LDR      r2,[pc,#492] ; [0x810708] = 0x40015000
        0x0081051c:    4290        .B      CMP      r0,r2
        0x0081051e:    d11d        ..      BNE      0x81055c ; RCC_I2CClkDivConfig + 66
;;;210        {
;;;211            /* disable clock first */
;;;212            SYSBLKCTRL->u_238.PERI_CLK_CTRL1 &= ~SYSBLK_ACTCK_I2C0_EN_Msk;
        0x00810520:    4a73        sJ      LDR      r2,[pc,#460] ; [0x8106f0] = 0x4000020c
        0x00810522:    322c        ,2      ADDS     r2,r2,#0x2c
        0x00810524:    6812        .h      LDR      r2,[r2,#0]
        0x00810526:    f0220201    "...    BIC      r2,r2,#1
        0x0081052a:    0483        ..      LSLS     r3,r0,#18
        0x0081052c:    f8c32238    ..8"    STR      r2,[r3,#0x238]
;;;213            //platform_delay_us(1);
;;;214    
;;;215            CLK_SOURCE_REG_1 &= ~(0x03 << 15);
        0x00810530:    0482        ..      LSLS     r2,r0,#18
        0x00810532:    f8d2235c    ..\#    LDR      r2,[r2,#0x35c]
        0x00810536:    f42232c0    "..2    BIC      r2,r2,#0x18000
        0x0081053a:    f8c3235c    ..\#    STR      r2,[r3,#0x35c]
;;;216            CLK_SOURCE_REG_1 |= (ClockDiv << 15);
        0x0081053e:    0482        ..      LSLS     r2,r0,#18
        0x00810540:    f8d2235c    ..\#    LDR      r2,[r2,#0x35c]
        0x00810544:    ea4232c1    B..2    ORR      r2,r2,r1,LSL #15
        0x00810548:    f8c3235c    ..\#    STR      r2,[r3,#0x35c]
;;;217    
;;;218            //platform_delay_us(1);
;;;219            SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= SYSBLK_ACTCK_I2C0_EN_Msk;
        0x0081054c:    0482        ..      LSLS     r2,r0,#18
        0x0081054e:    f8d22238    ..8"    LDR      r2,[r2,#0x238]
        0x00810552:    f0420201    B...    ORR      r2,r2,#1
        0x00810556:    f8c32238    ..8"    STR      r2,[r3,#0x238]
        0x0081055a:    e01f        ..      B        0x81059c ; RCC_I2CClkDivConfig + 130
;;;220        }
;;;221        else if (I2Cx == I2C1)
        0x0081055c:    4a6b        kJ      LDR      r2,[pc,#428] ; [0x81070c] = 0x40015400
        0x0081055e:    4290        .B      CMP      r0,r2
        0x00810560:    d11c        ..      BNE      0x81059c ; RCC_I2CClkDivConfig + 130
;;;222        {
;;;223            SYSBLKCTRL->u_238.PERI_CLK_CTRL1 &= ~SYSBLK_ACTCK_I2C1_EN_Msk;
        0x00810562:    4a63        cJ      LDR      r2,[pc,#396] ; [0x8106f0] = 0x4000020c
        0x00810564:    322c        ,2      ADDS     r2,r2,#0x2c
        0x00810566:    6812        .h      LDR      r2,[r2,#0]
        0x00810568:    f0220204    "...    BIC      r2,r2,#4
        0x0081056c:    0503        ..      LSLS     r3,r0,#20
        0x0081056e:    f8c32238    ..8"    STR      r2,[r3,#0x238]
;;;224            //platform_delay_us(1);
;;;225    
;;;226            CLK_SOURCE_REG_1 &= ~(0x03 << 17);
        0x00810572:    0502        ..      LSLS     r2,r0,#20
        0x00810574:    f8d2235c    ..\#    LDR      r2,[r2,#0x35c]
        0x00810578:    f42222c0    ".."    BIC      r2,r2,#0x60000
        0x0081057c:    f8c3235c    ..\#    STR      r2,[r3,#0x35c]
;;;227            CLK_SOURCE_REG_1 |= (ClockDiv << 17);
        0x00810580:    0502        ..      LSLS     r2,r0,#20
        0x00810582:    f8d2235c    ..\#    LDR      r2,[r2,#0x35c]
        0x00810586:    ea424241    B.AB    ORR      r2,r2,r1,LSL #17
        0x0081058a:    f8c3235c    ..\#    STR      r2,[r3,#0x35c]
;;;228    
;;;229            //platform_delay_us(1);
;;;230            SYSBLKCTRL->u_238.PERI_CLK_CTRL1 |= SYSBLK_ACTCK_I2C1_EN_Msk;
        0x0081058e:    0502        ..      LSLS     r2,r0,#20
        0x00810590:    f8d22238    ..8"    LDR      r2,[r2,#0x238]
        0x00810594:    f0420204    B...    ORR      r2,r2,#4
        0x00810598:    f8c32238    ..8"    STR      r2,[r3,#0x238]
;;;231        }
;;;232    
;;;233        return;
;;;234    }
        0x0081059c:    4770        pG      BX       lr
    RCC_UARTClkDivConfig
;;;235    
;;;236    /**
;;;237      * @brief  UART clock divider config.
;;;238      * @param  UARTx: selected UART peripheral.
;;;239      * @param  ClockDiv: specifies the APB peripheral to gates its clock.
;;;240      *      this parameter can be one of the following values:
;;;241      *     @arg UART_CLOCK_DIV_1
;;;242      *     @arg UART_CLOCK_DIV_2
;;;243      *     @arg UART_CLOCK_DIV_4
;;;244      *     @arg UART_CLOCK_DIV_16
;;;245      * @retval None
;;;246      */
;;;247    void RCC_UARTClkDivConfig(UART_TypeDef *UARTx, uint16_t ClockDiv)
;;;248    {
;;;249        assert_param(IS_UART_DIV(ClockDiv));
;;;250    
;;;251        /* Config UART clock divider */
;;;252        if (UARTx == UART)
        0x0081059e:    4a5c        \J      LDR      r2,[pc,#368] ; [0x810710] = 0x40012000
        0x008105a0:    4290        .B      CMP      r0,r2
        0x008105a2:    d11d        ..      BNE      0x8105e0 ; RCC_UARTClkDivConfig + 66
;;;253        {
;;;254            /* disable clock first */
;;;255            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 &= ~SYSBLK_ACTCK_UART0DATA_EN_Msk;
        0x008105a4:    4a52        RJ      LDR      r2,[pc,#328] ; [0x8106f0] = 0x4000020c
        0x008105a6:    3228        (2      ADDS     r2,r2,#0x28
        0x008105a8:    6812        .h      LDR      r2,[r2,#0]
        0x008105aa:    f0220201    "...    BIC      r2,r2,#1
        0x008105ae:    0443        C.      LSLS     r3,r0,#17
        0x008105b0:    f8c32234    ..4"    STR      r2,[r3,#0x234]
;;;256            //platform_delay_us(1);
;;;257    
;;;258            CLK_SOURCE_REG_1 &= ~(0x03 << 9);
        0x008105b4:    0442        B.      LSLS     r2,r0,#17
        0x008105b6:    f8d2235c    ..\#    LDR      r2,[r2,#0x35c]
        0x008105ba:    f42262c0    "..b    BIC      r2,r2,#0x600
        0x008105be:    f8c3235c    ..\#    STR      r2,[r3,#0x35c]
;;;259            CLK_SOURCE_REG_1 |= (ClockDiv << 9);
        0x008105c2:    0442        B.      LSLS     r2,r0,#17
        0x008105c4:    f8d2235c    ..\#    LDR      r2,[r2,#0x35c]
        0x008105c8:    ea422241    B.A"    ORR      r2,r2,r1,LSL #9
        0x008105cc:    f8c3235c    ..\#    STR      r2,[r3,#0x35c]
;;;260    
;;;261            //platform_delay_us(1);
;;;262            SYSBLKCTRL->u_234.PERI_CLK_CTRL0 |= SYSBLK_ACTCK_UART0DATA_EN_Msk;
        0x008105d0:    0442        B.      LSLS     r2,r0,#17
        0x008105d2:    f8d22234    ..4"    LDR      r2,[r2,#0x234]
        0x008105d6:    f0420201    B...    ORR      r2,r2,#1
        0x008105da:    f8c32234    ..4"    STR      r2,[r3,#0x234]
        0x008105de:    e01f        ..      B        0x810620 ; RCC_UARTClkDivConfig + 130
;;;263        }
;;;264        else if (UARTx == UART1)
        0x008105e0:    4a4c        LJ      LDR      r2,[pc,#304] ; [0x810714] = 0x40011000
        0x008105e2:    4290        .B      CMP      r0,r2
        0x008105e4:    d11c        ..      BNE      0x810620 ; RCC_UARTClkDivConfig + 130
;;;265        {
;;;266            SYSBLKCTRL->u_230.CLK_CTRL &= ~SYSBLK_ACTCK_LOGUART_EN_Msk;
        0x008105e6:    4a42        BJ      LDR      r2,[pc,#264] ; [0x8106f0] = 0x4000020c
        0x008105e8:    3224        $2      ADDS     r2,r2,#0x24
        0x008105ea:    6812        .h      LDR      r2,[r2,#0]
        0x008105ec:    f4225280    "..R    BIC      r2,r2,#0x1000
        0x008105f0:    0483        ..      LSLS     r3,r0,#18
        0x008105f2:    f8c32230    ..0"    STR      r2,[r3,#0x230]
;;;267            //platform_delay_us(1);
;;;268    
;;;269            CLK_SOURCE_REG_1 &= ~(0x03 << 11);
        0x008105f6:    0482        ..      LSLS     r2,r0,#18
        0x008105f8:    f8d2235c    ..\#    LDR      r2,[r2,#0x35c]
        0x008105fc:    f42252c0    "..R    BIC      r2,r2,#0x1800
        0x00810600:    f8c3235c    ..\#    STR      r2,[r3,#0x35c]
;;;270            CLK_SOURCE_REG_1 |= (ClockDiv << 11);
        0x00810604:    0482        ..      LSLS     r2,r0,#18
        0x00810606:    f8d2235c    ..\#    LDR      r2,[r2,#0x35c]
        0x0081060a:    ea4222c1    B.."    ORR      r2,r2,r1,LSL #11
        0x0081060e:    f8c3235c    ..\#    STR      r2,[r3,#0x35c]
;;;271    
;;;272            //platform_delay_us(1);
;;;273            SYSBLKCTRL->u_230.CLK_CTRL |= SYSBLK_ACTCK_LOGUART_EN_Msk;
        0x00810612:    0482        ..      LSLS     r2,r0,#18
        0x00810614:    f8d22230    ..0"    LDR      r2,[r2,#0x230]
        0x00810618:    f4425280    B..R    ORR      r2,r2,#0x1000
        0x0081061c:    f8c32230    ..0"    STR      r2,[r3,#0x230]
;;;274        }
;;;275    
;;;276        return;
;;;277    }
        0x00810620:    4770        pG      BX       lr
    RCC_PeriClockConfig
;;;278    
;;;279    /**
;;;280      * @brief  Enables or disables the APB peripheral clock.
;;;281      * @param  APBPeriph_Clock: specifies the APB peripheral clock config.
;;;282      *      this parameter can be one of the following values(must be the same with APBPeriph):
;;;283      *     @arg APBPeriph_TIMER_CLOCK
;;;284      *     @arg APBPeriph_GDMA_CLOCK
;;;285      *     @arg APBPeriph_SPI2W_CLOCK
;;;286      *     @arg APBPeriph_KEYSCAN_CLOCK
;;;287      *     @arg APBPeriph_QDEC_CLOCK
;;;288      *     @arg APBPeriph_I2C1_CLOCK
;;;289      *     @arg APBPeriph_I2C0_CLOCK
;;;290      *     @arg APBPeriph_IR_CLOCK
;;;291      *     @arg APBPeriph_SPI1_CLOCK
;;;292      *     @arg APBPeriph_SPI0_CLOCK
;;;293      *     @arg APBPeriph_UART0_CLOCK
;;;294      *     @arg APBPeriph_UART1_CLOCK
;;;295      *     @arg APBPeriph_UART2_CLOCK
;;;296      *     @arg APBPeriph_GPIO_CLOCK
;;;297      *     @arg APBPeriph_ADC_CLOCK
;;;298      *     @arg APBPeriph_I2S0_CLOCK
;;;299      *     @arg APBPeriph_I2S1_CLOCK
;;;300      *     @arg APBPeriph_CODEC_CLOCK
;;;301      * @param  NewState: new state of the specified peripheral clock.
;;;302      *   This parameter can be: ENABLE or DISABLE.
;;;303      * @retval None
;;;304      */
;;;305    void RCC_PeriClockConfig(uint32_t APBPeriph_Clock, FunctionalState NewState)
;;;306    {
        0x00810622:    b510        ..      PUSH     {r4,lr}
        0x00810624:    460a        .F      MOV      r2,r1
;;;307        /* Check the parameters */
;;;308        assert_param(IS_APB_PERIPH_CLOCK(APBPeriph_Clock));
;;;309        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;310    
;;;311        uint32_t clkRegOff = ((APBPeriph_Clock & (0x03 << 29)) >> 29);
        0x00810626:    f3c07141    ..Aq    UBFX     r1,r0,#29,#2
;;;312    
;;;313        /* Special register handle */
;;;314        if (NewState == ENABLE)
        0x0081062a:    2a01        .*      CMP      r2,#1
        0x0081062c:    d110        ..      BNE      0x810650 ; RCC_PeriClockConfig + 46
;;;315        {
;;;316            if ((APBPeriph_Clock == APBPeriph_I2S0_CLOCK) || ((APBPeriph_Clock == APBPeriph_I2S1_CLOCK)) ||
        0x0081062e:    f5b07f90    ....    CMP      r0,#0x120
        0x00810632:    d004        ..      BEQ      0x81063e ; RCC_PeriClockConfig + 28
        0x00810634:    f5b07fa0    ....    CMP      r0,#0x140
        0x00810638:    d001        ..      BEQ      0x81063e ; RCC_PeriClockConfig + 28
;;;317                (APBPeriph_Clock == APBPeriph_CODEC_CLOCK))
        0x0081063a:    2810        .(      CMP      r0,#0x10
        0x0081063c:    d119        ..      BNE      0x810672 ; RCC_PeriClockConfig + 80
;;;318            {
;;;319                SYSBLKCTRL->u_220 |= APBPeriph_Clock;
        0x0081063e:    4b2c        ,K      LDR      r3,[pc,#176] ; [0x8106f0] = 0x4000020c
        0x00810640:    3314        .3      ADDS     r3,r3,#0x14
        0x00810642:    681b        .h      LDR      r3,[r3,#0]
        0x00810644:    4303        .C      ORRS     r3,r3,r0
        0x00810646:    f04f4480    O..D    MOV      r4,#0x40000000
        0x0081064a:    f8c43220    .. 2    STR      r3,[r4,#0x220]
        0x0081064e:    bd10        ..      POP      {r4,pc}
;;;320                return;
;;;321            }
;;;322        }
;;;323        else
;;;324        {
;;;325            if ((APBPeriph_Clock == APBPeriph_I2S0_CLOCK) || ((APBPeriph_Clock == APBPeriph_I2S1_CLOCK)) ||
        0x00810650:    f5b07f90    ....    CMP      r0,#0x120
        0x00810654:    d004        ..      BEQ      0x810660 ; RCC_PeriClockConfig + 62
        0x00810656:    f5b07fa0    ....    CMP      r0,#0x140
        0x0081065a:    d001        ..      BEQ      0x810660 ; RCC_PeriClockConfig + 62
;;;326                (APBPeriph_Clock == APBPeriph_CODEC_CLOCK))
        0x0081065c:    2810        .(      CMP      r0,#0x10
        0x0081065e:    d108        ..      BNE      0x810672 ; RCC_PeriClockConfig + 80
;;;327            {
;;;328                SYSBLKCTRL->u_220 &= ~(APBPeriph_Clock);
        0x00810660:    4b23        #K      LDR      r3,[pc,#140] ; [0x8106f0] = 0x4000020c
        0x00810662:    3314        .3      ADDS     r3,r3,#0x14
        0x00810664:    681b        .h      LDR      r3,[r3,#0]
        0x00810666:    4383        .C      BICS     r3,r3,r0
        0x00810668:    f04f4480    O..D    MOV      r4,#0x40000000
        0x0081066c:    f8c43220    .. 2    STR      r3,[r4,#0x220]
;;;329                return;
        0x00810670:    e7ed        ..      B        0x81064e ; RCC_PeriClockConfig + 44
;;;330            }
;;;331        }
;;;332    
;;;333        APBPeriph_Clock &= (~(0x03 << 29));
        0x00810672:    f02040c0     ..@    BIC      r0,r0,#0x60000000
;;;334    
;;;335        if (NewState == ENABLE)
        0x00810676:    2a01        .*      CMP      r2,#1
        0x00810678:    d11b        ..      BNE      0x8106b2 ; RCC_PeriClockConfig + 144
;;;336        {
;;;337            //enable peripheral clock
;;;338            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) |= APBPeriph_Clock;
        0x0081067a:    4b1d        .K      LDR      r3,[pc,#116] ; [0x8106f0] = 0x4000020c
        0x0081067c:    3324        $3      ADDS     r3,r3,#0x24
        0x0081067e:    eb030381    ....    ADD      r3,r3,r1,LSL #2
        0x00810682:    f8533c04    S..<    LDR      r3,[r3,#-4]
        0x00810686:    4303        .C      ORRS     r3,r3,r0
        0x00810688:    4c19        .L      LDR      r4,[pc,#100] ; [0x8106f0] = 0x4000020c
        0x0081068a:    3424        $4      ADDS     r4,r4,#0x24
        0x0081068c:    eb040481    ....    ADD      r4,r4,r1,LSL #2
        0x00810690:    f8443c04    D..<    STR      r3,[r4,#-4]
;;;339            //enable peripheral clock in sleep mode
;;;340            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) |= (APBPeriph_Clock << 1);
        0x00810694:    4b16        .K      LDR      r3,[pc,#88] ; [0x8106f0] = 0x4000020c
        0x00810696:    3324        $3      ADDS     r3,r3,#0x24
        0x00810698:    eb030381    ....    ADD      r3,r3,r1,LSL #2
        0x0081069c:    f8533c04    S..<    LDR      r3,[r3,#-4]
        0x008106a0:    ea430440    C.@.    ORR      r4,r3,r0,LSL #1
        0x008106a4:    4b12        .K      LDR      r3,[pc,#72] ; [0x8106f0] = 0x4000020c
        0x008106a6:    3324        $3      ADDS     r3,r3,#0x24
        0x008106a8:    eb030381    ....    ADD      r3,r3,r1,LSL #2
        0x008106ac:    f8434c04    C..L    STR      r4,[r3,#-4]
        0x008106b0:    e01a        ..      B        0x8106e8 ; RCC_PeriClockConfig + 198
;;;341        }
;;;342        else
;;;343        {
;;;344            //disable peripheral clock
;;;345            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) &= (~APBPeriph_Clock);
        0x008106b2:    4b0f        .K      LDR      r3,[pc,#60] ; [0x8106f0] = 0x4000020c
        0x008106b4:    3324        $3      ADDS     r3,r3,#0x24
        0x008106b6:    eb030381    ....    ADD      r3,r3,r1,LSL #2
        0x008106ba:    f8533c04    S..<    LDR      r3,[r3,#-4]
        0x008106be:    4383        .C      BICS     r3,r3,r0
        0x008106c0:    4c0b        .L      LDR      r4,[pc,#44] ; [0x8106f0] = 0x4000020c
        0x008106c2:    3424        $4      ADDS     r4,r4,#0x24
        0x008106c4:    eb040481    ....    ADD      r4,r4,r1,LSL #2
        0x008106c8:    f8443c04    D..<    STR      r3,[r4,#-4]
;;;346            //disable peripheral clock in sleep mode
;;;347            *((uint32_t *)(&(SYSBLKCTRL->u_230.CLK_CTRL)) + clkRegOff - 1) &= (~(APBPeriph_Clock << 1));
        0x008106cc:    4b08        .K      LDR      r3,[pc,#32] ; [0x8106f0] = 0x4000020c
        0x008106ce:    3324        $3      ADDS     r3,r3,#0x24
        0x008106d0:    eb030381    ....    ADD      r3,r3,r1,LSL #2
        0x008106d4:    f8533c04    S..<    LDR      r3,[r3,#-4]
        0x008106d8:    ea230440    #.@.    BIC      r4,r3,r0,LSL #1
        0x008106dc:    4b04        .K      LDR      r3,[pc,#16] ; [0x8106f0] = 0x4000020c
        0x008106de:    3324        $3      ADDS     r3,r3,#0x24
        0x008106e0:    eb030381    ....    ADD      r3,r3,r1,LSL #2
        0x008106e4:    f8434c04    C..L    STR      r4,[r3,#-4]
;;;348        }
;;;349    
;;;350        return;
        0x008106e8:    bf00        ..      NOP      
        0x008106ea:    e7b0        ..      B        0x81064e ; RCC_PeriClockConfig + 44
    $d
        0x008106ec:    60000040    @..`    DCD    1610612800
        0x008106f0:    4000020c    ...@    DCD    1073742348
        0x008106f4:    60010000    ...`    DCD    1610678272
        0x008106f8:    20004000    .@.     DCD    536887296
        0x008106fc:    40000360    `..@    DCD    1073742688
        0x00810700:    40013000    .0.@    DCD    1073819648
        0x00810704:    40013400    .4.@    DCD    1073820672
        0x00810708:    40015000    .P.@    DCD    1073827840
        0x0081070c:    40015400    .T.@    DCD    1073828864
        0x00810710:    40012000    . .@    DCD    1073815552
        0x00810714:    40011000    ...@    DCD    1073811456
    $t
    RCC_PeriFunctionConfig
;;;351    }
;;;352    
;;;353    /**
;;;354      * @brief  Enables or disables the APB peripheral clock.
;;;355      * @param  APBPeriph: specifies the APB peripheral to gates its clock.
;;;356      *      this parameter can be one of the following values:
;;;357      *     @arg APBPeriph_TIMER
;;;358      *     @arg APBPeriph_GDMA
;;;359      *     @arg APBPeriph_LCD
;;;360      *     @arg APBPeriph_SPI2W
;;;361      *     @arg APBPeriph_KEYSCAN
;;;362      *     @arg APBPeriph_QDEC
;;;363      *     @arg APBPeriph_I2C1
;;;364      *     @arg APBPeriph_I2C0
;;;365      *     @arg APBPeriph_IR
;;;366      *     @arg APBPeriph_SPI1
;;;367      *     @arg APBPeriph_SPI0
;;;368      *     @arg APBPeriph_UART0
;;;369      *     @arg APBPeriph_UART1
;;;370      *     @arg APBPeriph_UART2
;;;371      *     @arg APBPeriph_GPIO
;;;372      *     @arg APBPeriph_ADC
;;;373      *     @arg APBPeriph_I2S0
;;;374      *     @arg APBPeriph_I2S1
;;;375      *     @arg APBPeriph_CODEC
;;;376      * @param  NewState: new state of the specified peripheral clock.
;;;377      *   This parameter can be: ENABLE or DISABLE.
;;;378      * @retval None
;;;379      */
;;;380    void RCC_PeriFunctionConfig(uint32_t APBPeriph, FunctionalState NewState)
;;;381    {
        0x00810718:    b510        ..      PUSH     {r4,lr}
        0x0081071a:    460a        .F      MOV      r2,r1
;;;382        /* Check the parameters */
;;;383        assert_param(IS_APB_PERIPH(APBPeriph));
;;;384        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;385    
;;;386        uint32_t apbRegOff = ((APBPeriph & (0x03 << 26)) >> 26);
        0x0081071c:    f3c06181    ...a    UBFX     r1,r0,#26,#2
;;;387    
;;;388        /* Special register handle */
;;;389        if (NewState == ENABLE)
        0x00810720:    2a01        .*      CMP      r2,#1
        0x00810722:    d10d        ..      BNE      0x810740 ; RCC_PeriFunctionConfig + 40
;;;390        {
;;;391            if ((APBPeriph == APBPeriph_I2S0) || ((APBPeriph == APBPeriph_I2S1)) ||
        0x00810724:    2802        .(      CMP      r0,#2
        0x00810726:    d003        ..      BEQ      0x810730 ; RCC_PeriFunctionConfig + 24
        0x00810728:    2804        .(      CMP      r0,#4
        0x0081072a:    d001        ..      BEQ      0x810730 ; RCC_PeriFunctionConfig + 24
;;;392                (APBPeriph == APBPeriph_CODEC))
        0x0081072c:    2801        .(      CMP      r0,#1
        0x0081072e:    d115        ..      BNE      0x81075c ; RCC_PeriFunctionConfig + 68
;;;393            {
;;;394                SYSBLKCTRL->u_220 |= APBPeriph;
        0x00810730:    4b17        .K      LDR      r3,[pc,#92] ; [0x810790] = 0x40000220
        0x00810732:    681b        .h      LDR      r3,[r3,#0]
        0x00810734:    4303        .C      ORRS     r3,r3,r0
        0x00810736:    f04f4480    O..D    MOV      r4,#0x40000000
        0x0081073a:    f8c43220    .. 2    STR      r3,[r4,#0x220]
        0x0081073e:    bd10        ..      POP      {r4,pc}
;;;395                return;
;;;396            }
;;;397        }
;;;398        else
;;;399        {
;;;400            if ((APBPeriph == APBPeriph_I2S0) || ((APBPeriph == APBPeriph_I2S1)) ||
        0x00810740:    2802        .(      CMP      r0,#2
        0x00810742:    d003        ..      BEQ      0x81074c ; RCC_PeriFunctionConfig + 52
        0x00810744:    2804        .(      CMP      r0,#4
        0x00810746:    d001        ..      BEQ      0x81074c ; RCC_PeriFunctionConfig + 52
;;;401                (APBPeriph == APBPeriph_CODEC))
        0x00810748:    2801        .(      CMP      r0,#1
        0x0081074a:    d107        ..      BNE      0x81075c ; RCC_PeriFunctionConfig + 68
;;;402            {
;;;403                SYSBLKCTRL->u_220 &= ~(APBPeriph);
        0x0081074c:    4b10        .K      LDR      r3,[pc,#64] ; [0x810790] = 0x40000220
        0x0081074e:    681b        .h      LDR      r3,[r3,#0]
        0x00810750:    4383        .C      BICS     r3,r3,r0
        0x00810752:    f04f4480    O..D    MOV      r4,#0x40000000
        0x00810756:    f8c43220    .. 2    STR      r3,[r4,#0x220]
;;;404                return;
        0x0081075a:    e7f0        ..      B        0x81073e ; RCC_PeriFunctionConfig + 38
;;;405            }
;;;406        }
;;;407    
;;;408        /* clear flag */
;;;409        APBPeriph &= (~(0x03 << 26));
        0x0081075c:    f0206040     .@`    BIC      r0,r0,#0xc000000
;;;410    
;;;411        if (NewState == ENABLE)
        0x00810760:    2a01        .*      CMP      r2,#1
        0x00810762:    d109        ..      BNE      0x810778 ; RCC_PeriFunctionConfig + 96
;;;412        {
;;;413            //enable peripheral
;;;414            *((uint32_t *)(&(SYSBLKCTRL->u_210.SOC_FUNC_EN)) + apbRegOff) |= APBPeriph;
        0x00810764:    4b0a        .K      LDR      r3,[pc,#40] ; [0x810790] = 0x40000220
        0x00810766:    3b10        .;      SUBS     r3,r3,#0x10
        0x00810768:    f8533021    S.!0    LDR      r3,[r3,r1,LSL #2]
        0x0081076c:    4303        .C      ORRS     r3,r3,r0
        0x0081076e:    4c08        .L      LDR      r4,[pc,#32] ; [0x810790] = 0x40000220
        0x00810770:    3c10        .<      SUBS     r4,r4,#0x10
        0x00810772:    f8443021    D.!0    STR      r3,[r4,r1,LSL #2]
        0x00810776:    e008        ..      B        0x81078a ; RCC_PeriFunctionConfig + 114
;;;415        }
;;;416        else
;;;417        {
;;;418            //disable peripheral
;;;419            *((uint32_t *)(&(SYSBLKCTRL->u_210.SOC_FUNC_EN)) + apbRegOff) &= (~APBPeriph);
        0x00810778:    4b05        .K      LDR      r3,[pc,#20] ; [0x810790] = 0x40000220
        0x0081077a:    3b10        .;      SUBS     r3,r3,#0x10
        0x0081077c:    f8533021    S.!0    LDR      r3,[r3,r1,LSL #2]
        0x00810780:    4383        .C      BICS     r3,r3,r0
        0x00810782:    4c03        .L      LDR      r4,[pc,#12] ; [0x810790] = 0x40000220
        0x00810784:    3c10        .<      SUBS     r4,r4,#0x10
        0x00810786:    f8443021    D.!0    STR      r3,[r4,r1,LSL #2]
;;;420        }
;;;421    
;;;422        return;
        0x0081078a:    bf00        ..      NOP      
        0x0081078c:    e7d7        ..      B        0x81073e ; RCC_PeriFunctionConfig + 38
    $d
        0x0081078e:    0000        ..      DCW    0
        0x00810790:    40000220     ..@    DCD    1073742368
    $t
    .text
    GPIO_DeInit
;;; .\..\..\..\src\mcu\peripheral\rtl876x_gpio.c
;;;32     {
        0x00810794:    b510        ..      PUSH     {r4,lr}
;;;33         RCC_PeriphClockCmd(APBPeriph_GPIO, APBPeriph_GPIO_CLOCK, DISABLE);
        0x00810796:    2200        ."      MOVS     r2,#0
        0x00810798:    f04f5104    O..Q    MOV      r1,#0x21000000
        0x0081079c:    4876        vH      LDR      r0,[pc,#472] ; [0x810978] = 0xc000100
        0x0081079e:    f7fffdab    ....    BL       RCC_PeriphClockCmd ; 0x8102f8
;;;34     }
        0x008107a2:    bd10        ..      POP      {r4,pc}
    GPIO_Init
;;;35     
;;;36     /**
;;;37       * @brief  Initializes the GPIO peripheral according to the specified
;;;38       *         parameters in the GPIO_InitStruct.
;;;39       * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
;;;40       *         contains the configuration information for the specified GPIO peripheral.
;;;41       * @retval None
;;;42       */
;;;43     void GPIO_Init(GPIO_InitTypeDef *GPIO_InitStruct)
;;;44     {
;;;45         /* Check the parameters */
;;;46         assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
;;;47         assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
;;;48         assert_param(IS_GPIOIT_LEVEL_TYPE(GPIO_InitStruct->GPIO_ITTrigger));
;;;49         assert_param(IS_GPIOIT_POLARITY_TYPE(GPIO_InitStruct->GPIO_ITPolarity));
;;;50         assert_param(IS_GPIOIT_DEBOUNCE_TYPE(GPIO_InitStruct->GPIO_ITDebounce));
;;;51     
;;;52         /* GPIO configure */
;;;53         if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT)
        0x008107a4:    7901        .y      LDRB     r1,[r0,#4]
        0x008107a6:    2901        .)      CMP      r1,#1
        0x008107a8:    d115        ..      BNE      0x8107d6 ; GPIO_Init + 50
;;;54         {
;;;55             GPIO->DATADIR |= GPIO_InitStruct->GPIO_Pin;
        0x008107aa:    4974        tI      LDR      r1,[pc,#464] ; [0x81097c] = 0x40001000
        0x008107ac:    6849        Ih      LDR      r1,[r1,#4]
        0x008107ae:    6802        .h      LDR      r2,[r0,#0]
        0x008107b0:    4311        .C      ORRS     r1,r1,r2
        0x008107b2:    4a72        rJ      LDR      r2,[pc,#456] ; [0x81097c] = 0x40001000
        0x008107b4:    6051        Q`      STR      r1,[r2,#4]
;;;56     
;;;57             if (GPIO_InitStruct->GPIO_ControlMode == GPIO_SOFTWARE_MODE)
        0x008107b6:    7a41        Az      LDRB     r1,[r0,#9]
        0x008107b8:    b931        1.      CBNZ     r1,0x8107c8 ; GPIO_Init + 36
;;;58             {
;;;59                 /* Config GPIO control software mode */
;;;60                 GPIO->DATASRC &= (~GPIO_InitStruct->GPIO_Pin);
        0x008107ba:    4611        .F      MOV      r1,r2
        0x008107bc:    6889        .h      LDR      r1,[r1,#8]
        0x008107be:    6802        .h      LDR      r2,[r0,#0]
        0x008107c0:    4391        .C      BICS     r1,r1,r2
        0x008107c2:    4a6e        nJ      LDR      r2,[pc,#440] ; [0x81097c] = 0x40001000
        0x008107c4:    6091        .`      STR      r1,[r2,#8]
        0x008107c6:    e063        c.      B        0x810890 ; GPIO_Init + 236
;;;61             }
;;;62             else
;;;63             {
;;;64                 /* Config GPIO hardware control mode */
;;;65                 GPIO->DATASRC |= (GPIO_InitStruct->GPIO_Pin);
        0x008107c8:    496c        lI      LDR      r1,[pc,#432] ; [0x81097c] = 0x40001000
        0x008107ca:    6889        .h      LDR      r1,[r1,#8]
        0x008107cc:    6802        .h      LDR      r2,[r0,#0]
        0x008107ce:    4311        .C      ORRS     r1,r1,r2
        0x008107d0:    4a6a        jJ      LDR      r2,[pc,#424] ; [0x81097c] = 0x40001000
        0x008107d2:    6091        .`      STR      r1,[r2,#8]
        0x008107d4:    e05c        \.      B        0x810890 ; GPIO_Init + 236
;;;66             }
;;;67     
;;;68         }
;;;69         else
;;;70         {
;;;71             /*Configure GPIO input mode */
;;;72             GPIO->DATADIR = GPIO->DATADIR & (~GPIO_InitStruct->GPIO_Pin);
        0x008107d6:    4969        iI      LDR      r1,[pc,#420] ; [0x81097c] = 0x40001000
        0x008107d8:    6849        Ih      LDR      r1,[r1,#4]
        0x008107da:    6802        .h      LDR      r2,[r0,#0]
        0x008107dc:    4391        .C      BICS     r1,r1,r2
        0x008107de:    4a67        gJ      LDR      r2,[pc,#412] ; [0x81097c] = 0x40001000
        0x008107e0:    6051        Q`      STR      r1,[r2,#4]
;;;73     
;;;74             if (GPIO_InitStruct->GPIO_ITCmd == ENABLE)
        0x008107e2:    7941        Ay      LDRB     r1,[r0,#5]
        0x008107e4:    2901        .)      CMP      r1,#1
        0x008107e6:    d153        S.      BNE      0x810890 ; GPIO_Init + 236
;;;75             {
;;;76     
;;;77                 GPIO->INTMASK = ~GPIO_Pin_All;
        0x008107e8:    2100        .!      MOVS     r1,#0
        0x008107ea:    6351        Qc      STR      r1,[r2,#0x34]
;;;78     
;;;79                 /* configure GPIO interrupt trigger type */
;;;80                 if (GPIO_InitStruct->GPIO_ITTrigger == GPIO_INT_Trigger_LEVEL)
        0x008107ec:    7981        .y      LDRB     r1,[r0,#6]
        0x008107ee:    b961        a.      CBNZ     r1,0x81080a ; GPIO_Init + 102
;;;81                 {
;;;82                     GPIO->INTTYPE = GPIO->INTTYPE & (~GPIO_InitStruct->GPIO_Pin);
        0x008107f0:    4611        .F      MOV      r1,r2
        0x008107f2:    6b89        .k      LDR      r1,[r1,#0x38]
        0x008107f4:    6802        .h      LDR      r2,[r0,#0]
        0x008107f6:    4391        .C      BICS     r1,r1,r2
        0x008107f8:    4a60        `J      LDR      r2,[pc,#384] ; [0x81097c] = 0x40001000
        0x008107fa:    6391        .c      STR      r1,[r2,#0x38]
;;;83     
;;;84                     /* Level-sensitive synchronization enable register */
;;;85                     GPIO->LSSYNC |= GPIO_InitStruct->GPIO_Pin;
        0x008107fc:    4611        .F      MOV      r1,r2
        0x008107fe:    6e09        .n      LDR      r1,[r1,#0x60]
        0x00810800:    6802        .h      LDR      r2,[r0,#0]
        0x00810802:    4311        .C      ORRS     r1,r1,r2
        0x00810804:    4a5d        ]J      LDR      r2,[pc,#372] ; [0x81097c] = 0x40001000
        0x00810806:    6611        .f      STR      r1,[r2,#0x60]
        0x00810808:    e010        ..      B        0x81082c ; GPIO_Init + 136
;;;86                 }
;;;87                 else if (GPIO_InitStruct->GPIO_ITTrigger == GPIO_INT_Trigger_EDGE)
        0x0081080a:    7981        .y      LDRB     r1,[r0,#6]
        0x0081080c:    2901        .)      CMP      r1,#1
        0x0081080e:    d107        ..      BNE      0x810820 ; GPIO_Init + 124
;;;88                 {
;;;89                     GPIO->INTTYPE = (GPIO->INTTYPE & (~GPIO_InitStruct->GPIO_Pin))
        0x00810810:    495a        ZI      LDR      r1,[pc,#360] ; [0x81097c] = 0x40001000
        0x00810812:    6b89        .k      LDR      r1,[r1,#0x38]
        0x00810814:    6802        .h      LDR      r2,[r0,#0]
        0x00810816:    4391        .C      BICS     r1,r1,r2
        0x00810818:    4311        .C      ORRS     r1,r1,r2
        0x0081081a:    4a58        XJ      LDR      r2,[pc,#352] ; [0x81097c] = 0x40001000
        0x0081081c:    6391        .c      STR      r1,[r2,#0x38]
        0x0081081e:    e005        ..      B        0x81082c ; GPIO_Init + 136
;;;90                                     | GPIO_InitStruct->GPIO_Pin;
;;;91                 }
;;;92                 else
;;;93                 {
;;;94                     GPIO->INTBOTHEDGE |= GPIO_InitStruct->GPIO_Pin;
        0x00810820:    4956        VI      LDR      r1,[pc,#344] ; [0x81097c] = 0x40001000
        0x00810822:    6e89        .n      LDR      r1,[r1,#0x68]
        0x00810824:    6802        .h      LDR      r2,[r0,#0]
        0x00810826:    4311        .C      ORRS     r1,r1,r2
        0x00810828:    4a54        TJ      LDR      r2,[pc,#336] ; [0x81097c] = 0x40001000
        0x0081082a:    6691        .f      STR      r1,[r2,#0x68]
;;;95                 }
;;;96     
;;;97                 /* configure Interrupt polarity register */
;;;98                 if (GPIO_InitStruct->GPIO_ITPolarity == GPIO_INT_POLARITY_ACTIVE_LOW)
        0x0081082c:    79c1        .y      LDRB     r1,[r0,#7]
        0x0081082e:    b931        1.      CBNZ     r1,0x81083e ; GPIO_Init + 154
;;;99                 {
;;;100                    GPIO->INTPOLARITY = GPIO->INTPOLARITY & (~GPIO_InitStruct->GPIO_Pin);
        0x00810830:    4952        RI      LDR      r1,[pc,#328] ; [0x81097c] = 0x40001000
        0x00810832:    6bc9        .k      LDR      r1,[r1,#0x3c]
        0x00810834:    6802        .h      LDR      r2,[r0,#0]
        0x00810836:    4391        .C      BICS     r1,r1,r2
        0x00810838:    4a50        PJ      LDR      r2,[pc,#320] ; [0x81097c] = 0x40001000
        0x0081083a:    63d1        .c      STR      r1,[r2,#0x3c]
        0x0081083c:    e006        ..      B        0x81084c ; GPIO_Init + 168
;;;101                }
;;;102                else
;;;103                {
;;;104                    GPIO->INTPOLARITY = (GPIO->INTPOLARITY & (~GPIO_InitStruct->GPIO_Pin))
        0x0081083e:    494f        OI      LDR      r1,[pc,#316] ; [0x81097c] = 0x40001000
        0x00810840:    6bc9        .k      LDR      r1,[r1,#0x3c]
        0x00810842:    6802        .h      LDR      r2,[r0,#0]
        0x00810844:    4391        .C      BICS     r1,r1,r2
        0x00810846:    4311        .C      ORRS     r1,r1,r2
        0x00810848:    4a4c        LJ      LDR      r2,[pc,#304] ; [0x81097c] = 0x40001000
        0x0081084a:    63d1        .c      STR      r1,[r2,#0x3c]
;;;105                                        | GPIO_InitStruct->GPIO_Pin;
;;;106                }
;;;107                /* Configure Debounce enable register */
;;;108                if (GPIO_InitStruct->GPIO_ITDebounce == GPIO_INT_DEBOUNCE_DISABLE)
        0x0081084c:    7a01        .z      LDRB     r1,[r0,#8]
        0x0081084e:    b931        1.      CBNZ     r1,0x81085e ; GPIO_Init + 186
;;;109                {
;;;110                    GPIO->DEBOUNCE = GPIO->DEBOUNCE & (~GPIO_InitStruct->GPIO_Pin);
        0x00810850:    494a        JI      LDR      r1,[pc,#296] ; [0x81097c] = 0x40001000
        0x00810852:    6c89        .l      LDR      r1,[r1,#0x48]
        0x00810854:    6802        .h      LDR      r2,[r0,#0]
        0x00810856:    4391        .C      BICS     r1,r1,r2
        0x00810858:    4a48        HJ      LDR      r2,[pc,#288] ; [0x81097c] = 0x40001000
        0x0081085a:    6491        .d      STR      r1,[r2,#0x48]
        0x0081085c:    e018        ..      B        0x810890 ; GPIO_Init + 236
;;;111                }
;;;112                else
;;;113                {
;;;114                    GPIO->DEBOUNCE = (GPIO->DEBOUNCE & (~GPIO_InitStruct->GPIO_Pin))
        0x0081085e:    4947        GI      LDR      r1,[pc,#284] ; [0x81097c] = 0x40001000
        0x00810860:    6c89        .l      LDR      r1,[r1,#0x48]
        0x00810862:    6802        .h      LDR      r2,[r0,#0]
        0x00810864:    4391        .C      BICS     r1,r1,r2
        0x00810866:    4311        .C      ORRS     r1,r1,r2
        0x00810868:    4a44        DJ      LDR      r2,[pc,#272] ; [0x81097c] = 0x40001000
        0x0081086a:    6491        .d      STR      r1,[r2,#0x48]
;;;115                                     | GPIO_InitStruct->GPIO_Pin;
;;;116    
;;;117    #ifdef _IS_ASIC_
;;;118                    /* Config debounce time , default debounce DIV is 14*/
;;;119                    GPIO_DBCLK_DIV = (((0xd) << 8) | (1 << 12));
;;;120                    GPIO_DBCLK_DIV |= ((((GPIO_InitStruct->GPIO_DebounceTime) * (GPIO_CLOCK_SOURCE_KHZ) >>
;;;121                                         (14)) - 1) & 0xff);
;;;122    #else
;;;123                    /* Config debounce time , default debounce DIV is 13*/
;;;124                    GPIO_DBCLK_DIV = (((0x3) << 10) | (1 << 12));
        0x0081086c:    f44f51e0    O..Q    MOV      r1,#0x1c00
        0x00810870:    4a43        CJ      LDR      r2,[pc,#268] ; [0x810980] = 0x40000344
        0x00810872:    6011        .`      STR      r1,[r2,#0]
;;;125                    GPIO_DBCLK_DIV |= ((((GPIO_InitStruct->GPIO_DebounceTime) * (GPIO_CLOCK_SOURCE_KHZ) >>
        0x00810874:    0711        ..      LSLS     r1,r2,#28
        0x00810876:    f8d11344    ..D.    LDR      r1,[r1,#0x344]
        0x0081087a:    f6446320    D. c    MOV      r3,#0x4e20
        0x0081087e:    68c2        .h      LDR      r2,[r0,#0xc]
        0x00810880:    435a        ZC      MULS     r2,r3,r2
        0x00810882:    2301        .#      MOVS     r3,#1
        0x00810884:    ebc33252    ..R2    RSB      r2,r3,r2,LSR #13
        0x00810888:    b2d2        ..      UXTB     r2,r2
        0x0081088a:    4311        .C      ORRS     r1,r1,r2
        0x0081088c:    4a3c        <J      LDR      r2,[pc,#240] ; [0x810980] = 0x40000344
        0x0081088e:    6011        .`      STR      r1,[r2,#0]
;;;126                                         (13)) - 1) & 0xff);
;;;127    #endif
;;;128                }
;;;129    
;;;130                /* Configure Interrupt enable register */
;;;131                //GPIO->INTEN |= GPIO_InitStruct->GPIO_Pin;
;;;132            }
;;;133        }
;;;134    }
        0x00810890:    4770        pG      BX       lr
    GPIO_StructInit
;;;135    
;;;136    /**
;;;137      * @brief    Fills each GPIO_InitStruct member with its default value.
;;;138      * @param  GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure which will
;;;139      *    be initialized.
;;;140      * @retval None
;;;141      */
;;;142    void GPIO_StructInit(GPIO_InitTypeDef *GPIO_InitStruct)
;;;143    {
;;;144        /* Reset GPIO init structure parameters values */
;;;145        GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
        0x00810892:    f04f31ff    O..1    MOV      r1,#0xffffffff
        0x00810896:    6001        .`      STR      r1,[r0,#0]
;;;146        GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
        0x00810898:    2100        .!      MOVS     r1,#0
        0x0081089a:    7101        .q      STRB     r1,[r0,#4]
;;;147        GPIO_InitStruct->GPIO_ITCmd = DISABLE;
        0x0081089c:    7141        Aq      STRB     r1,[r0,#5]
;;;148        GPIO_InitStruct->GPIO_ITTrigger = GPIO_INT_Trigger_LEVEL;
        0x0081089e:    7181        .q      STRB     r1,[r0,#6]
;;;149        GPIO_InitStruct->GPIO_ITPolarity = GPIO_INT_POLARITY_ACTIVE_LOW;
        0x008108a0:    71c1        .q      STRB     r1,[r0,#7]
;;;150        GPIO_InitStruct->GPIO_ITDebounce = GPIO_INT_DEBOUNCE_DISABLE;
        0x008108a2:    7201        .r      STRB     r1,[r0,#8]
;;;151        GPIO_InitStruct->GPIO_ControlMode = GPIO_SOFTWARE_MODE;
        0x008108a4:    7241        Ar      STRB     r1,[r0,#9]
;;;152        GPIO_InitStruct->GPIO_DebounceTime = 20;                 /* ms , can be 1~64 ms */
        0x008108a6:    2114        .!      MOVS     r1,#0x14
        0x008108a8:    60c1        .`      STR      r1,[r0,#0xc]
;;;153    }
        0x008108aa:    4770        pG      BX       lr
    GPIO_INTConfig
;;;154    
;;;155    /**
;;;156      * @brief enable the specified GPIO interrupt.
;;;157      * @param  GPIO_Pin_x: where x can be 0 or 31.
;;;158      * @retval None
;;;159      */
;;;160    void GPIO_INTConfig(uint32_t GPIO_Pin, FunctionalState NewState)
;;;161    {
;;;162        /* Check the parameters */
;;;163        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;164        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;165    
;;;166        if (NewState != DISABLE)
        0x008108ac:    b129        ).      CBZ      r1,0x8108ba ; GPIO_INTConfig + 14
;;;167        {
;;;168            /* Enable the selected GPIO pin interrupts */
;;;169            GPIO->INTEN |= GPIO_Pin;
        0x008108ae:    4a33        3J      LDR      r2,[pc,#204] ; [0x81097c] = 0x40001000
        0x008108b0:    6b12        .k      LDR      r2,[r2,#0x30]
        0x008108b2:    4302        .C      ORRS     r2,r2,r0
        0x008108b4:    4b31        1K      LDR      r3,[pc,#196] ; [0x81097c] = 0x40001000
        0x008108b6:    631a        .c      STR      r2,[r3,#0x30]
        0x008108b8:    e004        ..      B        0x8108c4 ; GPIO_INTConfig + 24
;;;170        }
;;;171        else
;;;172        {
;;;173            /* Disable the selected GPIO pin interrupts */
;;;174            GPIO->INTEN &= ~GPIO_Pin;
        0x008108ba:    4a30        0J      LDR      r2,[pc,#192] ; [0x81097c] = 0x40001000
        0x008108bc:    6b12        .k      LDR      r2,[r2,#0x30]
        0x008108be:    4382        .C      BICS     r2,r2,r0
        0x008108c0:    4b2e        .K      LDR      r3,[pc,#184] ; [0x81097c] = 0x40001000
        0x008108c2:    631a        .c      STR      r2,[r3,#0x30]
;;;175        }
;;;176    }
        0x008108c4:    4770        pG      BX       lr
    GPIO_ClearINTPendingBit
;;;177    
;;;178    /**
;;;179      * @brief clear the specified GPIO interrupt.
;;;180      * @param  GPIO_Pin_x: where x can be 0 or 31.
;;;181      * @retval None
;;;182      */
;;;183    void GPIO_ClearINTPendingBit(uint32_t GPIO_Pin)
;;;184    {
;;;185        /* Check the parameters */
;;;186        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;187    
;;;188        GPIO->INTCLR = GPIO_Pin;
        0x008108c6:    492d        -I      LDR      r1,[pc,#180] ; [0x81097c] = 0x40001000
        0x008108c8:    64c8        .d      STR      r0,[r1,#0x4c]
;;;189    }
        0x008108ca:    4770        pG      BX       lr
    GPIO_MaskINTConfig
;;;190    
;;;191    /**
;;;192      * @brief mask the specified GPIO interrupt.
;;;193      * @param  GPIO_Pin_x: where x can be 0 or 31.
;;;194      * @retval None
;;;195      */
;;;196    void GPIO_MaskINTConfig(uint32_t GPIO_Pin, FunctionalState NewState)
;;;197    {
;;;198        /* Check the parameters */
;;;199        assert_param(IS_GPIO_PIN(GPIO_Pin));
;;;200        assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;201    
;;;202        if (NewState != DISABLE)
        0x008108cc:    b129        ).      CBZ      r1,0x8108da ; GPIO_MaskINTConfig + 14
;;;203        {
;;;204            GPIO->INTMASK |= GPIO_Pin;
        0x008108ce:    4a2b        +J      LDR      r2,[pc,#172] ; [0x81097c] = 0x40001000
        0x008108d0:    6b52        Rk      LDR      r2,[r2,#0x34]
        0x008108d2:    4302        .C      ORRS     r2,r2,r0
        0x008108d4:    4b29        )K      LDR      r3,[pc,#164] ; [0x81097c] = 0x40001000
        0x008108d6:    635a        Zc      STR      r2,[r3,#0x34]
        0x008108d8:    e004        ..      B        0x8108e4 ; GPIO_MaskINTConfig + 24
;;;205        }
;;;206        else
;;;207        {
;;;208            GPIO->INTMASK &= ~(GPIO_Pin);
        0x008108da:    4a28        (J      LDR      r2,[pc,#160] ; [0x81097c] = 0x40001000
        0x008108dc:    6b52        Rk      LDR      r2,[r2,#0x34]
        0x008108de:    4382        .C      BICS     r2,r2,r0
        0x008108e0:    4b26        &K      LDR      r3,[pc,#152] ; [0x81097c] = 0x40001000
        0x008108e2:    635a        Zc      STR      r2,[r3,#0x34]
;;;209        }
;;;210    }
        0x008108e4:    4770        pG      BX       lr
    GPIO_GetPin
;;;211    
;;;212    /**
;;;213      * @brief get the specified GPIO pin.
;;;214      * @param  Pin_num: This parameter is from ADC_0 to P4_1, please refer to rtl876x.h "Pin_Number" part.
;;;215      * @retval  GPIO pin for GPIO initialization.
;;;216      */
;;;217    uint32_t GPIO_GetPin(uint8_t Pin_num)
;;;218    {
        0x008108e6:    4601        .F      MOV      r1,r0
;;;219        /* Check the parameters */
;;;220        assert_param(IS_PIN_NUM(Pin_num));
;;;221    
;;;222        if (Pin_num <= P3_6)
        0x008108e8:    291e        .)      CMP      r1,#0x1e
        0x008108ea:    dc02        ..      BGT      0x8108f2 ; GPIO_GetPin + 12
;;;223        {
;;;224            return  BIT(Pin_num);
        0x008108ec:    2001        .       MOVS     r0,#1
        0x008108ee:    4088        .@      LSLS     r0,r0,r1
        0x008108f0:    4770        pG      BX       lr
;;;225        }
;;;226        else if ((Pin_num <= P4_3) && (Pin_num >= P4_0))
        0x008108f2:    2923        #)      CMP      r1,#0x23
        0x008108f4:    dc06        ..      BGT      0x810904 ; GPIO_GetPin + 30
        0x008108f6:    2920         )      CMP      r1,#0x20
        0x008108f8:    db04        ..      BLT      0x810904 ; GPIO_GetPin + 30
;;;227        {
;;;228            return BIT(Pin_num - 4);
        0x008108fa:    1f08        ..      SUBS     r0,r1,#4
        0x008108fc:    2201        ."      MOVS     r2,#1
        0x008108fe:    fa02f000    ....    LSL      r0,r2,r0
        0x00810902:    e7f5        ..      B        0x8108f0 ; GPIO_GetPin + 10
;;;229        }
;;;230        else if ((Pin_num == H_0) || (Pin_num == H_1) || (Pin_num == H_2))
        0x00810904:    2924        $)      CMP      r1,#0x24
        0x00810906:    d003        ..      BEQ      0x810910 ; GPIO_GetPin + 42
        0x00810908:    2925        %)      CMP      r1,#0x25
        0x0081090a:    d001        ..      BEQ      0x810910 ; GPIO_GetPin + 42
        0x0081090c:    2926        &)      CMP      r1,#0x26
        0x0081090e:    d105        ..      BNE      0x81091c ; GPIO_GetPin + 54
;;;231        {
;;;232            return BIT(Pin_num - 11);
        0x00810910:    f1a1000b    ....    SUB      r0,r1,#0xb
        0x00810914:    2201        ."      MOVS     r2,#1
        0x00810916:    fa02f000    ....    LSL      r0,r2,r0
        0x0081091a:    e7e9        ..      B        0x8108f0 ; GPIO_GetPin + 10
;;;233        }
;;;234    
;;;235        return 0xFF;
        0x0081091c:    20ff        .       MOVS     r0,#0xff
        0x0081091e:    e7e7        ..      B        0x8108f0 ; GPIO_GetPin + 10
    GPIO_GetNum
;;;236    }
;;;237    
;;;238    /**
;;;239      * @brief get the specified GPIO pin number.
;;;240      * @param  Pin_num: This parameter is from ADC_0 to P4_1, please refer to rtl876x.h "Pin_Number" part.
;;;241      * @retval  GPIO pin number.
;;;242      */
;;;243    uint8_t GPIO_GetNum(uint8_t Pin_num)
;;;244    {
        0x00810920:    4601        .F      MOV      r1,r0
;;;245        /* Check the parameters */
;;;246        assert_param(IS_PIN_NUM(Pin_num));
;;;247    
;;;248        if (Pin_num <= P3_6)
        0x00810922:    291e        .)      CMP      r1,#0x1e
        0x00810924:    dc01        ..      BGT      0x81092a ; GPIO_GetNum + 10
;;;249        {
;;;250            return (Pin_num);
        0x00810926:    4608        .F      MOV      r0,r1
        0x00810928:    4770        pG      BX       lr
;;;251        }
;;;252        else if ((Pin_num <= P4_3) && (Pin_num >= P4_0))
        0x0081092a:    2923        #)      CMP      r1,#0x23
        0x0081092c:    dc04        ..      BGT      0x810938 ; GPIO_GetNum + 24
        0x0081092e:    2920         )      CMP      r1,#0x20
        0x00810930:    db02        ..      BLT      0x810938 ; GPIO_GetNum + 24
;;;253        {
;;;254            return (Pin_num - 4);
        0x00810932:    1f08        ..      SUBS     r0,r1,#4
        0x00810934:    b2c0        ..      UXTB     r0,r0
        0x00810936:    e7f7        ..      B        0x810928 ; GPIO_GetNum + 8
;;;255        }
;;;256        else if ((Pin_num == H_0) || (Pin_num == H_1) || (Pin_num == H_2))
        0x00810938:    2924        $)      CMP      r1,#0x24
        0x0081093a:    d003        ..      BEQ      0x810944 ; GPIO_GetNum + 36
        0x0081093c:    2925        %)      CMP      r1,#0x25
        0x0081093e:    d001        ..      BEQ      0x810944 ; GPIO_GetNum + 36
        0x00810940:    2926        &)      CMP      r1,#0x26
        0x00810942:    d103        ..      BNE      0x81094c ; GPIO_GetNum + 44
;;;257        {
;;;258            return (Pin_num - 11);
        0x00810944:    f1a1000b    ....    SUB      r0,r1,#0xb
        0x00810948:    b2c0        ..      UXTB     r0,r0
        0x0081094a:    e7ed        ..      B        0x810928 ; GPIO_GetNum + 8
;;;259        }
;;;260    
;;;261        return 0xFF;
        0x0081094c:    20ff        .       MOVS     r0,#0xff
        0x0081094e:    e7eb        ..      B        0x810928 ; GPIO_GetNum + 8
    GPIO_DBClkCmd
;;;262    }
;;;263    
;;;264    /**
;;;265      * @brief get the specified GPIO pin number.
;;;266      * @param  Pin_num: This parameter is from ADC_0 to P4_1, please refer to rtl876x.h "Pin_Number" part.
;;;267      * @retval  GPIO pin number.
;;;268      */
;;;269    void GPIO_DBClkCmd(FunctionalState NewState)
;;;270    {
;;;271        if (NewState != DISABLE)
        0x00810950:    b140        @.      CBZ      r0,0x810964 ; GPIO_DBClkCmd + 20
;;;272        {
;;;273            GPIO_DBCLK_DIV |= BIT12;
        0x00810952:    490b        .I      LDR      r1,[pc,#44] ; [0x810980] = 0x40000344
        0x00810954:    6809        .h      LDR      r1,[r1,#0]
        0x00810956:    f4415180    A..Q    ORR      r1,r1,#0x1000
        0x0081095a:    f04f4280    O..B    MOV      r2,#0x40000000
        0x0081095e:    f8c21344    ..D.    STR      r1,[r2,#0x344]
        0x00810962:    e007        ..      B        0x810974 ; GPIO_DBClkCmd + 36
;;;274        }
;;;275        else
;;;276        {
;;;277            GPIO_DBCLK_DIV &= ~BIT12;
        0x00810964:    4906        .I      LDR      r1,[pc,#24] ; [0x810980] = 0x40000344
        0x00810966:    6809        .h      LDR      r1,[r1,#0]
        0x00810968:    f4215180    !..Q    BIC      r1,r1,#0x1000
        0x0081096c:    f04f4280    O..B    MOV      r2,#0x40000000
        0x00810970:    f8c21344    ..D.    STR      r1,[r2,#0x344]
;;;278        }
;;;279    }
        0x00810974:    4770        pG      BX       lr
    $d
        0x00810976:    0000        ..      DCW    0
        0x00810978:    0c000100    ....    DCD    201326848
        0x0081097c:    40001000    ...@    DCD    1073745920
        0x00810980:    40000344    D..@    DCD    1073742660
    $t
    .text
    gap_lib_handle_btif_msg
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (38)
        0x00810984:    b570        p.      PUSH     {r4-r6,lr}
        0x00810986:    4604        .F      MOV      r4,r0
        0x00810988:    2001        .       MOVS     r0,#1
        0x0081098a:    7008        .p      STRB     r0,[r1,#0]
        0x0081098c:    8860        `.      LDRH     r0,[r4,#2]
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (39)
        0x0081098e:    2500        .%      MOVS     r5,#0
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (42)
        0x00810990:    f5b07f97    ....    CMP      r0,#0x12e
        0x00810994:    d01a        ..      BEQ      0x8109cc ; gap_lib_handle_btif_msg + 72
        0x00810996:    dc06        ..      BGT      0x8109a6 ; gap_lib_handle_btif_msg + 34
        0x00810998:    280e        .(      CMP      r0,#0xe
        0x0081099a:    d00b        ..      BEQ      0x8109b4 ; gap_lib_handle_btif_msg + 48
        0x0081099c:    280f        .(      CMP      r0,#0xf
        0x0081099e:    d011        ..      BEQ      0x8109c4 ; gap_lib_handle_btif_msg + 64
        0x008109a0:    2822        "(      CMP      r0,#0x22
        0x008109a2:    d126        &.      BNE      0x8109f2 ; gap_lib_handle_btif_msg + 110
        0x008109a4:    e00a        ..      B        0x8109bc ; gap_lib_handle_btif_msg + 56
        0x008109a6:    f5a07080    ...p    SUB      r0,r0,#0x100
        0x008109aa:    382f        /8      SUBS     r0,r0,#0x2f
        0x008109ac:    d016        ..      BEQ      0x8109dc ; gap_lib_handle_btif_msg + 88
        0x008109ae:    28a2        .(      CMP      r0,#0xa2
        0x008109b0:    d11f        ..      BNE      0x8109f2 ; gap_lib_handle_btif_msg + 110
        0x008109b2:    e01a        ..      B        0x8109ea ; gap_lib_handle_btif_msg + 102
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (46)
        0x008109b4:    1d20         .      ADDS     r0,r4,#4
        0x008109b6:    f000fbe8    ....    BL       le_handle_vendor_cmd_rsp ; 0x81118a
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (47)
        0x008109ba:    e01a        ..      B        0x8109f2 ; gap_lib_handle_btif_msg + 110
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (51)
        0x008109bc:    88a0        ..      LDRH     r0,[r4,#4]
        0x008109be:    f000f864    ..d.    BL       le_handle_sw_reset_rsp ; 0x810a8a
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (53)
        0x008109c2:    e009        ..      B        0x8109d8 ; gap_lib_handle_btif_msg + 84
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (116)
        0x008109c4:    1d20         .      ADDS     r0,r4,#4
        0x008109c6:    f000fc65    ..e.    BL       le_handle_vendor_evt_info ; 0x811294
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (117)
        0x008109ca:    e012        ..      B        0x8109f2 ; gap_lib_handle_btif_msg + 110
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (122)
        0x008109cc:    4620         F      MOV      r0,r4
        0x008109ce:    f43ef539    >.9.    BL       client_handle_btif_msg ; 0x4f444
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (123)
        0x008109d2:    1d20         .      ADDS     r0,r4,#4
        0x008109d4:    f000f93a    ..:.    BL       patch_le_link_handle_disconnect_rsp ; 0x810c4c
        0x008109d8:    2501        .%      MOVS     r5,#1
        0x008109da:    e00a        ..      B        0x8109f2 ; gap_lib_handle_btif_msg + 110
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (128)
        0x008109dc:    4620         F      MOV      r0,r4
        0x008109de:    f43ef531    >.1.    BL       client_handle_btif_msg ; 0x4f444
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (129)
        0x008109e2:    1d20         .      ADDS     r0,r4,#4
        0x008109e4:    f000f93e    ..>.    BL       patch_le_link_handle_disconnect_ind ; 0x810c64
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (131)
        0x008109e8:    e7f6        ..      B        0x8109d8 ; gap_lib_handle_btif_msg + 84
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (142)
        0x008109ea:    4620         F      MOV      r0,r4
        0x008109ec:    f000fb03    ....    BL       le_handle_read_remote_version_btif_msg ; 0x810ff6
        0x008109f0:    4605        .F      MOV      r5,r0
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (151)
        0x008109f2:    4628        (F      MOV      r0,r5
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (152)
        0x008109f4:    bd70        p.      POP      {r4-r6,pc}
    gap_lib_init
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (155)
        0x008109f6:    b530        0.      PUSH     {r4,r5,lr}
        0x008109f8:    b087        ..      SUB      sp,sp,#0x1c
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (156)
        0x008109fa:    2000        .       MOVS     r0,#0
        0x008109fc:    9005        ..      STR      r0,[sp,#0x14]
        0x008109fe:    2401        .$      MOVS     r4,#1
        0x00810a00:    9006        ..      STR      r0,[sp,#0x18]
        0x00810a02:    e9cd4000    ...@    STRD     r4,r0,[sp,#0]
        0x00810a06:    4d10        .M      LDR      r5,[pc,#64] ; [0x810a48] = 0x21103500
        0x00810a08:    9003        ..      STR      r0,[sp,#0xc]
        0x00810a0a:    9004        ..      STR      r0,[sp,#0x10]
        0x00810a0c:    9002        ..      STR      r0,[sp,#8]
        0x00810a0e:    231c        .#      MOVS     r3,#0x1c
        0x00810a10:    2208        ."      MOVS     r2,#8
        0x00810a12:    490c        .I      LDR      r1,[pc,#48] ; [0x810a44] = 0x8800d58
        0x00810a14:    4628        (F      MOV      r0,r5
        0x00810a16:    f7f7d822    ..".    BL       log_buffer ; 0x7a5e
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (160)
        0x00810a1a:    490a        .I      LDR      r1,[pc,#40] ; [0x810a44] = 0x8800d58
        0x00810a1c:    9405        ..      STR      r4,[sp,#0x14]
        0x00810a1e:    9406        ..      STR      r4,[sp,#0x18]
        0x00810a20:    9403        ..      STR      r4,[sp,#0xc]
        0x00810a22:    9404        ..      STR      r4,[sp,#0x10]
        0x00810a24:    9400        ..      STR      r4,[sp,#0]
        0x00810a26:    9401        ..      STR      r4,[sp,#4]
        0x00810a28:    2300        .#      MOVS     r3,#0
        0x00810a2a:    2208        ."      MOVS     r2,#8
        0x00810a2c:    31f0        .1      ADDS     r1,r1,#0xf0
        0x00810a2e:    4628        (F      MOV      r0,r5
        0x00810a30:    9402        ..      STR      r4,[sp,#8]
        0x00810a32:    f7f7d814    ....    BL       log_buffer ; 0x7a5e
;;; ..\..\..\src\app\gap_lib\gap_lib\gap_lib.c (163)
        0x00810a36:    f2af00b3    ....    ADR      r0,{pc}-0xb1 ; 0x810985
        0x00810a3a:    b007        ..      ADD      sp,sp,#0x1c
        0x00810a3c:    e8bd4030    ..0@    POP      {r4,r5,lr}
        0x00810a40:    f43bb1e6    ;...    B        gap_register_extend_cb ; 0x4be10
    $d
        0x00810a44:    08800d58    X...    DCD    142609752
        0x00810a48:    21103500    .5.!    DCD    554710272
    $t
    .text
    gap_sw_reset_req
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (137)
        0x00810a4c:    b570        p.      PUSH     {r4-r6,lr}
        0x00810a4e:    2402        .$      MOVS     r4,#2
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (137)
        0x00810a50:    4605        .F      MOV      r5,r0
        0x00810a52:    2801        .(      CMP      r0,#1
        0x00810a54:    d002        ..      BEQ      0x810a5c ; gap_sw_reset_req + 16
        0x00810a56:    2403        .$      MOVS     r4,#3
        0x00810a58:    4620         F      MOV      r0,r4
        0x00810a5a:    bd70        p.      POP      {r4-r6,pc}
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (141)
        0x00810a5c:    f43df088    =...    BL       le_get_active_link_num ; 0x4db70
        0x00810a60:    2800        .(      CMP      r0,#0
        0x00810a62:    d1f9        ..      BNE      0x810a58 ; gap_sw_reset_req + 12
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (142)
        0x00810a64:    48fb        .H      LDR      r0,[pc,#1004] ; [0x810e54] = 0x202e38
        0x00810a66:    7801        .x      LDRB     r1,[r0,#0]
        0x00810a68:    07c8        ..      LSLS     r0,r1,#31
        0x00810a6a:    d0f5        ..      BEQ      0x810a58 ; gap_sw_reset_req + 12
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (143)
        0x00810a6c:    f0110f0c    ....    TST      r1,#0xc
        0x00810a70:    d0f2        ..      BEQ      0x810a58 ; gap_sw_reset_req + 12
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (144)
        0x00810a72:    f0110f30    ..0.    TST      r1,#0x30
        0x00810a76:    d1ef        ..      BNE      0x810a58 ; gap_sw_reset_req + 12
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (145)
        0x00810a78:    0988        ..      LSRS     r0,r1,#6
        0x00810a7a:    d1ed        ..      BNE      0x810a58 ; gap_sw_reset_req + 12
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (147)
        0x00810a7c:    4628        (F      MOV      r0,r5
        0x00810a7e:    f410f630    ..0.    BL       btif_sw_reset_req ; 0x216e2
        0x00810a82:    2800        .(      CMP      r0,#0
        0x00810a84:    d0e8        ..      BEQ      0x810a58 ; gap_sw_reset_req + 12
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (149)
        0x00810a86:    2400        .$      MOVS     r4,#0
        0x00810a88:    e7e6        ..      B        0x810a58 ; gap_sw_reset_req + 12
    le_handle_sw_reset_rsp
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (161)
        0x00810a8a:    b538        8.      PUSH     {r3-r5,lr}
        0x00810a8c:    0004        ..      MOVS     r4,r0
        0x00810a8e:    d107        ..      BNE      0x810aa0 ; le_handle_sw_reset_rsp + 22
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (164)
        0x00810a90:    49f0        .I      LDR      r1,[pc,#960] ; [0x810e54] = 0x202e38
        0x00810a92:    7808        .x      LDRB     r0,[r1,#0]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (165)
        0x00810a94:    f020000e     ...    BIC      r0,r0,#0xe
        0x00810a98:    7008        .p      STRB     r0,[r1,#0]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (166)
        0x00810a9a:    20fc        .       MOVS     r0,#0xfc
        0x00810a9c:    f43cf211    <...    BL       gap_send_dev_state ; 0x4cec2
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (168)
        0x00810aa0:    48ed        .H      LDR      r0,[pc,#948] ; [0x810e58] = 0x202e48
        0x00810aa2:    6802        .h      LDR      r2,[r0,#0]
        0x00810aa4:    2a00        .*      CMP      r2,#0
        0x00810aa6:    d004        ..      BEQ      0x810ab2 ; le_handle_sw_reset_rsp + 40
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (171)
        0x00810aa8:    f8ad4000    ...@    STRH     r4,[sp,#0]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (172)
        0x00810aac:    4669        iF      MOV      r1,sp
        0x00810aae:    20a5        .       MOVS     r0,#0xa5
        0x00810ab0:    4790        .G      BLX      r2
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (174)
        0x00810ab2:    bd38        8.      POP      {r3-r5,pc}
    le_check_privacy_bond
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (180)
        0x00810ab4:    b530        0.      PUSH     {r4,r5,lr}
        0x00810ab6:    b08b        ..      SUB      sp,sp,#0x2c
        0x00810ab8:    f04f0100    O...    MOV      r1,#0
        0x00810abc:    4de7        .M      LDR      r5,[pc,#924] ; [0x810e5c] = 0x21103502
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (180)
        0x00810abe:    0004        ..      MOVS     r4,r0
        0x00810ac0:    9106        ..      STR      r1,[sp,#0x18]
        0x00810ac2:    9107        ..      STR      r1,[sp,#0x1c]
        0x00810ac4:    9108        ..      STR      r1,[sp,#0x20]
        0x00810ac6:    9109        ..      STR      r1,[sp,#0x24]
        0x00810ac8:    d002        ..      BEQ      0x810ad0 ; le_check_privacy_bond + 28
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (183)
        0x00810aca:    7820         x      LDRB     r0,[r4,#0]
        0x00810acc:    2801        .(      CMP      r0,#1
        0x00810ace:    d008        ..      BEQ      0x810ae2 ; le_check_privacy_bond + 46
        0x00810ad0:    2301        .#      MOVS     r3,#1
        0x00810ad2:    2201        ."      MOVS     r2,#1
        0x00810ad4:    49e2        .I      LDR      r1,[pc,#904] ; [0x810e60] = 0x8800f60
        0x00810ad6:    4628        (F      MOV      r0,r5
        0x00810ad8:    f7f6dfc1    ....    BL       log_buffer ; 0x7a5e
        0x00810adc:    2000        .       MOVS     r0,#0
        0x00810ade:    b00b        ..      ADD      sp,sp,#0x2c
        0x00810ae0:    bd30        0.      POP      {r4,r5,pc}
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (185)
        0x00810ae2:    78a0        .x      LDRB     r0,[r4,#2]
        0x00810ae4:    0700        ..      LSLS     r0,r0,#28
        0x00810ae6:    d518        ..      BPL      0x810b1a ; le_check_privacy_bond + 102
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (188)
        0x00810ae8:    466a        jF      MOV      r2,sp
        0x00810aea:    2114        .!      MOVS     r1,#0x14
        0x00810aec:    4620         F      MOV      r0,r4
        0x00810aee:    f43ff439    ?.9.    BL       le_get_key ; 0x50364
        0x00810af2:    b180        ..      CBZ      r0,0x810b16 ; le_check_privacy_bond + 98
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (190)
        0x00810af4:    2210        ."      MOVS     r2,#0x10
        0x00810af6:    a906        ..      ADD      r1,sp,#0x18
        0x00810af8:    4668        hF      MOV      r0,sp
        0x00810afa:    f449f183    I...    BL       memcmp ; 0x59e04
        0x00810afe:    b140        @.      CBZ      r0,0x810b12 ; le_check_privacy_bond + 94
        0x00810b00:    49d7        .I      LDR      r1,[pc,#860] ; [0x810e60] = 0x8800f60
        0x00810b02:    7863        cx      LDRB     r3,[r4,#1]
        0x00810b04:    2201        ."      MOVS     r2,#1
        0x00810b06:    3930        09      SUBS     r1,r1,#0x30
        0x00810b08:    4628        (F      MOV      r0,r5
        0x00810b0a:    f7f6dfa8    ....    BL       log_buffer ; 0x7a5e
        0x00810b0e:    2001        .       MOVS     r0,#1
        0x00810b10:    e7e5        ..      B        0x810ade ; le_check_privacy_bond + 42
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (192)
        0x00810b12:    2305        .#      MOVS     r3,#5
        0x00810b14:    e7dd        ..      B        0x810ad2 ; le_check_privacy_bond + 30
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (202)
        0x00810b16:    2304        .#      MOVS     r3,#4
        0x00810b18:    e7db        ..      B        0x810ad2 ; le_check_privacy_bond + 30
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (207)
        0x00810b1a:    2302        .#      MOVS     r3,#2
        0x00810b1c:    e7d9        ..      B        0x810ad2 ; le_check_privacy_bond + 30
    le_bond_just_work_confirm
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (219)
        0x00810b1e:    460a        .F      MOV      r2,r1
        0x00810b20:    eb000140    ..@.    ADD      r1,r0,r0,LSL #1
        0x00810b24:    48cf        .H      LDR      r0,[pc,#828] ; [0x810e64] = 0x202e64
        0x00810b26:    b510        ..      PUSH     {r4,lr}
        0x00810b28:    6800        .h      LDR      r0,[r0,#0]
        0x00810b2a:    eb001001    ....    ADD      r0,r0,r1,LSL #4
        0x00810b2e:    7801        .x      LDRB     r1,[r0,#0]
        0x00810b30:    b129        ).      CBZ      r1,0x810b3e ; le_bond_just_work_confirm + 32
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (222)
        0x00810b32:    7981        .y      LDRB     r1,[r0,#6]
        0x00810b34:    1dc0        ..      ADDS     r0,r0,#7
        0x00810b36:    f410f590    ....    BL       btif_just_work_req_cfm ; 0x2165a
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (224)
        0x00810b3a:    2000        .       MOVS     r0,#0
        0x00810b3c:    bd10        ..      POP      {r4,pc}
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (228)
        0x00810b3e:    2004        .       MOVS     r0,#4
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (230)
        0x00810b40:    bd10        ..      POP      {r4,pc}
    le_gen_rand_addr
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (234)
        0x00810b42:    b5f0        ..      PUSH     {r4-r7,lr}
        0x00810b44:    b085        ..      SUB      sp,sp,#0x14
        0x00810b46:    460c        .F      MOV      r4,r1
        0x00810b48:    0006        ..      MOVS     r6,r0
        0x00810b4a:    d005        ..      BEQ      0x810b58 ; le_gen_rand_addr + 22
        0x00810b4c:    f411f2d1    ....    BL       btif_le_gen_rand_addr ; 0x220f2
        0x00810b50:    b378        x.      CBZ      r0,0x810bb2 ; le_gen_rand_addr + 112
        0x00810b52:    2000        .       MOVS     r0,#0
        0x00810b54:    b005        ..      ADD      sp,sp,#0x14
        0x00810b56:    bdf0        ..      POP      {r4-r7,pc}
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (238)
        0x00810b58:    2700        .'      MOVS     r7,#0
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (240)
        0x00810b5a:    b344        D.      CBZ      r4,0x810bae ; le_gen_rand_addr + 108
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (246)
        0x00810b5c:    f7fdfdfe    ....    BL       rand ; 0x80e75c
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (247)
        0x00810b60:    7020         p      STRB     r0,[r4,#0]
        0x00810b62:    0a01        ..      LSRS     r1,r0,#8
        0x00810b64:    7061        ap      STRB     r1,[r4,#1]
        0x00810b66:    0c01        ..      LSRS     r1,r0,#16
        0x00810b68:    70a1        .p      STRB     r1,[r4,#2]
        0x00810b6a:    0e00        ..      LSRS     r0,r0,#24
        0x00810b6c:    1c65        e.      ADDS     r5,r4,#1
        0x00810b6e:    70e0        .p      STRB     r0,[r4,#3]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (248)
        0x00810b70:    f7fdfdf4    ....    BL       rand ; 0x80e75c
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (249)
        0x00810b74:    70e8        .p      STRB     r0,[r5,#3]
        0x00810b76:    0a00        ..      LSRS     r0,r0,#8
        0x00810b78:    7128        (q      STRB     r0,[r5,#4]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (251)
        0x00810b7a:    f04000c0    @...    ORR      r0,r0,#0xc0
        0x00810b7e:    7160        `q      STRB     r0,[r4,#5]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (252)
        0x00810b80:    a0b9        ..      ADR      r0,{pc}+0x2e8 ; 0x810e68
        0x00810b82:    2206        ."      MOVS     r2,#6
        0x00810b84:    e9d01000    ....    LDRD     r1,r0,[r0,#0]
        0x00810b88:    e9cd1001    ....    STRD     r1,r0,[sp,#4]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (253)
        0x00810b8c:    a0b8        ..      ADR      r0,{pc}+0x2e4 ; 0x810e70
        0x00810b8e:    e9d01000    ....    LDRD     r1,r0,[r0,#0]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (254)
        0x00810b92:    e9cd1003    ....    STRD     r1,r0,[sp,#0xc]
        0x00810b96:    a901        ..      ADD      r1,sp,#4
        0x00810b98:    4620         F      MOV      r0,r4
        0x00810b9a:    f449f133    I.3.    BL       memcmp ; 0x59e04
        0x00810b9e:    b148        H.      CBZ      r0,0x810bb4 ; le_gen_rand_addr + 114
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (255)
        0x00810ba0:    2206        ."      MOVS     r2,#6
        0x00810ba2:    a903        ..      ADD      r1,sp,#0xc
        0x00810ba4:    4620         F      MOV      r0,r4
        0x00810ba6:    f449f12d    I.-.    BL       memcmp ; 0x59e04
        0x00810baa:    b118        ..      CBZ      r0,0x810bb4 ; le_gen_rand_addr + 114
        0x00810bac:    e004        ..      B        0x810bb8 ; le_gen_rand_addr + 118
        0x00810bae:    2003        .       MOVS     r0,#3
        0x00810bb0:    e7d0        ..      B        0x810b54 ; le_gen_rand_addr + 18
        0x00810bb2:    e00f        ..      B        0x810bd4 ; le_gen_rand_addr + 146
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (257)
        0x00810bb4:    2066        f       MOVS     r0,#0x66
        0x00810bb6:    7020         p      STRB     r0,[r4,#0]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (259)
        0x00810bb8:    4621        !F      MOV      r1,r4
        0x00810bba:    48af        .H      LDR      r0,[pc,#700] ; [0x810e78] = 0x21300000
        0x00810bbc:    f7f7d90c    ....    BL       trace_bdaddr ; 0x7dd8
        0x00810bc0:    49a7        .I      LDR      r1,[pc,#668] ; [0x810e60] = 0x8800f60
        0x00810bc2:    4603        .F      MOV      r3,r0
        0x00810bc4:    2202        ."      MOVS     r2,#2
        0x00810bc6:    3138        81      ADDS     r1,r1,#0x38
        0x00810bc8:    48a4        .H      LDR      r0,[pc,#656] ; [0x810e5c] = 0x21103502
        0x00810bca:    9600        ..      STR      r6,[sp,#0]
        0x00810bcc:    f7f6df47    ..G.    BL       log_buffer ; 0x7a5e
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (261)
        0x00810bd0:    4638        8F      MOV      r0,r7
        0x00810bd2:    e7bf        ..      B        0x810b54 ; le_gen_rand_addr + 18
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (267)
        0x00810bd4:    2007        .       MOVS     r0,#7
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (268)
        0x00810bd6:    e7bd        ..      B        0x810b54 ; le_gen_rand_addr + 18
    patch_le_link_disconnected
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (275)
        0x00810bd8:    b570        p.      PUSH     {r4-r6,lr}
        0x00810bda:    460d        .F      MOV      r5,r1
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (277)
        0x00810bdc:    f43cf68a    <...    BL       le_link_find_by_link_id ; 0x4d8f4
        0x00810be0:    0004        ..      MOVS     r4,r0
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (279)
        0x00810be2:    d02a        *.      BEQ      0x810c3a ; patch_le_link_disconnected + 98
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (281)
        0x00810be4:    48a5        .H      LDR      r0,[pc,#660] ; [0x810e7c] = 0x202e60
        0x00810be6:    499e        .I      LDR      r1,[pc,#632] ; [0x810e60] = 0x8800f60
        0x00810be8:    2201        ."      MOVS     r2,#1
        0x00810bea:    7803        .x      LDRB     r3,[r0,#0]
        0x00810bec:    489b        .H      LDR      r0,[pc,#620] ; [0x810e5c] = 0x21103502
        0x00810bee:    3174        t1      ADDS     r1,r1,#0x74
        0x00810bf0:    1c40        @.      ADDS     r0,r0,#1
        0x00810bf2:    f7f6df34    ..4.    BL       log_buffer ; 0x7a5e
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (282)
        0x00810bf6:    4997        .I      LDR      r1,[pc,#604] ; [0x810e54] = 0x202e38
        0x00810bf8:    2201        ."      MOVS     r2,#1
        0x00810bfa:    7808        .x      LDRB     r0,[r1,#0]
        0x00810bfc:    ebb21f90    ....    CMP      r2,r0,LSR #6
        0x00810c00:    d10a        ..      BNE      0x810c18 ; patch_le_link_disconnected + 64
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (284)
        0x00810c02:    7862        bx      LDRB     r2,[r4,#1]
        0x00810c04:    2a03        .*      CMP      r2,#3
        0x00810c06:    d107        ..      BNE      0x810c18 ; patch_le_link_disconnected + 64
        0x00810c08:    78a2        .x      LDRB     r2,[r4,#2]
        0x00810c0a:    2a01        .*      CMP      r2,#1
        0x00810c0c:    d104        ..      BNE      0x810c18 ; patch_le_link_disconnected + 64
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (285)
        0x00810c0e:    8a22        ".      LDRH     r2,[r4,#0x10]
        0x00810c10:    b912        ..      CBNZ     r2,0x810c18 ; patch_le_link_disconnected + 64
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (287)
        0x00810c12:    f02000c0     ...    BIC      r0,r0,#0xc0
        0x00810c16:    7008        .p      STRB     r0,[r1,#0]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (291)
        0x00810c18:    78e0        .x      LDRB     r0,[r4,#3]
        0x00810c1a:    462a        *F      MOV      r2,r5
        0x00810c1c:    2100        .!      MOVS     r1,#0
        0x00810c1e:    f441f53c    A.<.    BL       gap_send_conn_state_msg ; 0x5269a
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (292)
        0x00810c22:    2000        .       MOVS     r0,#0
        0x00810c24:    f43cf14d    <.M.    BL       gap_send_dev_state ; 0x4cec2
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (293)
        0x00810c28:    6ae0        .j      LDR      r0,[r4,#0x2c]
        0x00810c2a:    b108        ..      CBZ      r0,0x810c30 ; patch_le_link_disconnected + 88
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (295)
        0x00810c2c:    f415f123    ..#.    BL       os_mem_free ; 0x25e76
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (297)
        0x00810c30:    4620         F      MOV      r0,r4
        0x00810c32:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x00810c36:    f43cb64c    <.L.    B        le_link_release ; 0x4d8d2
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (301)
        0x00810c3a:    4989        .I      LDR      r1,[pc,#548] ; [0x810e60] = 0x8800f60
        0x00810c3c:    e8bd4070    ..p@    POP      {r4-r6,lr}
        0x00810c40:    4886        .H      LDR      r0,[pc,#536] ; [0x810e5c] = 0x21103502
        0x00810c42:    2200        ."      MOVS     r2,#0
        0x00810c44:    31a4        .1      ADDS     r1,r1,#0xa4
        0x00810c46:    1e80        ..      SUBS     r0,r0,#2
        0x00810c48:    f7f69f09    ....    B        log_buffer ; 0x7a5e
    patch_le_link_handle_disconnect_rsp
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (308)
        0x00810c4c:    8843        C.      LDRH     r3,[r0,#2]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (307)
        0x00810c4e:    b133        3.      CBZ      r3,0x810c5e ; patch_le_link_handle_disconnect_rsp + 18
        0x00810c50:    4983        .I      LDR      r1,[pc,#524] ; [0x810e60] = 0x8800f60
        0x00810c52:    4882        .H      LDR      r0,[pc,#520] ; [0x810e5c] = 0x21103502
        0x00810c54:    2201        ."      MOVS     r2,#1
        0x00810c56:    31d4        .1      ADDS     r1,r1,#0xd4
        0x00810c58:    1e80        ..      SUBS     r0,r0,#2
        0x00810c5a:    f7f69f00    ....    B        log_buffer ; 0x7a5e
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (310)
        0x00810c5e:    8881        ..      LDRH     r1,[r0,#4]
        0x00810c60:    8800        ..      LDRH     r0,[r0,#0]
        0x00810c62:    e7b9        ..      B        patch_le_link_disconnected ; 0x810bd8
    patch_le_link_handle_disconnect_ind
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (319)
        0x00810c64:    b510        ..      PUSH     {r4,lr}
        0x00810c66:    4604        .F      MOV      r4,r0
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (320)
        0x00810c68:    8841        A.      LDRH     r1,[r0,#2]
        0x00810c6a:    8800        ..      LDRH     r0,[r0,#0]
        0x00810c6c:    f7ffffb4    ....    BL       patch_le_link_disconnected ; 0x810bd8
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (321)
        0x00810c70:    8820         .      LDRH     r0,[r4,#0]
        0x00810c72:    e8bd4010    ...@    POP      {r4,lr}
        0x00810c76:    f410b5cb    ....    B        btif_le_disconn_cfm ; 0x21810
    le_bond_get_sec_level
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (337)
        0x00810c7a:    b510        ..      PUSH     {r4,lr}
        0x00810c7c:    b08a        ..      SUB      sp,sp,#0x28
        0x00810c7e:    460c        .F      MOV      r4,r1
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (340)
        0x00810c80:    2100        .!      MOVS     r1,#0
        0x00810c82:    7021        !p      STRB     r1,[r4,#0]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (341)
        0x00810c84:    aa09        ..      ADD      r2,sp,#0x24
        0x00810c86:    a907        ..      ADD      r1,sp,#0x1c
        0x00810c88:    f43cf7b1    <...    BL       le_get_conn_addr ; 0x4dbee
        0x00810c8c:    b1b8        ..      CBZ      r0,0x810cbe ; le_bond_get_sec_level + 68
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (344)
        0x00810c8e:    f89d1024    ..$.    LDRB     r1,[sp,#0x24]
        0x00810c92:    a807        ..      ADD      r0,sp,#0x1c
        0x00810c94:    f43ff27b    ?.{.    BL       le_find_key_entry ; 0x5018e
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (345)
        0x00810c98:    b188        ..      CBZ      r0,0x810cbe ; le_bond_get_sec_level + 68
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (348)
        0x00810c9a:    466a        jF      MOV      r2,sp
        0x00810c9c:    2111        .!      MOVS     r1,#0x11
        0x00810c9e:    f43ff361    ?.a.    BL       le_get_key ; 0x50364
        0x00810ca2:    b160        `.      CBZ      r0,0x810cbe ; le_bond_get_sec_level + 68
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (350)
        0x00810ca4:    f89d301b    ...0    LDRB     r3,[sp,#0x1b]
        0x00810ca8:    2201        ."      MOVS     r2,#1
        0x00810caa:    4975        uI      LDR      r1,[pc,#468] ; [0x810e80] = 0x8801068
        0x00810cac:    486b        kH      LDR      r0,[pc,#428] ; [0x810e5c] = 0x21103502
        0x00810cae:    f7f6ded6    ....    BL       log_buffer ; 0x7a5e
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (351)
        0x00810cb2:    f89d001b    ....    LDRB     r0,[sp,#0x1b]
        0x00810cb6:    7020         p      STRB     r0,[r4,#0]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (352)
        0x00810cb8:    2000        .       MOVS     r0,#0
        0x00810cba:    b00a        ..      ADD      sp,sp,#0x28
        0x00810cbc:    bd10        ..      POP      {r4,pc}
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (356)
        0x00810cbe:    2003        .       MOVS     r0,#3
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (357)
        0x00810cc0:    e7fb        ..      B        0x810cba ; le_bond_get_sec_level + 64
    le_get_dev_bond_info_len
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (372)
        0x00810cc2:    4870        pH      LDR      r0,[pc,#448] ; [0x810e84] = 0x202eee
        0x00810cc4:    8800        ..      LDRH     r0,[r0,#0]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (373)
        0x00810cc6:    4770        pG      BX       lr
    le_get_dev_bond_info
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (376)
        0x00810cc8:    e92d4ff8    -..O    PUSH     {r3-r11,lr}
        0x00810ccc:    460f        .F      MOV      r7,r1
        0x00810cce:    0005        ..      MOVS     r5,r0
        0x00810cd0:    d008        ..      BEQ      0x810ce4 ; le_get_dev_bond_info + 28
        0x00810cd2:    4b62        bK      LDR      r3,[pc,#392] ; [0x810e5c] = 0x21103502
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (382)
        0x00810cd4:    7828        (x      LDRB     r0,[r5,#0]
        0x00810cd6:    1e9b        ..      SUBS     r3,r3,#2
        0x00810cd8:    2801        .(      CMP      r0,#1
        0x00810cda:    d006        ..      BEQ      0x810cea ; le_get_dev_bond_info + 34
        0x00810cdc:    4968        hI      LDR      r1,[pc,#416] ; [0x810e80] = 0x8801068
        0x00810cde:    2200        ."      MOVS     r2,#0
        0x00810ce0:    3148        H1      ADDS     r1,r1,#0x48
        0x00810ce2:    e00b        ..      B        0x810cfc ; le_get_dev_bond_info + 52
        0x00810ce4:    2000        .       MOVS     r0,#0
        0x00810ce6:    e8bd8ff8    ....    POP      {r3-r11,pc}
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (384)
        0x00810cea:    4867        gH      LDR      r0,[pc,#412] ; [0x810e88] = 0x202ebc
        0x00810cec:    7869        ix      LDRB     r1,[r5,#1]
        0x00810cee:    7800        .x      LDRB     r0,[r0,#0]
        0x00810cf0:    1e40        @.      SUBS     r0,r0,#1
        0x00810cf2:    4281        .B      CMP      r1,r0
        0x00810cf4:    dd06        ..      BLE      0x810d04 ; le_get_dev_bond_info + 60
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (386)
        0x00810cf6:    4962        bI      LDR      r1,[pc,#392] ; [0x810e80] = 0x8801068
        0x00810cf8:    2200        ."      MOVS     r2,#0
        0x00810cfa:    3120         1      ADDS     r1,r1,#0x20
        0x00810cfc:    4618        .F      MOV      r0,r3
        0x00810cfe:    f7f6deae    ....    BL       log_buffer ; 0x7a5e
        0x00810d02:    e7ef        ..      B        0x810ce4 ; le_get_dev_bond_info + 28
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (390)
        0x00810d04:    f8df817c    ..|.    LDR      r8,[pc,#380] ; [0x810e84] = 0x202eee
        0x00810d08:    4638        8F      MOV      r0,r7
        0x00810d0a:    f8b81000    ....    LDRH     r1,[r8,#0]
        0x00810d0e:    088e        ..      LSRS     r6,r1,#2
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (392)
        0x00810d10:    f449f184    I...    BL       __aeabi_memclr ; 0x5a01c
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (393)
        0x00810d14:    2400        .$      MOVS     r4,#0
        0x00810d16:    f8df9174    ..t.    LDR      r9,[pc,#372] ; [0x810e8c] = 0x202ef0
        0x00810d1a:    f8dfa174    ..t.    LDR      r10,[pc,#372] ; [0x810e90] = 0x202ee0
        0x00810d1e:    e011        ..      B        0x810d44 ; le_get_dev_bond_info + 124
        0x00810d20:    7868        hx      LDRB     r0,[r5,#1]
        0x00810d22:    9000        ..      STR      r0,[sp,#0]
        0x00810d24:    f8b91000    ....    LDRH     r1,[r9,#0]
        0x00810d28:    f8ba0000    ....    LDRH     r0,[r10,#0]
        0x00810d2c:    2304        .#      MOVS     r3,#4
        0x00810d2e:    4408        .D      ADD      r0,r0,r1
        0x00810d30:    eb000084    ....    ADD      r0,r0,r4,LSL #2
        0x00810d34:    b281        ..      UXTH     r1,r0
        0x00810d36:    eb070084    ....    ADD      r0,r7,r4,LSL #2
        0x00810d3a:    f8b82000    ...     LDRH     r2,[r8,#0]
        0x00810d3e:    f440f173    @.s.    BL       imp_flash_load ; 0x51028
        0x00810d42:    1c64        d.      ADDS     r4,r4,#1
        0x00810d44:    42b4        .B      CMP      r4,r6
        0x00810d46:    dbeb        ..      BLT      0x810d20 ; le_get_dev_bond_info + 88
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (401)
        0x00810d48:    2001        .       MOVS     r0,#1
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (405)
        0x00810d4a:    e7cc        ..      B        0x810ce6 ; le_get_dev_bond_info + 30
    le_key_entry_init
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (408)
        0x00810d4c:    b530        0.      PUSH     {r4,r5,lr}
        0x00810d4e:    b0a7        ..      SUB      sp,sp,#0x9c
        0x00810d50:    0004        ..      MOVS     r4,r0
        0x00810d52:    d007        ..      BEQ      0x810d64 ; le_key_entry_init + 24
        0x00810d54:    f1040008    ....    ADD      r0,r4,#8
        0x00810d58:    7861        ax      LDRB     r1,[r4,#1]
        0x00810d5a:    4605        .F      MOV      r5,r0
        0x00810d5c:    f440f238    @.8.    BL       flash_load_le_remote_bd ; 0x511d0
        0x00810d60:    b118        ..      CBZ      r0,0x810d6a ; le_key_entry_init + 30
        0x00810d62:    e014        ..      B        0x810d8e ; le_key_entry_init + 66
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (411)
        0x00810d64:    2000        .       MOVS     r0,#0
        0x00810d66:    b027        '.      ADD      sp,sp,#0x9c
        0x00810d68:    bd30        0.      POP      {r4,r5,pc}
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (415)
        0x00810d6a:    7be0        .{      LDRB     r0,[r4,#0xf]
        0x00810d6c:    07c1        ..      LSLS     r1,r0,#31
        0x00810d6e:    d00e        ..      BEQ      0x810d8e ; le_key_entry_init + 66
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (417)
        0x00810d70:    2101        .!      MOVS     r1,#1
        0x00810d72:    7021        !p      STRB     r1,[r4,#0]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (418)
        0x00810d74:    8862        b.      LDRH     r2,[r4,#2]
        0x00810d76:    0783        ..      LSLS     r3,r0,#30
        0x00810d78:    f0420201    B...    ORR      r2,r2,#1
        0x00810d7c:    8062        b.      STRH     r2,[r4,#2]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (419)
        0x00810d7e:    d502        ..      BPL      0x810d86 ; le_key_entry_init + 58
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (421)
        0x00810d80:    f0420280    B...    ORR      r2,r2,#0x80
        0x00810d84:    8062        b.      STRH     r2,[r4,#2]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (423)
        0x00810d86:    0740        @.      LSLS     r0,r0,#29
        0x00810d88:    d504        ..      BPL      0x810d94 ; le_key_entry_init + 72
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (425)
        0x00810d8a:    7121        !q      STRB     r1,[r4,#4]
        0x00810d8c:    e002        ..      B        0x810d94 ; le_key_entry_init + 72
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (429)
        0x00810d8e:    7820         x      LDRB     r0,[r4,#0]
        0x00810d90:    2801        .(      CMP      r0,#1
        0x00810d92:    d15d        ].      BNE      0x810e50 ; le_key_entry_init + 260
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (437)
        0x00810d94:    7861        ax      LDRB     r1,[r4,#1]
        0x00810d96:    a80a        ..      ADD      r0,sp,#0x28
        0x00810d98:    f440f25c    @.\.    BL       flash_load_le_local_ltk ; 0x51254
        0x00810d9c:    b930        0.      CBNZ     r0,0x810dac ; le_key_entry_init + 96
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (439)
        0x00810d9e:    f89d0028    ..(.    LDRB     r0,[sp,#0x28]
        0x00810da2:    b118        ..      CBZ      r0,0x810dac ; le_key_entry_init + 96
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (441)
        0x00810da4:    8860        `.      LDRH     r0,[r4,#2]
        0x00810da6:    f0400002    @...    ORR      r0,r0,#2
        0x00810daa:    8060        `.      STRH     r0,[r4,#2]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (444)
        0x00810dac:    7861        ax      LDRB     r1,[r4,#1]
        0x00810dae:    a812        ..      ADD      r0,sp,#0x48
        0x00810db0:    f440f299    @...    BL       flash_load_le_remote_ltk ; 0x512e6
        0x00810db4:    b930        0.      CBNZ     r0,0x810dc4 ; le_key_entry_init + 120
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (446)
        0x00810db6:    f89d0048    ..H.    LDRB     r0,[sp,#0x48]
        0x00810dba:    b118        ..      CBZ      r0,0x810dc4 ; le_key_entry_init + 120
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (448)
        0x00810dbc:    8860        `.      LDRH     r0,[r4,#2]
        0x00810dbe:    f0400004    @...    ORR      r0,r0,#4
        0x00810dc2:    8060        `.      STRH     r0,[r4,#2]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (451)
        0x00810dc4:    7861        ax      LDRB     r1,[r4,#1]
        0x00810dc6:    a804        ..      ADD      r0,sp,#0x10
        0x00810dc8:    f440f2fb    @...    BL       flash_load_le_remote_irk ; 0x513c2
        0x00810dcc:    b970        p.      CBNZ     r0,0x810dec ; le_key_entry_init + 160
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (453)
        0x00810dce:    f89d0027    ..'.    LDRB     r0,[sp,#0x27]
        0x00810dd2:    b158        X.      CBZ      r0,0x810dec ; le_key_entry_init + 160
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (455)
        0x00810dd4:    9808        ..      LDR      r0,[sp,#0x20]
        0x00810dd6:    6120         a      STR      r0,[r4,#0x10]
        0x00810dd8:    f8bd0024    ..$.    LDRH     r0,[sp,#0x24]
        0x00810ddc:    82a0        ..      STRH     r0,[r4,#0x14]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (456)
        0x00810dde:    f89d0026    ..&.    LDRB     r0,[sp,#0x26]
        0x00810de2:    75a0        .u      STRB     r0,[r4,#0x16]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (457)
        0x00810de4:    8860        `.      LDRH     r0,[r4,#2]
        0x00810de6:    f0400008    @...    ORR      r0,r0,#8
        0x00810dea:    8060        `.      STRH     r0,[r4,#2]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (460)
        0x00810dec:    7861        ax      LDRB     r1,[r4,#1]
        0x00810dee:    a81a        ..      ADD      r0,sp,#0x68
        0x00810df0:    f440f3b0    @...    BL       flash_load_le_local_csrk ; 0x51554
        0x00810df4:    b930        0.      CBNZ     r0,0x810e04 ; le_key_entry_init + 184
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (462)
        0x00810df6:    f89d007d    ..}.    LDRB     r0,[sp,#0x7d]
        0x00810dfa:    b118        ..      CBZ      r0,0x810e04 ; le_key_entry_init + 184
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (464)
        0x00810dfc:    8860        `.      LDRH     r0,[r4,#2]
        0x00810dfe:    f0400010    @...    ORR      r0,r0,#0x10
        0x00810e02:    8060        `.      STRH     r0,[r4,#2]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (467)
        0x00810e04:    7861        ax      LDRB     r1,[r4,#1]
        0x00810e06:    a820         .      ADD      r0,sp,#0x80
        0x00810e08:    f440f411    @...    BL       flash_load_le_remote_csrk ; 0x5162e
        0x00810e0c:    b930        0.      CBNZ     r0,0x810e1c ; le_key_entry_init + 208
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (469)
        0x00810e0e:    f89d0095    ....    LDRB     r0,[sp,#0x95]
        0x00810e12:    b118        ..      CBZ      r0,0x810e1c ; le_key_entry_init + 208
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (471)
        0x00810e14:    8860        `.      LDRH     r0,[r4,#2]
        0x00810e16:    f0400020    @. .    ORR      r0,r0,#0x20
        0x00810e1a:    8060        `.      STRH     r0,[r4,#2]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (474)
        0x00810e1c:    7860        `x      LDRB     r0,[r4,#1]
        0x00810e1e:    f440f47b    @.{.    BL       flash_read_le_cccd_length ; 0x51718
        0x00810e22:    b118        ..      CBZ      r0,0x810e2c ; le_key_entry_init + 224
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (476)
        0x00810e24:    8860        `.      LDRH     r0,[r4,#2]
        0x00810e26:    f0400040    @.@.    ORR      r0,r0,#0x40
        0x00810e2a:    8060        `.      STRH     r0,[r4,#2]
        0x00810e2c:    4629        )F      MOV      r1,r5
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (478)
        0x00810e2e:    4812        .H      LDR      r0,[pc,#72] ; [0x810e78] = 0x21300000
        0x00810e30:    f7f6dfd2    ....    BL       trace_bdaddr ; 0x7dd8
        0x00810e34:    7922        "y      LDRB     r2,[r4,#4]
        0x00810e36:    8861        a.      LDRH     r1,[r4,#2]
        0x00810e38:    7ba3        .{      LDRB     r3,[r4,#0xe]
        0x00810e3a:    e9cd1202    ....    STRD     r1,r2,[sp,#8]
        0x00810e3e:    e9cd0300    ....    STRD     r0,r3,[sp,#0]
        0x00810e42:    490f        .I      LDR      r1,[pc,#60] ; [0x810e80] = 0x8801068
        0x00810e44:    7863        cx      LDRB     r3,[r4,#1]
        0x00810e46:    2205        ."      MOVS     r2,#5
        0x00810e48:    317c        |1      ADDS     r1,r1,#0x7c
        0x00810e4a:    4804        .H      LDR      r0,[pc,#16] ; [0x810e5c] = 0x21103502
        0x00810e4c:    f7f6de07    ....    BL       log_buffer ; 0x7a5e
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (482)
        0x00810e50:    2001        .       MOVS     r0,#1
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (483)
        0x00810e52:    e788        ..      B        0x810d66 ; le_key_entry_init + 26
    $d
        0x00810e54:    00202e38    8. .    DCD    2108984
        0x00810e58:    00202e48    H. .    DCD    2109000
        0x00810e5c:    21103502    .5.!    DCD    554710274
        0x00810e60:    08800f60    `...    DCD    142610272
        0x00810e64:    00202e64    d. .    DCD    2109028
        0x00810e68:    00000000    ....    DCD    0
        0x00810e6c:    0000c000    ....    DCD    49152
        0x00810e70:    ffffffff    ....    DCD    4294967295
        0x00810e74:    0000ffff    ....    DCD    65535
        0x00810e78:    21300000    ..0!    DCD    556793856
        0x00810e7c:    00202e60    `. .    DCD    2109024
        0x00810e80:    08801068    h...    DCD    142610536
        0x00810e84:    00202eee    .. .    DCD    2109166
        0x00810e88:    00202ebc    .. .    DCD    2109116
        0x00810e8c:    00202ef0    .. .    DCD    2109168
        0x00810e90:    00202ee0    .. .    DCD    2109152
    $t
    le_set_dev_bond_info
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (486)
        0x00810e94:    e92d43fe    -..C    PUSH     {r1-r9,lr}
        0x00810e98:    4688        .F      MOV      r8,r1
        0x00810e9a:    4d98        .M      LDR      r5,[pc,#608] ; [0x8110fc] = 0x202eee
        0x00810e9c:    2100        .!      MOVS     r1,#0
        0x00810e9e:    7011        .p      STRB     r1,[r2,#0]
        0x00810ea0:    8829        ).      LDRH     r1,[r5,#0]
        0x00810ea2:    4e97        .N      LDR      r6,[pc,#604] ; [0x811100] = 0x21103500
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (486)
        0x00810ea4:    4617        .F      MOV      r7,r2
        0x00810ea6:    4288        .B      CMP      r0,r1
        0x00810ea8:    d002        ..      BEQ      0x810eb0 ; le_set_dev_bond_info + 28
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (490)
        0x00810eaa:    2200        ."      MOVS     r2,#0
        0x00810eac:    4995        .I      LDR      r1,[pc,#596] ; [0x811104] = 0x8801140
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (491)
        0x00810eae:    e049        I.      B        0x810f44 ; le_set_dev_bond_info + 176
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (497)
        0x00810eb0:    f8d81000    ....    LDR      r1,[r8,#0]
        0x00810eb4:    9101        ..      STR      r1,[sp,#4]
        0x00810eb6:    f8d80004    ....    LDR      r0,[r8,#4]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (499)
        0x00810eba:    9002        ..      STR      r0,[sp,#8]
        0x00810ebc:    f89d100a    ....    LDRB     r1,[sp,#0xa]
        0x00810ec0:    a801        ..      ADD      r0,sp,#4
        0x00810ec2:    f43ff164    ?.d.    BL       le_find_key_entry ; 0x5018e
        0x00810ec6:    0004        ..      MOVS     r4,r0
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (500)
        0x00810ec8:    d106        ..      BNE      0x810ed8 ; le_set_dev_bond_info + 68
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (502)
        0x00810eca:    f89d100a    ....    LDRB     r1,[sp,#0xa]
        0x00810ece:    a801        ..      ADD      r0,sp,#4
        0x00810ed0:    f43ff4bd    ?...    BL       le_find_entry_by_aes ; 0x5084e
        0x00810ed4:    0004        ..      MOVS     r4,r0
        0x00810ed6:    d008        ..      BEQ      0x810eea ; le_set_dev_bond_info + 86
        0x00810ed8:    2001        .       MOVS     r0,#1
        0x00810eda:    498a        .I      LDR      r1,[pc,#552] ; [0x811104] = 0x8801140
        0x00810edc:    7038        8p      STRB     r0,[r7,#0]
        0x00810ede:    2200        ."      MOVS     r2,#0
        0x00810ee0:    3134        41      ADDS     r1,r1,#0x34
        0x00810ee2:    4630        0F      MOV      r0,r6
        0x00810ee4:    f7f6ddbb    ....    BL       log_buffer ; 0x7a5e
        0x00810ee8:    e039        9.      B        0x810f5e ; le_set_dev_bond_info + 202
        0x00810eea:    f89d000b    ....    LDRB     r0,[sp,#0xb]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (506)
        0x00810eee:    2700        .'      MOVS     r7,#0
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (507)
        0x00810ef0:    0740        @.      LSLS     r0,r0,#29
        0x00810ef2:    d500        ..      BPL      0x810ef6 ; le_set_dev_bond_info + 98
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (509)
        0x00810ef4:    2701        .'      MOVS     r7,#1
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (511)
        0x00810ef6:    f89d100a    ....    LDRB     r1,[sp,#0xa]
        0x00810efa:    463a        :F      MOV      r2,r7
        0x00810efc:    a801        ..      ADD      r0,sp,#4
        0x00810efe:    f43ff1df    ?...    BL       le_allocate_key_entry ; 0x502c0
        0x00810f02:    0004        ..      MOVS     r4,r0
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (513)
        0x00810f04:    d10d        ..      BNE      0x810f22 ; le_set_dev_bond_info + 142
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (515)
        0x00810f06:    f43ff44b    ?.K.    BL       le_get_low_priority_bond ; 0x507a0
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (516)
        0x00810f0a:    b350        P.      CBZ      r0,0x810f62 ; le_set_dev_bond_info + 206
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (518)
        0x00810f0c:    7840        @x      LDRB     r0,[r0,#1]
        0x00810f0e:    f43bf12d    ;.-.    BL       le_bond_delete_by_idx ; 0x4c16c
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (519)
        0x00810f12:    f89d100a    ....    LDRB     r1,[sp,#0xa]
        0x00810f16:    463a        :F      MOV      r2,r7
        0x00810f18:    a801        ..      ADD      r0,sp,#4
        0x00810f1a:    f43ff1d1    ?...    BL       le_allocate_key_entry ; 0x502c0
        0x00810f1e:    0004        ..      MOVS     r4,r0
        0x00810f20:    d01f        ..      BEQ      0x810f62 ; le_set_dev_bond_info + 206
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (533)
        0x00810f22:    7860        `x      LDRB     r0,[r4,#1]
        0x00810f24:    9000        ..      STR      r0,[sp,#0]
        0x00810f26:    4878        xH      LDR      r0,[pc,#480] ; [0x811108] = 0x202ef0
        0x00810f28:    4978        xI      LDR      r1,[pc,#480] ; [0x81110c] = 0x202ee0
        0x00810f2a:    882a        *.      LDRH     r2,[r5,#0]
        0x00810f2c:    8800        ..      LDRH     r0,[r0,#0]
        0x00810f2e:    8809        ..      LDRH     r1,[r1,#0]
        0x00810f30:    b2d3        ..      UXTB     r3,r2
        0x00810f32:    4408        .D      ADD      r0,r0,r1
        0x00810f34:    b281        ..      UXTH     r1,r0
        0x00810f36:    4640        @F      MOV      r0,r8
        0x00810f38:    f440f056    @.V.    BL       imp_flash_save ; 0x50fe8
        0x00810f3c:    b140        @.      CBZ      r0,0x810f50 ; le_set_dev_bond_info + 188
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (536)
        0x00810f3e:    4971        qI      LDR      r1,[pc,#452] ; [0x811104] = 0x8801140
        0x00810f40:    2200        ."      MOVS     r2,#0
        0x00810f42:    3164        d1      ADDS     r1,r1,#0x64
        0x00810f44:    4630        0F      MOV      r0,r6
        0x00810f46:    f7f6dd8a    ....    BL       log_buffer ; 0x7a5e
        0x00810f4a:    2000        .       MOVS     r0,#0
        0x00810f4c:    e8bd83fe    ....    POP      {r1-r9,pc}
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (540)
        0x00810f50:    7861        ax      LDRB     r1,[r4,#1]
        0x00810f52:    2001        .       MOVS     r0,#1
        0x00810f54:    f43ff761    ?.a.    BL       bond_priority_queue_add ; 0x50e1a
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (541)
        0x00810f58:    4620         F      MOV      r0,r4
        0x00810f5a:    f7fffef7    ....    BL       le_key_entry_init ; 0x810d4c
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (542)
        0x00810f5e:    4620         F      MOV      r0,r4
        0x00810f60:    e7f4        ..      B        0x810f4c ; le_set_dev_bond_info + 184
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (545)
        0x00810f62:    4968        hI      LDR      r1,[pc,#416] ; [0x811104] = 0x8801140
        0x00810f64:    2200        ."      MOVS     r2,#0
        0x00810f66:    31a4        .1      ADDS     r1,r1,#0xa4
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (546)
        0x00810f68:    e7ec        ..      B        0x810f44 ; le_set_dev_bond_info + 176
    btif_read_remote_version_req
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (554)
        0x00810f6a:    b500        ..      PUSH     {lr}
        0x00810f6c:    b091        ..      SUB      sp,sp,#0x44
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (557)
        0x00810f6e:    f44f71e8    O..q    MOV      r1,#0x1d0
        0x00810f72:    f8ad1000    ....    STRH     r1,[sp,#0]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (559)
        0x00810f76:    f8ad0004    ....    STRH     r0,[sp,#4]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (561)
        0x00810f7a:    2101        .!      MOVS     r1,#1
        0x00810f7c:    4668        hF      MOV      r0,sp
        0x00810f7e:    f410f238    ..8.    BL       btif_send_cmd ; 0x213f2
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (562)
        0x00810f82:    b011        ..      ADD      sp,sp,#0x44
        0x00810f84:    bd00        ..      POP      {pc}
    le_read_remote_version
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (565)
        0x00810f86:    b510        ..      PUSH     {r4,lr}
        0x00810f88:    4604        .F      MOV      r4,r0
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (566)
        0x00810f8a:    4601        .F      MOV      r1,r0
        0x00810f8c:    4860        `H      LDR      r0,[pc,#384] ; [0x811110] = 0x811bbc
        0x00810f8e:    f43cf543    <.C.    BL       le_link_check_conn_id_internal ; 0x4da18
        0x00810f92:    b168        h.      CBZ      r0,0x810fb0 ; le_read_remote_version + 42
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (568)
        0x00810f94:    495f        _I      LDR      r1,[pc,#380] ; [0x811114] = 0x202e64
        0x00810f96:    eb040044    ..D.    ADD      r0,r4,r4,LSL #1
        0x00810f9a:    6809        .h      LDR      r1,[r1,#0]
        0x00810f9c:    eb011000    ....    ADD      r0,r1,r0,LSL #4
        0x00810fa0:    8a00        ..      LDRH     r0,[r0,#0x10]
        0x00810fa2:    f7ffffe2    ....    BL       btif_read_remote_version_req ; 0x810f6a
        0x00810fa6:    b108        ..      CBZ      r0,0x810fac ; le_read_remote_version + 38
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (570)
        0x00810fa8:    2000        .       MOVS     r0,#0
        0x00810faa:    bd10        ..      POP      {r4,pc}
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (572)
        0x00810fac:    2007        .       MOVS     r0,#7
        0x00810fae:    bd10        ..      POP      {r4,pc}
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (576)
        0x00810fb0:    2004        .       MOVS     r0,#4
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (578)
        0x00810fb2:    bd10        ..      POP      {r4,pc}
    le_handle_read_remote_version_rsp
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (582)
        0x00810fb4:    b57f        ..      PUSH     {r0-r6,lr}
        0x00810fb6:    4d58        XM      LDR      r5,[pc,#352] ; [0x811118] = 0x202e48
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (582)
        0x00810fb8:    4604        .F      MOV      r4,r0
        0x00810fba:    6828        (h      LDR      r0,[r5,#0]
        0x00810fbc:    2800        .(      CMP      r0,#0
        0x00810fbe:    d019        ..      BEQ      0x810ff4 ; le_handle_read_remote_version_rsp + 64
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (588)
        0x00810fc0:    8860        `.      LDRH     r0,[r4,#2]
        0x00810fc2:    f43cf497    <...    BL       le_link_find_by_link_id ; 0x4d8f4
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (589)
        0x00810fc6:    2800        .(      CMP      r0,#0
        0x00810fc8:    d014        ..      BEQ      0x810ff4 ; le_handle_read_remote_version_rsp + 64
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (591)
        0x00810fca:    78c0        .x      LDRB     r0,[r0,#3]
        0x00810fcc:    f88d0000    ....    STRB     r0,[sp,#0]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (597)
        0x00810fd0:    8820         .      LDRH     r0,[r4,#0]
        0x00810fd2:    f8ad0002    ....    STRH     r0,[sp,#2]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (598)
        0x00810fd6:    7920         y      LDRB     r0,[r4,#4]
        0x00810fd8:    f88d0004    ....    STRB     r0,[sp,#4]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (599)
        0x00810fdc:    88e0        ..      LDRH     r0,[r4,#6]
        0x00810fde:    f8ad0006    ....    STRH     r0,[sp,#6]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (600)
        0x00810fe2:    8920         .      LDRH     r0,[r4,#8]
        0x00810fe4:    f8ad0008    ....    STRH     r0,[sp,#8]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (601)
        0x00810fe8:    f8cdd00c    ....    STR      sp,[sp,#0xc]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (602)
        0x00810fec:    682a        *h      LDR      r2,[r5,#0]
        0x00810fee:    a903        ..      ADD      r1,sp,#0xc
        0x00810ff0:    201b        .       MOVS     r0,#0x1b
        0x00810ff2:    4790        .G      BLX      r2
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (604)
        0x00810ff4:    bd7f        ..      POP      {r0-r6,pc}
    le_handle_read_remote_version_btif_msg
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (607)
        0x00810ff6:    b510        ..      PUSH     {r4,lr}
        0x00810ff8:    8841        A.      LDRH     r1,[r0,#2]
        0x00810ffa:    2401        .$      MOVS     r4,#1
        0x00810ffc:    f5a17180    ...q    SUB      r1,r1,#0x100
        0x00811000:    39d1        .9      SUBS     r1,r1,#0xd1
        0x00811002:    d002        ..      BEQ      0x81100a ; le_handle_read_remote_version_btif_msg + 20
        0x00811004:    2400        .$      MOVS     r4,#0
        0x00811006:    4620         F      MOV      r0,r4
        0x00811008:    bd10        ..      POP      {r4,pc}
        0x0081100a:    1d00        ..      ADDS     r0,r0,#4
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (612)
        0x0081100c:    f7ffffd2    ....    BL       le_handle_read_remote_version_rsp ; 0x810fb4
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (613)
        0x00811010:    e7f9        ..      B        0x811006 ; le_handle_read_remote_version_btif_msg + 16
    le_write_authen_payload_timeout
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (625)
        0x00811012:    b570        p.      PUSH     {r4-r6,lr}
        0x00811014:    460c        .F      MOV      r4,r1
        0x00811016:    4605        .F      MOV      r5,r0
        0x00811018:    4601        .F      MOV      r1,r0
        0x0081101a:    483d        =H      LDR      r0,[pc,#244] ; [0x811110] = 0x811bbc
        0x0081101c:    b086        ..      SUB      sp,sp,#0x18
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (626)
        0x0081101e:    3017        .0      ADDS     r0,r0,#0x17
        0x00811020:    f43cf4fa    <...    BL       le_link_check_conn_id_internal ; 0x4da18
        0x00811024:    b390        ..      CBZ      r0,0x81108c ; le_write_authen_payload_timeout + 122
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (628)
        0x00811026:    1e61        a.      SUBS     r1,r4,#1
        0x00811028:    f64f72ff    O..r    MOV      r2,#0xffff
        0x0081102c:    4b39        9K      LDR      r3,[pc,#228] ; [0x811114] = 0x202e64
        0x0081102e:    eb050045    ..E.    ADD      r0,r5,r5,LSL #1
        0x00811032:    4291        .B      CMP      r1,r2
        0x00811034:    d20e        ..      BCS      0x811054 ; le_write_authen_payload_timeout + 66
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (629)
        0x00811036:    6819        .h      LDR      r1,[r3,#0]
        0x00811038:    eb011100    ....    ADD      r1,r1,r0,LSL #4
        0x0081103c:    8a8a        ..      LDRH     r2,[r1,#0x14]
        0x0081103e:    eb020282    ....    ADD      r2,r2,r2,LSL #2
        0x00811042:    0896        ..      LSRS     r6,r2,#2
        0x00811044:    8aca        ..      LDRH     r2,[r1,#0x16]
        0x00811046:    1c52        R.      ADDS     r2,r2,#1
        0x00811048:    4356        VC      MULS     r6,r2,r6
        0x0081104a:    eb040284    ....    ADD      r2,r4,r4,LSL #2
        0x0081104e:    ebb60f42    ..B.    CMP      r6,r2,LSL #1
        0x00811052:    dd1c        ..      BLE      0x81108e ; le_write_authen_payload_timeout + 124
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (632)
        0x00811054:    6819        .h      LDR      r1,[r3,#0]
        0x00811056:    eb011000    ....    ADD      r0,r1,r0,LSL #4
        0x0081105a:    8a81        ..      LDRH     r1,[r0,#0x14]
        0x0081105c:    8ac0        ..      LDRH     r0,[r0,#0x16]
        0x0081105e:    eb010281    ....    ADD      r2,r1,r1,LSL #2
        0x00811062:    0892        ..      LSRS     r2,r2,#2
        0x00811064:    1c43        C.      ADDS     r3,r0,#1
        0x00811066:    435a        ZC      MULS     r2,r3,r2
        0x00811068:    eb040384    ....    ADD      r3,r4,r4,LSL #2
        0x0081106c:    005b        [.      LSLS     r3,r3,#1
        0x0081106e:    e9cd4100    ...A    STRD     r4,r1,[sp,#0]
        0x00811072:    e9cd0302    ....    STRD     r0,r3,[sp,#8]
        0x00811076:    4923        #I      LDR      r1,[pc,#140] ; [0x811104] = 0x8801140
        0x00811078:    9204        ..      STR      r2,[sp,#0x10]
        0x0081107a:    462b        +F      MOV      r3,r5
        0x0081107c:    2206        ."      MOVS     r2,#6
        0x0081107e:    31c4        .1      ADDS     r1,r1,#0xc4
        0x00811080:    481f        .H      LDR      r0,[pc,#124] ; [0x811100] = 0x21103500
        0x00811082:    f7f6dcec    ....    BL       log_buffer ; 0x7a5e
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (636)
        0x00811086:    2003        .       MOVS     r0,#3
        0x00811088:    b006        ..      ADD      sp,sp,#0x18
        0x0081108a:    bd70        p.      POP      {r4-r6,pc}
        0x0081108c:    e015        ..      B        0x8110ba ; le_write_authen_payload_timeout + 168
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (640)
        0x0081108e:    8a08        ..      LDRH     r0,[r1,#0x10]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (642)
        0x00811090:    f88d0014    ....    STRB     r0,[sp,#0x14]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (643)
        0x00811094:    0a00        ..      LSRS     r0,r0,#8
        0x00811096:    f88d0015    ....    STRB     r0,[sp,#0x15]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (644)
        0x0081109a:    f88d4016    ...@    STRB     r4,[sp,#0x16]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (645)
        0x0081109e:    0a20         .      LSRS     r0,r4,#8
        0x008110a0:    f88d0017    ....    STRB     r0,[sp,#0x17]
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (649)
        0x008110a4:    aa05        ..      ADD      r2,sp,#0x14
        0x008110a6:    2104        .!      MOVS     r1,#4
        0x008110a8:    f640407c    @.|@    MOV      r0,#0xc7c
        0x008110ac:    f410f21e    ....    BL       btif_vendor_cmd_req ; 0x214ec
        0x008110b0:    b108        ..      CBZ      r0,0x8110b6 ; le_write_authen_payload_timeout + 164
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (651)
        0x008110b2:    2000        .       MOVS     r0,#0
        0x008110b4:    e7e8        ..      B        0x811088 ; le_write_authen_payload_timeout + 118
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (653)
        0x008110b6:    2007        .       MOVS     r0,#7
        0x008110b8:    e7e6        ..      B        0x811088 ; le_write_authen_payload_timeout + 118
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (657)
        0x008110ba:    2004        .       MOVS     r0,#4
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (659)
        0x008110bc:    e7e4        ..      B        0x811088 ; le_write_authen_payload_timeout + 118
    client_send_exchange_mtu_req
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (666)
        0x008110be:    b510        ..      PUSH     {r4,lr}
        0x008110c0:    4604        .F      MOV      r4,r0
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (667)
        0x008110c2:    4601        .F      MOV      r1,r0
        0x008110c4:    4812        .H      LDR      r0,[pc,#72] ; [0x811110] = 0x811bbc
        0x008110c6:    3037        70      ADDS     r0,r0,#0x37
        0x008110c8:    f43cf4a6    <...    BL       le_link_check_conn_id_internal ; 0x4da18
        0x008110cc:    b1a0        ..      CBZ      r0,0x8110f8 ; client_send_exchange_mtu_req + 58
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (669)
        0x008110ce:    4911        .I      LDR      r1,[pc,#68] ; [0x811114] = 0x202e64
        0x008110d0:    eb040044    ..D.    ADD      r0,r4,r4,LSL #1
        0x008110d4:    6809        .h      LDR      r1,[r1,#0]
        0x008110d6:    eb011000    ....    ADD      r0,r1,r0,LSL #4
        0x008110da:    8a00        ..      LDRH     r0,[r0,#0x10]
        0x008110dc:    f40ef189    ....    BL       gatt_find_chann_by_handle ; 0x1f3f2
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (671)
        0x008110e0:    b140        @.      CBZ      r0,0x8110f4 ; client_send_exchange_mtu_req + 54
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (673)
        0x008110e2:    8d41        A.      LDRH     r1,[r0,#0x2a]
        0x008110e4:    2917        .)      CMP      r1,#0x17
        0x008110e6:    d303        ..      BCC      0x8110f0 ; client_send_exchange_mtu_req + 50
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (675)
        0x008110e8:    f40bf35f    .._.    BL       att_send_mtu_req ; 0x1c7aa
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (676)
        0x008110ec:    2000        .       MOVS     r0,#0
        0x008110ee:    bd10        ..      POP      {r4,pc}
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (680)
        0x008110f0:    2003        .       MOVS     r0,#3
        0x008110f2:    bd10        ..      POP      {r4,pc}
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (685)
        0x008110f4:    200a        .       MOVS     r0,#0xa
        0x008110f6:    bd10        ..      POP      {r4,pc}
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (690)
        0x008110f8:    2004        .       MOVS     r0,#4
;;; ..\..\..\src\app\gap_lib\8762\common\gap_lib_patch.c (692)
        0x008110fa:    bd10        ..      POP      {r4,pc}
    $d
        0x008110fc:    00202eee    .. .    DCD    2109166
        0x00811100:    21103500    .5.!    DCD    554710272
        0x00811104:    08801140    @...    DCD    142610752
        0x00811108:    00202ef0    .. .    DCD    2109168
        0x0081110c:    00202ee0    .. .    DCD    2109152
        0x00811110:    00811bbc    ....    DCD    8461244
        0x00811114:    00202e64    d. .    DCD    2109028
        0x00811118:    00202e48    H. .    DCD    2109000
    $t
    .text
    gap_register_vendor_cb
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (85)
        0x0081111c:    49fd        .I      LDR      r1,[pc,#1012] ; [0x811514] = 0x207f14
        0x0081111e:    6008        .`      STR      r0,[r1,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (86)
        0x00811120:    4770        pG      BX       lr
    gap_set_lps_bootup_active_time
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (91)
        0x00811122:    b508        ..      PUSH     {r3,lr}
        0x00811124:    1ec1        ..      SUBS     r1,r0,#3
        0x00811126:    f24072fe    @..r    MOV      r2,#0x7fe
        0x0081112a:    4291        .B      CMP      r1,r2
        0x0081112c:    d301        ..      BCC      0x811132 ; gap_set_lps_bootup_active_time + 16
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (96)
        0x0081112e:    2000        .       MOVS     r0,#0
        0x00811130:    bd08        ..      POP      {r3,pc}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (98)
        0x00811132:    2105        .!      MOVS     r1,#5
        0x00811134:    f88d1000    ....    STRB     r1,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (99)
        0x00811138:    f88d0001    ....    STRB     r0,[sp,#1]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (100)
        0x0081113c:    0a00        ..      LSRS     r0,r0,#8
        0x0081113e:    f88d0002    ....    STRB     r0,[sp,#2]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (102)
        0x00811142:    466a        jF      MOV      r2,sp
        0x00811144:    2103        .!      MOVS     r1,#3
        0x00811146:    f64f406e    O.n@    MOV      r0,#0xfc6e
        0x0081114a:    f410f1cf    ....    BL       btif_vendor_cmd_req ; 0x214ec
        0x0081114e:    2800        .(      CMP      r0,#0
        0x00811150:    d0ee        ..      BEQ      0x811130 ; gap_set_lps_bootup_active_time + 14
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (104)
        0x00811152:    2001        .       MOVS     r0,#1
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (107)
        0x00811154:    bd08        ..      POP      {r3,pc}
    lps_get_wakeup_time
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (110)
        0x00811156:    b530        0.      PUSH     {r4,r5,lr}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (111)
        0x00811158:    4bef        .K      LDR      r3,[pc,#956] ; [0x811518] = 0x201b1c
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (112)
        0x0081115a:    681d        .h      LDR      r5,[r3,#0]
        0x0081115c:    1d1b        ..      ADDS     r3,r3,#4
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (113)
        0x0081115e:    681c        .h      LDR      r4,[r3,#0]
        0x00811160:    1d1b        ..      ADDS     r3,r3,#4
        0x00811162:    681b        .h      LDR      r3,[r3,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (115)
        0x00811164:    6005        .`      STR      r5,[r0,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (116)
        0x00811166:    600c        .`      STR      r4,[r1,#0]
        0x00811168:    6013        .`      STR      r3,[r2,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (117)
        0x0081116a:    bd30        0.      POP      {r4,r5,pc}
    le_vendor_trigger_internal_32k_calibration
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (218)
        0x0081116c:    b508        ..      PUSH     {r3,lr}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (220)
        0x0081116e:    200f        .       MOVS     r0,#0xf
        0x00811170:    f88d0000    ....    STRB     r0,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (222)
        0x00811174:    466a        jF      MOV      r2,sp
        0x00811176:    2101        .!      MOVS     r1,#1
        0x00811178:    f64f5080    O..P    MOV      r0,#0xfd80
        0x0081117c:    f410f1b6    ....    BL       btif_vendor_cmd_req ; 0x214ec
        0x00811180:    b108        ..      CBZ      r0,0x811186 ; le_vendor_trigger_internal_32k_calibration + 26
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (224)
        0x00811182:    2000        .       MOVS     r0,#0
        0x00811184:    bd08        ..      POP      {r3,pc}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (226)
        0x00811186:    2007        .       MOVS     r0,#7
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (227)
        0x00811188:    bd08        ..      POP      {r3,pc}
    le_handle_vendor_cmd_rsp
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (231)
        0x0081118a:    e92d43f8    -..C    PUSH     {r3-r9,lr}
        0x0081118e:    8801        ..      LDRH     r1,[r0,#0]
        0x00811190:    f64f5880    O..X    MOV      r8,#0xfd80
        0x00811194:    4de1        .M      LDR      r5,[pc,#900] ; [0x81151c] = 0x202e48
        0x00811196:    4604        .F      MOV      r4,r0
        0x00811198:    4541        AE      CMP      r1,r8
        0x0081119a:    d121        !.      BNE      0x8111e0 ; le_handle_vendor_cmd_rsp + 86
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (238)
        0x0081119c:    79a0        .y      LDRB     r0,[r4,#6]
        0x0081119e:    280f        .(      CMP      r0,#0xf
        0x008111a0:    d004        ..      BEQ      0x8111ac ; le_handle_vendor_cmd_rsp + 34
        0x008111a2:    2813        .(      CMP      r0,#0x13
        0x008111a4:    d007        ..      BEQ      0x8111b6 ; le_handle_vendor_cmd_rsp + 44
        0x008111a6:    2814        .(      CMP      r0,#0x14
        0x008111a8:    d11a        ..      BNE      0x8111e0 ; le_handle_vendor_cmd_rsp + 86
        0x008111aa:    e009        ..      B        0x8111c0 ; le_handle_vendor_cmd_rsp + 54
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (298)
        0x008111ac:    8860        `.      LDRH     r0,[r4,#2]
        0x008111ae:    f8ad0000    ....    STRH     r0,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (299)
        0x008111b2:    20ac        .       MOVS     r0,#0xac
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (301)
        0x008111b4:    e010        ..      B        0x8111d8 ; le_handle_vendor_cmd_rsp + 78
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (314)
        0x008111b6:    8860        `.      LDRH     r0,[r4,#2]
        0x008111b8:    f8ad0000    ....    STRH     r0,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (315)
        0x008111bc:    20a8        .       MOVS     r0,#0xa8
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (317)
        0x008111be:    e00b        ..      B        0x8111d8 ; le_handle_vendor_cmd_rsp + 78
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (322)
        0x008111c0:    79e0        .y      LDRB     r0,[r4,#7]
        0x008111c2:    7a21        !z      LDRB     r1,[r4,#8]
        0x008111c4:    7aa2        .z      LDRB     r2,[r4,#0xa]
        0x008111c6:    eb002001    ...     ADD      r0,r0,r1,LSL #8
        0x008111ca:    7a61        az      LDRB     r1,[r4,#9]
        0x008111cc:    0409        ..      LSLS     r1,r1,#16
        0x008111ce:    eb016102    ...a    ADD      r1,r1,r2,LSL #24
        0x008111d2:    4408        .D      ADD      r0,r0,r1
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (324)
        0x008111d4:    9000        ..      STR      r0,[sp,#0]
        0x008111d6:    20ae        .       MOVS     r0,#0xae
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (333)
        0x008111d8:    682a        *h      LDR      r2,[r5,#0]
        0x008111da:    b10a        ..      CBZ      r2,0x8111e0 ; le_handle_vendor_cmd_rsp + 86
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (335)
        0x008111dc:    4669        iF      MOV      r1,sp
        0x008111de:    4790        .G      BLX      r2
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (341)
        0x008111e0:    8820         .      LDRH     r0,[r4,#0]
        0x008111e2:    f64f466e    O.nF    MOV      r6,#0xfc6e
        0x008111e6:    42b0        .B      CMP      r0,r6
        0x008111e8:    d107        ..      BNE      0x8111fa ; le_handle_vendor_cmd_rsp + 112
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (347)
        0x008111ea:    7960        `y      LDRB     r0,[r4,#5]
        0x008111ec:    b928        (.      CBNZ     r0,0x8111fa ; le_handle_vendor_cmd_rsp + 112
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (349)
        0x008111ee:    8860        `.      LDRH     r0,[r4,#2]
        0x008111f0:    f8ad0000    ....    STRH     r0,[sp,#0]
        0x008111f4:    682a        *h      LDR      r2,[r5,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (350)
        0x008111f6:    20a6        .       MOVS     r0,#0xa6
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (351)
        0x008111f8:    bb62        b.      CBNZ     r2,0x811254 ; le_handle_vendor_cmd_rsp + 202
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (365)
        0x008111fa:    8820         .      LDRH     r0,[r4,#0]
        0x008111fc:    f64f5782    O..W    MOV      r7,#0xfd82
        0x00811200:    42b8        .B      CMP      r0,r7
        0x00811202:    d11c        ..      BNE      0x81123e ; le_handle_vendor_cmd_rsp + 180
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (371)
        0x00811204:    79a0        .y      LDRB     r0,[r4,#6]
        0x00811206:    2805        .(      CMP      r0,#5
        0x00811208:    d119        ..      BNE      0x81123e ; le_handle_vendor_cmd_rsp + 180
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (376)
        0x0081120a:    79e0        .y      LDRB     r0,[r4,#7]
        0x0081120c:    2809        .(      CMP      r0,#9
        0x0081120e:    d004        ..      BEQ      0x81121a ; le_handle_vendor_cmd_rsp + 144
        0x00811210:    281e        .(      CMP      r0,#0x1e
        0x00811212:    d007        ..      BEQ      0x811224 ; le_handle_vendor_cmd_rsp + 154
        0x00811214:    281f        .(      CMP      r0,#0x1f
        0x00811216:    d112        ..      BNE      0x81123e ; le_handle_vendor_cmd_rsp + 180
        0x00811218:    e009        ..      B        0x81122e ; le_handle_vendor_cmd_rsp + 164
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (381)
        0x0081121a:    8860        `.      LDRH     r0,[r4,#2]
        0x0081121c:    f8ad0000    ....    STRH     r0,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (382)
        0x00811220:    20ab        .       MOVS     r0,#0xab
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (384)
        0x00811222:    e008        ..      B        0x811236 ; le_handle_vendor_cmd_rsp + 172
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (399)
        0x00811224:    8860        `.      LDRH     r0,[r4,#2]
        0x00811226:    f8ad0000    ....    STRH     r0,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (400)
        0x0081122a:    20aa        .       MOVS     r0,#0xaa
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (402)
        0x0081122c:    e003        ..      B        0x811236 ; le_handle_vendor_cmd_rsp + 172
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (405)
        0x0081122e:    8860        `.      LDRH     r0,[r4,#2]
        0x00811230:    f8ad0000    ....    STRH     r0,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (406)
        0x00811234:    20ad        .       MOVS     r0,#0xad
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (425)
        0x00811236:    682a        *h      LDR      r2,[r5,#0]
        0x00811238:    b10a        ..      CBZ      r2,0x81123e ; le_handle_vendor_cmd_rsp + 180
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (427)
        0x0081123a:    4669        iF      MOV      r1,sp
        0x0081123c:    4790        .G      BLX      r2
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (432)
        0x0081123e:    8820         .      LDRH     r0,[r4,#0]
        0x00811240:    f5a0417d    ..}A    SUB      r1,r0,#0xfd00
        0x00811244:    3987        .9      SUBS     r1,r1,#0x87
        0x00811246:    d109        ..      BNE      0x81125c ; le_handle_vendor_cmd_rsp + 210
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (437)
        0x00811248:    8860        `.      LDRH     r0,[r4,#2]
        0x0081124a:    f8ad0000    ....    STRH     r0,[sp,#0]
        0x0081124e:    682a        *h      LDR      r2,[r5,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (438)
        0x00811250:    20af        .       MOVS     r0,#0xaf
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (450)
        0x00811252:    b11a        ..      CBZ      r2,0x81125c ; le_handle_vendor_cmd_rsp + 210
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (454)
        0x00811254:    4669        iF      MOV      r1,sp
        0x00811256:    4790        .G      BLX      r2
        0x00811258:    e8bd83f8    ....    POP      {r3-r9,pc}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (461)
        0x0081125c:    8820         .      LDRH     r0,[r4,#0]
        0x0081125e:    4540        @E      CMP      r0,r8
        0x00811260:    d0fa        ..      BEQ      0x811258 ; le_handle_vendor_cmd_rsp + 206
        0x00811262:    f5a0417d    ..}A    SUB      r1,r0,#0xfd00
        0x00811266:    3981        .9      SUBS     r1,r1,#0x81
        0x00811268:    d0f6        ..      BEQ      0x811258 ; le_handle_vendor_cmd_rsp + 206
        0x0081126a:    42b8        .B      CMP      r0,r7
        0x0081126c:    d0f4        ..      BEQ      0x811258 ; le_handle_vendor_cmd_rsp + 206
        0x0081126e:    42b0        .B      CMP      r0,r6
        0x00811270:    d0f2        ..      BEQ      0x811258 ; le_handle_vendor_cmd_rsp + 206
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (464)
        0x00811272:    48ab        .H      LDR      r0,[pc,#684] ; [0x811520] = 0x202df4
        0x00811274:    6802        .h      LDR      r2,[r0,#0]
        0x00811276:    2a00        .*      CMP      r2,#0
        0x00811278:    d0ee        ..      BEQ      0x811258 ; le_handle_vendor_cmd_rsp + 206
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (467)
        0x0081127a:    2003        .       MOVS     r0,#3
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (469)
        0x0081127c:    4669        iF      MOV      r1,sp
        0x0081127e:    9400        ..      STR      r4,[sp,#0]
        0x00811280:    4790        .G      BLX      r2
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (472)
        0x00811282:    e7e9        ..      B        0x811258 ; le_handle_vendor_cmd_rsp + 206
    gap_vendor_cmd_req
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (476)
        0x00811284:    b510        ..      PUSH     {r4,lr}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (477)
        0x00811286:    f410f131    ..1.    BL       btif_vendor_cmd_req ; 0x214ec
        0x0081128a:    b108        ..      CBZ      r0,0x811290 ; gap_vendor_cmd_req + 12
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (479)
        0x0081128c:    2000        .       MOVS     r0,#0
        0x0081128e:    bd10        ..      POP      {r4,pc}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (481)
        0x00811290:    2007        .       MOVS     r0,#7
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (482)
        0x00811292:    bd10        ..      POP      {r4,pc}
    le_handle_vendor_evt_info
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (485)
        0x00811294:    4601        .F      MOV      r1,r0
        0x00811296:    48a2        .H      LDR      r0,[pc,#648] ; [0x811520] = 0x202df4
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (485)
        0x00811298:    b508        ..      PUSH     {r3,lr}
        0x0081129a:    6802        .h      LDR      r2,[r0,#0]
        0x0081129c:    2a00        .*      CMP      r2,#0
        0x0081129e:    d003        ..      BEQ      0x8112a8 ; le_handle_vendor_evt_info + 20
        0x008112a0:    9100        ..      STR      r1,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (489)
        0x008112a2:    2004        .       MOVS     r0,#4
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (491)
        0x008112a4:    4669        iF      MOV      r1,sp
        0x008112a6:    4790        .G      BLX      r2
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (493)
        0x008112a8:    bd08        ..      POP      {r3,pc}
    le_vendor_modify_bt_le_fw_policy
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (498)
        0x008112aa:    b50e        ..      PUSH     {r1-r3,lr}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (501)
        0x008112ac:    2210        ."      MOVS     r2,#0x10
        0x008112ae:    f88d2000    ...     STRB     r2,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (502)
        0x008112b2:    f88d0001    ....    STRB     r0,[sp,#1]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (503)
        0x008112b6:    0a02        ..      LSRS     r2,r0,#8
        0x008112b8:    f88d2002    ...     STRB     r2,[sp,#2]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (504)
        0x008112bc:    0c02        ..      LSRS     r2,r0,#16
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (505)
        0x008112be:    0e00        ..      LSRS     r0,r0,#24
        0x008112c0:    f88d0004    ....    STRB     r0,[sp,#4]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (506)
        0x008112c4:    f88d1005    ....    STRB     r1,[sp,#5]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (507)
        0x008112c8:    0a08        ..      LSRS     r0,r1,#8
        0x008112ca:    f88d0006    ....    STRB     r0,[sp,#6]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (508)
        0x008112ce:    0c08        ..      LSRS     r0,r1,#16
        0x008112d0:    f88d0007    ....    STRB     r0,[sp,#7]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (509)
        0x008112d4:    0e08        ..      LSRS     r0,r1,#24
        0x008112d6:    f88d2003    ...     STRB     r2,[sp,#3]
        0x008112da:    f88d0008    ....    STRB     r0,[sp,#8]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (511)
        0x008112de:    466a        jF      MOV      r2,sp
        0x008112e0:    2109        .!      MOVS     r1,#9
        0x008112e2:    f64f5080    O..P    MOV      r0,#0xfd80
        0x008112e6:    f410f101    ....    BL       btif_vendor_cmd_req ; 0x214ec
        0x008112ea:    b108        ..      CBZ      r0,0x8112f0 ; le_vendor_modify_bt_le_fw_policy + 70
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (513)
        0x008112ec:    2000        .       MOVS     r0,#0
        0x008112ee:    bd0e        ..      POP      {r1-r3,pc}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (515)
        0x008112f0:    2007        .       MOVS     r0,#7
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (522)
        0x008112f2:    bd0e        ..      POP      {r1-r3,pc}
    le_vendor_check_priority_level
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (543)
        0x008112f4:    280a        .(      CMP      r0,#0xa
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (542)
        0x008112f6:    d901        ..      BLS      0x8112fc ; le_vendor_check_priority_level + 8
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (545)
        0x008112f8:    2000        .       MOVS     r0,#0
        0x008112fa:    4770        pG      BX       lr
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (547)
        0x008112fc:    2001        .       MOVS     r0,#1
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (548)
        0x008112fe:    4770        pG      BX       lr
    le_vendor_set_priority
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (551)
        0x00811300:    b530        0.      PUSH     {r4,r5,lr}
        0x00811302:    b08b        ..      SUB      sp,sp,#0x2c
        0x00811304:    4604        .F      MOV      r4,r0
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (553)
        0x00811306:    212c        ,!      MOVS     r1,#0x2c
        0x00811308:    4668        hF      MOV      r0,sp
        0x0081130a:    f448f6a9    H...    BL       __aeabi_memclr4 ; 0x5a060
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (554)
        0x0081130e:    2013        .       MOVS     r0,#0x13
        0x00811310:    f88d0000    ....    STRB     r0,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (556)
        0x00811314:    7820         x      LDRB     r0,[r4,#0]
        0x00811316:    2200        ."      MOVS     r2,#0
        0x00811318:    2101        .!      MOVS     r1,#1
        0x0081131a:    2802        .(      CMP      r0,#2
        0x0081131c:    d003        ..      BEQ      0x811326 ; le_vendor_set_priority + 38
        0x0081131e:    2801        .(      CMP      r0,#1
        0x00811320:    d007        ..      BEQ      0x811332 ; le_vendor_set_priority + 50
        0x00811322:    b148        H.      CBZ      r0,0x811338 ; le_vendor_set_priority + 56
        0x00811324:    e090        ..      B        0x811448 ; le_vendor_set_priority + 328
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (558)
        0x00811326:    f88d1001    ....    STRB     r1,[sp,#1]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (559)
        0x0081132a:    f88d2002    ...     STRB     r2,[sp,#2]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (560)
        0x0081132e:    2103        .!      MOVS     r1,#3
        0x00811330:    e082        ..      B        0x811438 ; le_vendor_set_priority + 312
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (566)
        0x00811332:    f88d1001    ....    STRB     r1,[sp,#1]
        0x00811336:    e001        ..      B        0x81133c ; le_vendor_set_priority + 60
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (570)
        0x00811338:    f88d2001    ...     STRB     r2,[sp,#1]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (577)
        0x0081133c:    79e0        .y      LDRB     r0,[r4,#7]
        0x0081133e:    2802        .(      CMP      r0,#2
        0x00811340:    d10d        ..      BNE      0x81135e ; le_vendor_set_priority + 94
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (579)
        0x00811342:    7a20         z      LDRB     r0,[r4,#8]
        0x00811344:    f7ffffd6    ....    BL       le_vendor_check_priority_level ; 0x8112f4
        0x00811348:    2800        .(      CMP      r0,#0
        0x0081134a:    d07d        }.      BEQ      0x811448 ; le_vendor_set_priority + 328
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (581)
        0x0081134c:    f89d0002    ....    LDRB     r0,[sp,#2]
        0x00811350:    f0400001    @...    ORR      r0,r0,#1
        0x00811354:    f88d0002    ....    STRB     r0,[sp,#2]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (582)
        0x00811358:    7a20         z      LDRB     r0,[r4,#8]
        0x0081135a:    f88d0003    ....    STRB     r0,[sp,#3]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (590)
        0x0081135e:    7860        `x      LDRB     r0,[r4,#1]
        0x00811360:    2801        .(      CMP      r0,#1
        0x00811362:    d10d        ..      BNE      0x811380 ; le_vendor_set_priority + 128
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (592)
        0x00811364:    78a0        .x      LDRB     r0,[r4,#2]
        0x00811366:    f7ffffc5    ....    BL       le_vendor_check_priority_level ; 0x8112f4
        0x0081136a:    2800        .(      CMP      r0,#0
        0x0081136c:    d06c        l.      BEQ      0x811448 ; le_vendor_set_priority + 328
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (594)
        0x0081136e:    f89d0002    ....    LDRB     r0,[sp,#2]
        0x00811372:    f0400004    @...    ORR      r0,r0,#4
        0x00811376:    f88d0002    ....    STRB     r0,[sp,#2]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (595)
        0x0081137a:    78a0        .x      LDRB     r0,[r4,#2]
        0x0081137c:    f88d0004    ....    STRB     r0,[sp,#4]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (603)
        0x00811380:    7960        `y      LDRB     r0,[r4,#5]
        0x00811382:    2801        .(      CMP      r0,#1
        0x00811384:    d10c        ..      BNE      0x8113a0 ; le_vendor_set_priority + 160
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (605)
        0x00811386:    79a0        .y      LDRB     r0,[r4,#6]
        0x00811388:    f7ffffb4    ....    BL       le_vendor_check_priority_level ; 0x8112f4
        0x0081138c:    b3e0        ..      CBZ      r0,0x811408 ; le_vendor_set_priority + 264
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (607)
        0x0081138e:    f89d0002    ....    LDRB     r0,[sp,#2]
        0x00811392:    f0400008    @...    ORR      r0,r0,#8
        0x00811396:    f88d0002    ....    STRB     r0,[sp,#2]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (608)
        0x0081139a:    79a0        .y      LDRB     r0,[r4,#6]
        0x0081139c:    f88d0005    ....    STRB     r0,[sp,#5]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (616)
        0x008113a0:    78e0        .x      LDRB     r0,[r4,#3]
        0x008113a2:    2801        .(      CMP      r0,#1
        0x008113a4:    d10c        ..      BNE      0x8113c0 ; le_vendor_set_priority + 192
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (618)
        0x008113a6:    7920         y      LDRB     r0,[r4,#4]
        0x008113a8:    f7ffffa4    ....    BL       le_vendor_check_priority_level ; 0x8112f4
        0x008113ac:    b360        `.      CBZ      r0,0x811408 ; le_vendor_set_priority + 264
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (620)
        0x008113ae:    f89d0002    ....    LDRB     r0,[sp,#2]
        0x008113b2:    f0400010    @...    ORR      r0,r0,#0x10
        0x008113b6:    f88d0002    ....    STRB     r0,[sp,#2]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (621)
        0x008113ba:    7920         y      LDRB     r0,[r4,#4]
        0x008113bc:    f88d0006    ....    STRB     r0,[sp,#6]
        0x008113c0:    79e0        .y      LDRB     r0,[r4,#7]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (629)
        0x008113c2:    2107        .!      MOVS     r1,#7
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (631)
        0x008113c4:    2801        .(      CMP      r0,#1
        0x008113c6:    d137        7.      BNE      0x811438 ; le_vendor_set_priority + 312
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (633)
        0x008113c8:    7a60        `z      LDRB     r0,[r4,#9]
        0x008113ca:    1e40        @.      SUBS     r0,r0,#1
        0x008113cc:    280b        .(      CMP      r0,#0xb
        0x008113ce:    d23b        ;.      BCS      0x811448 ; le_vendor_set_priority + 328
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (640)
        0x008113d0:    f89d0002    ....    LDRB     r0,[sp,#2]
        0x008113d4:    2100        .!      MOVS     r1,#0
        0x008113d6:    f0400002    @...    ORR      r0,r0,#2
        0x008113da:    f88d0002    ....    STRB     r0,[sp,#2]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (641)
        0x008113de:    7a60        `z      LDRB     r0,[r4,#9]
        0x008113e0:    f88d0007    ....    STRB     r0,[sp,#7]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (643)
        0x008113e4:    e01f        ..      B        0x811426 ; le_vendor_set_priority + 294
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (645)
        0x008113e6:    eb040041    ..A.    ADD      r0,r4,r1,LSL #1
        0x008113ea:    7a82        .z      LDRB     r2,[r0,#0xa]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (646)
        0x008113ec:    eb020342    ..B.    ADD      r3,r2,r2,LSL #1
        0x008113f0:    4a4c        LJ      LDR      r2,[pc,#304] ; [0x811524] = 0x202e64
        0x008113f2:    6812        .h      LDR      r2,[r2,#0]
        0x008113f4:    eb021303    ....    ADD      r3,r2,r3,LSL #4
        0x008113f8:    8a1a        ..      LDRH     r2,[r3,#0x10]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (647)
        0x008113fa:    785d        ]x      LDRB     r5,[r3,#1]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (648)
        0x008113fc:    7ac3        .z      LDRB     r3,[r0,#0xb]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (650)
        0x008113fe:    2d02        .-      CMP      r5,#2
        0x00811400:    d003        ..      BEQ      0x81140a ; le_vendor_set_priority + 266
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (652)
        0x00811402:    2002        .       MOVS     r0,#2
        0x00811404:    b00b        ..      ADD      sp,sp,#0x2c
        0x00811406:    bd30        0.      POP      {r4,r5,pc}
        0x00811408:    e01e        ..      B        0x811448 ; le_vendor_set_priority + 328
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (654)
        0x0081140a:    4618        .F      MOV      r0,r3
        0x0081140c:    f7ffff72    ..r.    BL       le_vendor_check_priority_level ; 0x8112f4
        0x00811410:    b1d0        ..      CBZ      r0,0x811448 ; le_vendor_set_priority + 328
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (659)
        0x00811412:    eb010541    ..A.    ADD      r5,r1,r1,LSL #1
        0x00811416:    4668        hF      MOV      r0,sp
        0x00811418:    4428        (D      ADD      r0,r0,r5
        0x0081141a:    7202        .r      STRB     r2,[r0,#8]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (660)
        0x0081141c:    0a12        ..      LSRS     r2,r2,#8
        0x0081141e:    7242        Br      STRB     r2,[r0,#9]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (661)
        0x00811420:    1c49        I.      ADDS     r1,r1,#1
        0x00811422:    7283        .r      STRB     r3,[r0,#0xa]
        0x00811424:    b2c9        ..      UXTB     r1,r1
        0x00811426:    f89d0007    ....    LDRB     r0,[sp,#7]
        0x0081142a:    4288        .B      CMP      r0,r1
        0x0081142c:    d8db        ..      BHI      0x8113e6 ; le_vendor_set_priority + 230
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (664)
        0x0081142e:    b2c0        ..      UXTB     r0,r0
        0x00811430:    eb000040    ..@.    ADD      r0,r0,r0,LSL #1
        0x00811434:    3008        .0      ADDS     r0,r0,#8
        0x00811436:    b2c1        ..      UXTB     r1,r0
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (673)
        0x00811438:    466a        jF      MOV      r2,sp
        0x0081143a:    f64f5080    O..P    MOV      r0,#0xfd80
        0x0081143e:    f410f055    ..U.    BL       btif_vendor_cmd_req ; 0x214ec
        0x00811442:    b118        ..      CBZ      r0,0x81144c ; le_vendor_set_priority + 332
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (675)
        0x00811444:    2000        .       MOVS     r0,#0
        0x00811446:    e7dd        ..      B        0x811404 ; le_vendor_set_priority + 260
        0x00811448:    2003        .       MOVS     r0,#3
        0x0081144a:    e7db        ..      B        0x811404 ; le_vendor_set_priority + 260
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (677)
        0x0081144c:    2007        .       MOVS     r0,#7
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (678)
        0x0081144e:    e7d9        ..      B        0x811404 ; le_vendor_set_priority + 260
    le_vendor_more_precise_32k_option
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (683)
        0x00811450:    b508        ..      PUSH     {r3,lr}
        0x00811452:    2105        .!      MOVS     r1,#5
        0x00811454:    f88d1000    ....    STRB     r1,[sp,#0]
        0x00811458:    2109        .!      MOVS     r1,#9
        0x0081145a:    f88d1001    ....    STRB     r1,[sp,#1]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (683)
        0x0081145e:    b100        ..      CBZ      r0,0x811462 ; le_vendor_more_precise_32k_option + 18
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (690)
        0x00811460:    2001        .       MOVS     r0,#1
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (694)
        0x00811462:    f88d0002    ....    STRB     r0,[sp,#2]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (697)
        0x00811466:    466a        jF      MOV      r2,sp
        0x00811468:    2103        .!      MOVS     r1,#3
        0x0081146a:    f64f5082    O..P    MOV      r0,#0xfd82
        0x0081146e:    f410f03d    ..=.    BL       btif_vendor_cmd_req ; 0x214ec
        0x00811472:    b108        ..      CBZ      r0,0x811478 ; le_vendor_more_precise_32k_option + 40
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (699)
        0x00811474:    2000        .       MOVS     r0,#0
        0x00811476:    bd08        ..      POP      {r3,pc}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (701)
        0x00811478:    2007        .       MOVS     r0,#7
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (702)
        0x0081147a:    bd08        ..      POP      {r3,pc}
    le_vendor_measure_master_clk_freq_mode
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (723)
        0x0081147c:    b508        ..      PUSH     {r3,lr}
        0x0081147e:    2105        .!      MOVS     r1,#5
        0x00811480:    f88d1000    ....    STRB     r1,[sp,#0]
        0x00811484:    211e        .!      MOVS     r1,#0x1e
        0x00811486:    f88d1001    ....    STRB     r1,[sp,#1]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (723)
        0x0081148a:    b100        ..      CBZ      r0,0x81148e ; le_vendor_measure_master_clk_freq_mode + 18
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (730)
        0x0081148c:    2001        .       MOVS     r0,#1
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (734)
        0x0081148e:    f88d0002    ....    STRB     r0,[sp,#2]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (737)
        0x00811492:    466a        jF      MOV      r2,sp
        0x00811494:    2103        .!      MOVS     r1,#3
        0x00811496:    f64f5082    O..P    MOV      r0,#0xfd82
        0x0081149a:    f410f027    ..'.    BL       btif_vendor_cmd_req ; 0x214ec
        0x0081149e:    b108        ..      CBZ      r0,0x8114a4 ; le_vendor_measure_master_clk_freq_mode + 40
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (739)
        0x008114a0:    2000        .       MOVS     r0,#0
        0x008114a2:    bd08        ..      POP      {r3,pc}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (741)
        0x008114a4:    2007        .       MOVS     r0,#7
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (742)
        0x008114a6:    bd08        ..      POP      {r3,pc}
    le_vendor_record_ce_info
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (745)
        0x008114a8:    b508        ..      PUSH     {r3,lr}
        0x008114aa:    2105        .!      MOVS     r1,#5
        0x008114ac:    f88d1000    ....    STRB     r1,[sp,#0]
        0x008114b0:    211f        .!      MOVS     r1,#0x1f
        0x008114b2:    f88d1001    ....    STRB     r1,[sp,#1]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (745)
        0x008114b6:    b100        ..      CBZ      r0,0x8114ba ; le_vendor_record_ce_info + 18
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (752)
        0x008114b8:    2001        .       MOVS     r0,#1
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (756)
        0x008114ba:    f88d0002    ....    STRB     r0,[sp,#2]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (759)
        0x008114be:    466a        jF      MOV      r2,sp
        0x008114c0:    2103        .!      MOVS     r1,#3
        0x008114c2:    f64f5082    O..P    MOV      r0,#0xfd82
        0x008114c6:    f410f011    ....    BL       btif_vendor_cmd_req ; 0x214ec
        0x008114ca:    b108        ..      CBZ      r0,0x8114d0 ; le_vendor_record_ce_info + 40
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (761)
        0x008114cc:    2000        .       MOVS     r0,#0
        0x008114ce:    bd08        ..      POP      {r3,pc}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (763)
        0x008114d0:    2007        .       MOVS     r0,#7
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (764)
        0x008114d2:    bd08        ..      POP      {r3,pc}
    le_vendor_get_ce_info_addr
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (767)
        0x008114d4:    b508        ..      PUSH     {r3,lr}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (769)
        0x008114d6:    2014        .       MOVS     r0,#0x14
        0x008114d8:    f88d0000    ....    STRB     r0,[sp,#0]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (771)
        0x008114dc:    466a        jF      MOV      r2,sp
        0x008114de:    2101        .!      MOVS     r1,#1
        0x008114e0:    f64f5080    O..P    MOV      r0,#0xfd80
        0x008114e4:    f410f002    ....    BL       btif_vendor_cmd_req ; 0x214ec
        0x008114e8:    b108        ..      CBZ      r0,0x8114ee ; le_vendor_get_ce_info_addr + 26
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (773)
        0x008114ea:    2000        .       MOVS     r0,#0
        0x008114ec:    bd08        ..      POP      {r3,pc}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (775)
        0x008114ee:    2007        .       MOVS     r0,#7
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (776)
        0x008114f0:    bd08        ..      POP      {r3,pc}
    le_vendor_shift_frequency_band
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (779)
        0x008114f2:    b51c        ..      PUSH     {r2-r4,lr}
        0x008114f4:    000a        ..      MOVS     r2,r1
        0x008114f6:    f04f0108    O...    MOV      r1,#8
        0x008114fa:    f88d1000    ....    STRB     r1,[sp,#0]
        0x008114fe:    f88d0001    ....    STRB     r0,[sp,#1]
        0x00811502:    d011        ..      BEQ      0x811528 ; le_vendor_shift_frequency_band + 54
        0x00811504:    6810        .h      LDR      r0,[r2,#0]
        0x00811506:    f8cd0002    ....    STR      r0,[sp,#2]
        0x0081150a:    7910        .y      LDRB     r0,[r2,#4]
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (786)
        0x0081150c:    2107        .!      MOVS     r1,#7
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (787)
        0x0081150e:    f88d0006    ....    STRB     r0,[sp,#6]
        0x00811512:    e00a        ..      B        0x81152a ; le_vendor_shift_frequency_band + 56
    $d
        0x00811514:    00207f14    .. .    DCD    2129684
        0x00811518:    00201b1c    .. .    DCD    2104092
        0x0081151c:    00202e48    H. .    DCD    2109000
        0x00811520:    00202df4    .- .    DCD    2108916
        0x00811524:    00202e64    d. .    DCD    2109028
    $t
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (791)
        0x00811528:    2102        .!      MOVS     r1,#2
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (793)
        0x0081152a:    466a        jF      MOV      r2,sp
        0x0081152c:    f64f5087    O..P    MOV      r0,#0xfd87
        0x00811530:    f40ff7dc    ....    BL       btif_vendor_cmd_req ; 0x214ec
        0x00811534:    b108        ..      CBZ      r0,0x81153a ; le_vendor_shift_frequency_band + 72
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (795)
        0x00811536:    2000        .       MOVS     r0,#0
        0x00811538:    bd1c        ..      POP      {r2-r4,pc}
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (797)
        0x0081153a:    2007        .       MOVS     r0,#7
;;; ..\..\..\src\app\gap_lib\extension\gap_vendor_cmd.c (798)
        0x0081153c:    bd1c        ..      POP      {r2-r4,pc}
        0x0081153e:    0000        ..      MOVS     r0,r0
    .text
    srand
        0x00811540:    490b        .I      LDR      r1,[pc,#44] ; [0x811570] = 0x207f94
        0x00811542:    b510        ..      PUSH     {r4,lr}
        0x00811544:    f1a1027c    ..|.    SUB      r2,r1,#0x7c
        0x00811548:    4c0a        .L      LDR      r4,[pc,#40] ; [0x811574] = 0x66d619e1
        0x0081154a:    e9c21237    ..7.    STRD     r1,r2,[r2,#0xdc]
        0x0081154e:    2137        7!      MOVS     r1,#0x37
        0x00811550:    e006        ..      B        0x811560 ; srand + 32
        0x00811552:    eb004310    ...C    ADD      r3,r0,r0,LSR #16
        0x00811556:    f8423021    B.!0    STR      r3,[r2,r1,LSL #2]
        0x0081155a:    4b07        .K      LDR      r3,[pc,#28] ; [0x811578] = 0x10dcd
        0x0081155c:    fb004003    ...@    MLA      r0,r0,r3,r4
        0x00811560:    1e0b        ..      SUBS     r3,r1,#0
        0x00811562:    f1a10101    ....    SUB      r1,r1,#1
        0x00811566:    dcf4        ..      BGT      0x811552 ; srand + 18
        0x00811568:    bd10        ..      POP      {r4,pc}
    _rand_init
        0x0081156a:    2001        .       MOVS     r0,#1
        0x0081156c:    e7e8        ..      B        srand ; 0x811540
    $d
        0x0081156e:    0000        ..      DCW    0
        0x00811570:    00207f94    .. .    DCD    2129812
        0x00811574:    66d619e1    ...f    DCD    1725307361
        0x00811578:    00010dcd    ....    DCD    69069
    $t
    x$fpl$fpinit
    $v0
    _fp_init
        0x0081157c:    f04f7040    O.@p    MOV      r0,#0x3000000
        0x00811580:    eee10a10    ....    VMSR     FPSCR,r0
    __fplib_config_fpu_vfp
    __fplib_config_pureend_doubles
        0x00811584:    4770        pG      BX       lr
        0x00811586:    0000        ..      MOVS     r0,r0
    $d.realdata
    .constdata
    app_cb_table
        0x00811588:    0e85d101    ....    DCD    243650817
        0x0081158c:    00000007    ....    DCD    7
        0x00811590:    0080e9bd    ....    DCD    8448445
        0x00811594:    00000000    ....    DCD    0
        0x00811598:    00000000    ....    DCD    0
        0x0081159c:    00000000    ....    DCD    0
        0x008115a0:    00000000    ....    DCD    0
        0x008115a4:    0080e9e7    ....    DCD    8448487
        0x008115a8:    0080ea05    ....    DCD    8448517
        0x008115ac:    00811d4c    L...    DCD    8461644
        0x008115b0:    00811df8    ....    DCD    8461816
        0x008115b4:    00811d40    @...    DCD    8461632
        0x008115b8:    00811e00    ....    DCD    8461824
        0x008115bc:    00811da4    ....    DCD    8461732
        0x008115c0:    00811e18    ....    DCD    8461848
        0x008115c4:    00811e0c    ....    DCD    8461836
        0x008115c8:    00811d94    ....    DCD    8461716
        0x008115cc:    00811d94    ....    DCD    8461716
        0x008115d0:    00811d94    ....    DCD    8461716
        0x008115d4:    00811d94    ....    DCD    8461716
        0x008115d8:    00811d34    4...    DCD    8461620
        0x008115dc:    00811dec    ....    DCD    8461804
        0x008115e0:    00811d94    ....    DCD    8461716
        0x008115e4:    00811d5c    \...    DCD    8461660
        0x008115e8:    00811dbc    ....    DCD    8461756
        0x008115ec:    00811dd0    ....    DCD    8461776
        0x008115f0:    00811d3c    <...    DCD    8461628
        0x008115f4:    00811d24    $...    DCD    8461604
        0x008115f8:    00811ca4    ....    DCD    8461476
        0x008115fc:    00811c78    x...    DCD    8461432
        0x00811600:    00811dd8    ....    DCD    8461784
        0x00811604:    00811d8c    ....    DCD    8461708
        0x00811608:    00811d78    x...    DCD    8461688
        0x0081160c:    00811d10    ....    DCD    8461584
        0x00811610:    00811cd0    ....    DCD    8461520
        0x00811614:    00811cf0    ....    DCD    8461552
        0x00811618:    00811c54    T...    DCD    8461396
        0x0081161c:    00811c20     ...    DCD    8461344
        0x00811620:    00811d30    0...    DCD    8461616
        0x00811624:    00811c18    ....    DCD    8461336
        0x00811628:    00811c4c    L...    DCD    8461388
        0x0081162c:    00811c10    ....    DCD    8461328
        0x00811630:    00811c44    D...    DCD    8461380
        0x00811634:    00811d2c    ,...    DCD    8461612
        0x00811638:    00811dc4    ....    DCD    8461764
        0x0081163c:    00811c28    (...    DCD    8461352
        0x00811640:    00811c5c    \...    DCD    8461404
        0x00811644:    00811c88    ....    DCD    8461448
        0x00811648:    00811cac    ....    DCD    8461484
        0x0081164c:    00811cd8    ....    DCD    8461528
        0x00811650:    00811cf8    ....    DCD    8461560
        0x00811654:    00811cbc    ....    DCD    8461500
        0x00811658:    00811c98    ....    DCD    8461464
        0x0081165c:    00811d58    X...    DCD    8461656
        0x00811660:    00811c6c    l...    DCD    8461420
        0x00811664:    00811c38    8...    DCD    8461368
        0x00811668:    00811c80    ....    DCD    8461440
        0x0081166c:    00811cc8    ....    DCD    8461512
        0x00811670:    00811ce8    ....    DCD    8461544
        0x00811674:    00811d08    ....    DCD    8461576
        0x00811678:    00811d1c    ....    DCD    8461596
        0x0081167c:    00811db0    ....    DCD    8461744
        0x00811680:    00811d9c    ....    DCD    8461724
        0x00811684:    00811de4    ....    DCD    8461796
        0x00811688:    00811d64    d...    DCD    8461668
        0x0081168c:    00811d44    D...    DCD    8461636
        0x00811690:    00811e24    $...    DCD    8461860
        0x00811694:    00811d80    ....    DCD    8461696
        0x00811698:    00811d6c    l...    DCD    8461676
        0x0081169c:    00811d38    8...    DCD    8461624
    __func__
        0x008116a0:    6c6c616d    mall    DCD    1819042157
        0x008116a4:    636f        oc      DCW    25455
        0x008116a6:    00          .       DCB    0
    __func__
        0x008116a7:    63          c       DCB    99
        0x008116a8:    6f6c6c61    allo    DCD    1869376609
        0x008116ac:    0063        c.      DCW    99
    __func__
        0x008116ae:    6572        re      DCW    25970
        0x008116b0:    6f6c6c61    allo    DCD    1869376609
        0x008116b4:    0063        c.      DCW    99
    .constdata
    __func__
        0x008116b6:    7061        ap      DCW    28769
        0x008116b8:    616d5f70    p_ma    DCD    1634557808
        0x008116bc:    745f6e69    in_t    DCD    1952411241
        0x008116c0:    006b7361    ask.    DCD    7041889
    .constdata
        0x008116c4:    5f454c42    BLE_    DCD    1598377026
        0x008116c8:    0041544f    OTA.    DCD    4281423
        0x008116cc:    00000000    ....    DCD    0
        0x008116d0:    00000000    ....    DCD    0
        0x008116d4:    00000000    ....    DCD    0
        0x008116d8:    00000000    ....    DCD    0
        0x008116dc:    00000000    ....    DCD    0
        0x008116e0:    00000000    ....    DCD    0
        0x008116e4:    00000000    ....    DCD    0
        0x008116e8:    00000000    ....    DCD    0
    .constdata
    bas_attr_tbl
        0x008116ec:    28000802    ...(    DCD    671090690
        0x008116f0:    0000180f    ....    DCD    6159
        0x008116f4:    00000000    ....    DCD    0
        0x008116f8:    00000000    ....    DCD    0
        0x008116fc:    00020000    ....    DCD    131072
        0x00811700:    00000000    ....    DCD    0
        0x00811704:    00000001    ....    DCD    1
        0x00811708:    28030002    ...(    DCD    671285250
        0x0081170c:    00000012    ....    DCD    18
        0x00811710:    00000000    ....    DCD    0
        0x00811714:    00000000    ....    DCD    0
        0x00811718:    00010000    ....    DCD    65536
        0x0081171c:    00000000    ....    DCD    0
        0x00811720:    00000001    ....    DCD    1
        0x00811724:    2a190004    ...*    DCD    706281476
        0x00811728:    00000000    ....    DCD    0
        0x0081172c:    00000000    ....    DCD    0
        0x00811730:    00000000    ....    DCD    0
        0x00811734:    00000000    ....    DCD    0
        0x00811738:    00000000    ....    DCD    0
        0x0081173c:    00000001    ....    DCD    1
        0x00811740:    29020012    ...)    DCD    687996946
        0x00811744:    00000000    ....    DCD    0
        0x00811748:    00000000    ....    DCD    0
        0x0081174c:    00000000    ....    DCD    0
        0x00811750:    00020000    ....    DCD    131072
        0x00811754:    00000000    ....    DCD    0
        0x00811758:    00000011    ....    DCD    17
    bas_cbs
        0x0081175c:    0080f9fb    ....    DCD    8452603
        0x00811760:    00000000    ....    DCD    0
        0x00811764:    0080fa8b    ....    DCD    8452747
    .constdata
    dis_attr_tbl
        0x00811768:    28000802    ...(    DCD    671090690
        0x0081176c:    0000180a    ....    DCD    6154
        0x00811770:    00000000    ....    DCD    0
        0x00811774:    00000000    ....    DCD    0
        0x00811778:    00020000    ....    DCD    131072
        0x0081177c:    00000000    ....    DCD    0
        0x00811780:    00000001    ....    DCD    1
        0x00811784:    28030002    ...(    DCD    671285250
        0x00811788:    00000002    ....    DCD    2
        0x0081178c:    00000000    ....    DCD    0
        0x00811790:    00000000    ....    DCD    0
        0x00811794:    00010000    ....    DCD    65536
        0x00811798:    00000000    ....    DCD    0
        0x0081179c:    00000001    ....    DCD    1
        0x008117a0:    2a290004    ..)*    DCD    707330052
        0x008117a4:    00000000    ....    DCD    0
        0x008117a8:    00000000    ....    DCD    0
        0x008117ac:    00000000    ....    DCD    0
        0x008117b0:    00000000    ....    DCD    0
        0x008117b4:    00000000    ....    DCD    0
        0x008117b8:    00000001    ....    DCD    1
        0x008117bc:    28030002    ...(    DCD    671285250
        0x008117c0:    00000002    ....    DCD    2
        0x008117c4:    00000000    ....    DCD    0
        0x008117c8:    00000000    ....    DCD    0
        0x008117cc:    00010000    ....    DCD    65536
        0x008117d0:    00000000    ....    DCD    0
        0x008117d4:    00000001    ....    DCD    1
        0x008117d8:    2a240004    ..$*    DCD    707002372
        0x008117dc:    00000000    ....    DCD    0
        0x008117e0:    00000000    ....    DCD    0
        0x008117e4:    00000000    ....    DCD    0
        0x008117e8:    00000000    ....    DCD    0
        0x008117ec:    00000000    ....    DCD    0
        0x008117f0:    00000001    ....    DCD    1
        0x008117f4:    28030002    ...(    DCD    671285250
        0x008117f8:    00000002    ....    DCD    2
        0x008117fc:    00000000    ....    DCD    0
        0x00811800:    00000000    ....    DCD    0
        0x00811804:    00010000    ....    DCD    65536
        0x00811808:    00000000    ....    DCD    0
        0x0081180c:    00000001    ....    DCD    1
        0x00811810:    2a250004    ..%*    DCD    707067908
        0x00811814:    00000000    ....    DCD    0
        0x00811818:    00000000    ....    DCD    0
        0x0081181c:    00000000    ....    DCD    0
        0x00811820:    00000000    ....    DCD    0
        0x00811824:    00000000    ....    DCD    0
        0x00811828:    00000001    ....    DCD    1
        0x0081182c:    28030002    ...(    DCD    671285250
        0x00811830:    00000002    ....    DCD    2
        0x00811834:    00000000    ....    DCD    0
        0x00811838:    00000000    ....    DCD    0
        0x0081183c:    00010000    ....    DCD    65536
        0x00811840:    00000000    ....    DCD    0
        0x00811844:    00000001    ....    DCD    1
        0x00811848:    2a270004    ..'*    DCD    707198980
        0x0081184c:    00000000    ....    DCD    0
        0x00811850:    00000000    ....    DCD    0
        0x00811854:    00000000    ....    DCD    0
        0x00811858:    00000000    ....    DCD    0
        0x0081185c:    00000000    ....    DCD    0
        0x00811860:    00000001    ....    DCD    1
        0x00811864:    28030002    ...(    DCD    671285250
        0x00811868:    00000002    ....    DCD    2
        0x0081186c:    00000000    ....    DCD    0
        0x00811870:    00000000    ....    DCD    0
        0x00811874:    00010000    ....    DCD    65536
        0x00811878:    00000000    ....    DCD    0
        0x0081187c:    00000001    ....    DCD    1
        0x00811880:    2a260004    ..&*    DCD    707133444
        0x00811884:    00000000    ....    DCD    0
        0x00811888:    00000000    ....    DCD    0
        0x0081188c:    00000000    ....    DCD    0
        0x00811890:    00000000    ....    DCD    0
        0x00811894:    00000000    ....    DCD    0
        0x00811898:    00000001    ....    DCD    1
        0x0081189c:    28030002    ...(    DCD    671285250
        0x008118a0:    00000002    ....    DCD    2
        0x008118a4:    00000000    ....    DCD    0
        0x008118a8:    00000000    ....    DCD    0
        0x008118ac:    00010000    ....    DCD    65536
        0x008118b0:    00000000    ....    DCD    0
        0x008118b4:    00000001    ....    DCD    1
        0x008118b8:    2a280004    ..(*    DCD    707264516
        0x008118bc:    00000000    ....    DCD    0
        0x008118c0:    00000000    ....    DCD    0
        0x008118c4:    00000000    ....    DCD    0
        0x008118c8:    00000000    ....    DCD    0
        0x008118cc:    00000000    ....    DCD    0
        0x008118d0:    00000001    ....    DCD    1
        0x008118d4:    28030002    ...(    DCD    671285250
        0x008118d8:    00000002    ....    DCD    2
        0x008118dc:    00000000    ....    DCD    0
        0x008118e0:    00000000    ....    DCD    0
        0x008118e4:    00010000    ....    DCD    65536
        0x008118e8:    00000000    ....    DCD    0
        0x008118ec:    00000001    ....    DCD    1
        0x008118f0:    2a230004    ..#*    DCD    706936836
        0x008118f4:    00000000    ....    DCD    0
        0x008118f8:    00000000    ....    DCD    0
        0x008118fc:    00000000    ....    DCD    0
        0x00811900:    00000000    ....    DCD    0
        0x00811904:    00000000    ....    DCD    0
        0x00811908:    00000001    ....    DCD    1
        0x0081190c:    28030002    ...(    DCD    671285250
        0x00811910:    00000002    ....    DCD    2
        0x00811914:    00000000    ....    DCD    0
        0x00811918:    00000000    ....    DCD    0
        0x0081191c:    00010000    ....    DCD    65536
        0x00811920:    00000000    ....    DCD    0
        0x00811924:    00000001    ....    DCD    1
        0x00811928:    2a2a0004    ..**    DCD    707395588
        0x0081192c:    00000000    ....    DCD    0
        0x00811930:    00000000    ....    DCD    0
        0x00811934:    00000000    ....    DCD    0
        0x00811938:    00000000    ....    DCD    0
        0x0081193c:    00000000    ....    DCD    0
        0x00811940:    00000001    ....    DCD    1
        0x00811944:    28030002    ...(    DCD    671285250
        0x00811948:    00000002    ....    DCD    2
        0x0081194c:    00000000    ....    DCD    0
        0x00811950:    00000000    ....    DCD    0
        0x00811954:    00010000    ....    DCD    65536
        0x00811958:    00000000    ....    DCD    0
        0x0081195c:    00000001    ....    DCD    1
        0x00811960:    2a500004    ..P*    DCD    709885956
        0x00811964:    00000000    ....    DCD    0
        0x00811968:    00000000    ....    DCD    0
        0x0081196c:    00000000    ....    DCD    0
        0x00811970:    00000000    ....    DCD    0
        0x00811974:    00000000    ....    DCD    0
        0x00811978:    00000001    ....    DCD    1
    dis_attr_tbl_size
        0x0081197c:    00000214    ....    DCD    532
    dis_cbs
        0x00811980:    0080fc61    a...    DCD    8453217
        0x00811984:    00000000    ....    DCD    0
        0x00811988:    00000000    ....    DCD    0
    .constdata
    GATT_UUID_OTA_SERVICE
        0x0081198c:    2e4da212    ..M.    DCD    776839698
        0x00811990:    8e4814fe    ..H.    DCD    2387088638
        0x00811994:    3c17d293    ...<    DCD    1008194195
        0x00811998:    0000d0ff    ....    DCD    53503
    gattOtaServiceTable
        0x0081199c:    28000800    ...(    DCD    671090688
        0x008119a0:    00000000    ....    DCD    0
        0x008119a4:    00000000    ....    DCD    0
        0x008119a8:    00000000    ....    DCD    0
        0x008119ac:    00100000    ....    DCD    1048576
        0x008119b0:    0081198c    ....    DCD    8460684
        0x008119b4:    00000001    ....    DCD    1
        0x008119b8:    28030002    ...(    DCD    671285250
        0x008119bc:    00000004    ....    DCD    4
        0x008119c0:    00000000    ....    DCD    0
        0x008119c4:    00000000    ....    DCD    0
        0x008119c8:    00010000    ....    DCD    65536
        0x008119cc:    00000000    ....    DCD    0
        0x008119d0:    00000001    ....    DCD    1
        0x008119d4:    ffd10004    ....    DCD    4291887108
        0x008119d8:    00000000    ....    DCD    0
        0x008119dc:    00000000    ....    DCD    0
        0x008119e0:    00000000    ....    DCD    0
        0x008119e4:    00020000    ....    DCD    131072
        0x008119e8:    00000000    ....    DCD    0
        0x008119ec:    00000011    ....    DCD    17
        0x008119f0:    28030002    ...(    DCD    671285250
        0x008119f4:    00000002    ....    DCD    2
        0x008119f8:    00000000    ....    DCD    0
        0x008119fc:    00000000    ....    DCD    0
        0x00811a00:    00010000    ....    DCD    65536
        0x00811a04:    00000000    ....    DCD    0
        0x00811a08:    00000001    ....    DCD    1
        0x00811a0c:    ffd20004    ....    DCD    4291952644
        0x00811a10:    00000000    ....    DCD    0
        0x00811a14:    00000000    ....    DCD    0
        0x00811a18:    00000000    ....    DCD    0
        0x00811a1c:    00010000    ....    DCD    65536
        0x00811a20:    00000000    ....    DCD    0
        0x00811a24:    00000001    ....    DCD    1
        0x00811a28:    28030002    ...(    DCD    671285250
        0x00811a2c:    00000002    ....    DCD    2
        0x00811a30:    00000000    ....    DCD    0
        0x00811a34:    00000000    ....    DCD    0
        0x00811a38:    00010000    ....    DCD    65536
        0x00811a3c:    00000000    ....    DCD    0
        0x00811a40:    00000001    ....    DCD    1
        0x00811a44:    ffd30004    ....    DCD    4292018180
        0x00811a48:    00000000    ....    DCD    0
        0x00811a4c:    00000000    ....    DCD    0
        0x00811a50:    00000000    ....    DCD    0
        0x00811a54:    00010000    ....    DCD    65536
        0x00811a58:    00000000    ....    DCD    0
        0x00811a5c:    00000001    ....    DCD    1
        0x00811a60:    28030002    ...(    DCD    671285250
        0x00811a64:    00000002    ....    DCD    2
        0x00811a68:    00000000    ....    DCD    0
        0x00811a6c:    00000000    ....    DCD    0
        0x00811a70:    00010000    ....    DCD    65536
        0x00811a74:    00000000    ....    DCD    0
        0x00811a78:    00000001    ....    DCD    1
        0x00811a7c:    ffd40004    ....    DCD    4292083716
        0x00811a80:    00000000    ....    DCD    0
        0x00811a84:    00000000    ....    DCD    0
        0x00811a88:    00000000    ....    DCD    0
        0x00811a8c:    00010000    ....    DCD    65536
        0x00811a90:    00000000    ....    DCD    0
        0x00811a94:    00000001    ....    DCD    1
        0x00811a98:    28030002    ...(    DCD    671285250
        0x00811a9c:    00000002    ....    DCD    2
        0x00811aa0:    00000000    ....    DCD    0
        0x00811aa4:    00000000    ....    DCD    0
        0x00811aa8:    00010000    ....    DCD    65536
        0x00811aac:    00000000    ....    DCD    0
        0x00811ab0:    00000001    ....    DCD    1
        0x00811ab4:    ffd50004    ....    DCD    4292149252
        0x00811ab8:    00000000    ....    DCD    0
        0x00811abc:    00000000    ....    DCD    0
        0x00811ac0:    00000000    ....    DCD    0
        0x00811ac4:    00010000    ....    DCD    65536
        0x00811ac8:    00000000    ....    DCD    0
        0x00811acc:    00000001    ....    DCD    1
        0x00811ad0:    28030002    ...(    DCD    671285250
        0x00811ad4:    00000004    ....    DCD    4
        0x00811ad8:    00000000    ....    DCD    0
        0x00811adc:    00000000    ....    DCD    0
        0x00811ae0:    00010000    ....    DCD    65536
        0x00811ae4:    00000000    ....    DCD    0
        0x00811ae8:    00000001    ....    DCD    1
        0x00811aec:    ffd80004    ....    DCD    4292345860
        0x00811af0:    00000000    ....    DCD    0
        0x00811af4:    00000000    ....    DCD    0
        0x00811af8:    00000000    ....    DCD    0
        0x00811afc:    00000000    ....    DCD    0
        0x00811b00:    00000000    ....    DCD    0
        0x00811b04:    00000010    ....    DCD    16
        0x00811b08:    28030002    ...(    DCD    671285250
        0x00811b0c:    00000002    ....    DCD    2
        0x00811b10:    00000000    ....    DCD    0
        0x00811b14:    00000000    ....    DCD    0
        0x00811b18:    00010000    ....    DCD    65536
        0x00811b1c:    00000000    ....    DCD    0
        0x00811b20:    00000001    ....    DCD    1
        0x00811b24:    fff10004    ....    DCD    4293984260
        0x00811b28:    00000000    ....    DCD    0
        0x00811b2c:    00000000    ....    DCD    0
        0x00811b30:    00000000    ....    DCD    0
        0x00811b34:    00010000    ....    DCD    65536
        0x00811b38:    00000000    ....    DCD    0
        0x00811b3c:    00000001    ....    DCD    1
        0x00811b40:    28030002    ...(    DCD    671285250
        0x00811b44:    00000008    ....    DCD    8
        0x00811b48:    00000000    ....    DCD    0
        0x00811b4c:    00000000    ....    DCD    0
        0x00811b50:    00010000    ....    DCD    65536
        0x00811b54:    00000000    ....    DCD    0
        0x00811b58:    00000001    ....    DCD    1
        0x00811b5c:    fff20004    ....    DCD    4294049796
        0x00811b60:    00000000    ....    DCD    0
        0x00811b64:    00000000    ....    DCD    0
        0x00811b68:    00000000    ....    DCD    0
        0x00811b6c:    00050000    ....    DCD    327680
        0x00811b70:    00000000    ....    DCD    0
        0x00811b74:    00000010    ....    DCD    16
        0x00811b78:    28030002    ...(    DCD    671285250
        0x00811b7c:    00000002    ....    DCD    2
        0x00811b80:    00000000    ....    DCD    0
        0x00811b84:    00000000    ....    DCD    0
        0x00811b88:    00010000    ....    DCD    65536
        0x00811b8c:    00000000    ....    DCD    0
        0x00811b90:    00000001    ....    DCD    1
        0x00811b94:    ffe00004    ....    DCD    4292870148
        0x00811b98:    00000000    ....    DCD    0
        0x00811b9c:    00000000    ....    DCD    0
        0x00811ba0:    00000000    ....    DCD    0
        0x00811ba4:    00010000    ....    DCD    65536
        0x00811ba8:    00000000    ....    DCD    0
        0x00811bac:    00000001    ....    DCD    1
    OTAServiceCBs
        0x00811bb0:    0080ff67    g...    DCD    8453991
        0x00811bb4:    0080fe79    y...    DCD    8453753
        0x00811bb8:    00000000    ....    DCD    0
    .constdata
    __func__
        0x00811bbc:    725f656c    le_r    DCD    1918854508
        0x00811bc0:    5f646165    ead_    DCD    1600414053
        0x00811bc4:    6f6d6572    remo    DCD    1869440370
        0x00811bc8:    765f6574    te_v    DCD    1985963380
        0x00811bcc:    69737265    ersi    DCD    1769173605
        0x00811bd0:    6e6f        on      DCW    28271
        0x00811bd2:    00          .       DCB    0
    __func__
        0x00811bd3:    6c          l       DCB    108
        0x00811bd4:    72775f65    e_wr    DCD    1920425829
        0x00811bd8:    5f657469    ite_    DCD    1600484457
        0x00811bdc:    68747561    auth    DCD    1752462689
        0x00811be0:    705f6e65    en_p    DCD    1885302373
        0x00811be4:    6f6c7961    aylo    DCD    1869379937
        0x00811be8:    745f6461    ad_t    DCD    1952408673
        0x00811bec:    6f656d69    imeo    DCD    1868918121
        0x00811bf0:    7475        ut      DCW    29813
        0x00811bf2:    00          .       DCB    0
    __func__
        0x00811bf3:    63          c       DCB    99
        0x00811bf4:    6e65696c    lien    DCD    1852139884
        0x00811bf8:    65735f74    t_se    DCD    1702059892
        0x00811bfc:    655f646e    nd_e    DCD    1700750446
        0x00811c00:    61686378    xcha    DCD    1634231160
        0x00811c04:    5f65676e    nge_    DCD    1600481134
        0x00811c08:    5f75746d    mtu_    DCD    1601533037
        0x00811c0c:    00716572    req.    DCD    7431538
    .conststring
        0x00811c10:    30433249    I2C0    DCD    809710153
        0x00811c14:    00000000    ....    DCD    0
        0x00811c18:    30495053    SPI0    DCD    810111059
        0x00811c1c:    00000000    ....    DCD    0
        0x00811c20:    54524155    UART    DCD    1414676821
        0x00811c24:    00000030    0...    DCD    48
        0x00811c28:    414d4447    GDMA    DCD    1095582791
        0x00811c2c:    68432030    0 Ch    DCD    1749229616
        0x00811c30:    656e6e61    anne    DCD    1701736033
        0x00811c34:    0000306c    l0..    DCD    12396
        0x00811c38:    4f495047    GPIO    DCD    1330204743
        0x00811c3c:    6f72475f    _Gro    DCD    1869760351
        0x00811c40:    00307075    up0.    DCD    3174517
        0x00811c44:    31433249    I2C1    DCD    826487369
        0x00811c48:    00000000    ....    DCD    0
        0x00811c4c:    31495053    SPI1    DCD    826888275
        0x00811c50:    00000000    ....    DCD    0
        0x00811c54:    54524155    UART    DCD    1414676821
        0x00811c58:    00000031    1...    DCD    49
        0x00811c5c:    414d4447    GDMA    DCD    1095582791
        0x00811c60:    68432030    0 Ch    DCD    1749229616
        0x00811c64:    656e6e61    anne    DCD    1701736033
        0x00811c68:    0000316c    l1..    DCD    12652
        0x00811c6c:    4f495047    GPIO    DCD    1330204743
        0x00811c70:    6f72475f    _Gro    DCD    1869760351
        0x00811c74:    00317075    up1.    DCD    3240053
        0x00811c78:    324d4954    TIM2    DCD    843925844
        0x00811c7c:    00000000    ....    DCD    0
        0x00811c80:    54524155    UART    DCD    1414676821
        0x00811c84:    00000032    2...    DCD    50
        0x00811c88:    414d4447    GDMA    DCD    1095582791
        0x00811c8c:    68432030    0 Ch    DCD    1749229616
        0x00811c90:    656e6e61    anne    DCD    1701736033
        0x00811c94:    0000326c    l2..    DCD    12908
        0x00811c98:    4f495047    GPIO    DCD    1330204743
        0x00811c9c:    6f72475f    _Gro    DCD    1869760351
        0x00811ca0:    00327075    up2.    DCD    3305589
        0x00811ca4:    334d4954    TIM3    DCD    860703060
        0x00811ca8:    00000000    ....    DCD    0
        0x00811cac:    414d4447    GDMA    DCD    1095582791
        0x00811cb0:    68432030    0 Ch    DCD    1749229616
        0x00811cb4:    656e6e61    anne    DCD    1701736033
        0x00811cb8:    0000336c    l3..    DCD    13164
        0x00811cbc:    4f495047    GPIO    DCD    1330204743
        0x00811cc0:    6f72475f    _Gro    DCD    1869760351
        0x00811cc4:    00337075    up3.    DCD    3371125
        0x00811cc8:    344d4954    TIM4    DCD    877480276
        0x00811ccc:    00000000    ....    DCD    0
        0x00811cd0:    4f495047    GPIO    DCD    1330204743
        0x00811cd4:    00000034    4...    DCD    52
        0x00811cd8:    414d4447    GDMA    DCD    1095582791
        0x00811cdc:    68432030    0 Ch    DCD    1749229616
        0x00811ce0:    656e6e61    anne    DCD    1701736033
        0x00811ce4:    0000346c    l4..    DCD    13420
        0x00811ce8:    354d4954    TIM5    DCD    894257492
        0x00811cec:    00000000    ....    DCD    0
        0x00811cf0:    4f495047    GPIO    DCD    1330204743
        0x00811cf4:    00000035    5...    DCD    53
        0x00811cf8:    414d4447    GDMA    DCD    1095582791
        0x00811cfc:    68432030    0 Ch    DCD    1749229616
        0x00811d00:    656e6e61    anne    DCD    1701736033
        0x00811d04:    0000356c    l5..    DCD    13676
        0x00811d08:    364d4954    TIM6    DCD    911034708
        0x00811d0c:    00000000    ....    DCD    0
        0x00811d10:    656d6954    Time    DCD    1701669204
        0x00811d14:    372d3472    r4-7    DCD    925709426
        0x00811d18:    00000000    ....    DCD    0
        0x00811d1c:    374d4954    TIM7    DCD    927811924
        0x00811d20:    00000000    ....    DCD    0
        0x00811d24:    414d5442    BTMA    DCD    1095586882
        0x00811d28:    00000043    C...    DCD    67
        0x00811d2c:    00434441    ADC.    DCD    4408385
        0x00811d30:    00435452    RTC.    DCD    4412498
        0x00811d34:    00435653    SVC.    DCD    4413011
        0x00811d38:    0044434c    LCD.    DCD    4473676
        0x00811d3c:    00474457    WDG.    DCD    4670551
        0x00811d40:    00494d4e    NMI.    DCD    4803918
        0x00811d44:    4f43504c    LPCO    DCD    1329811532
        0x00811d48:    0000504d    MP..    DCD    20557
        0x00811d4c:    74696e49    Init    DCD    1953066569
        0x00811d50:    536c6169    ialS    DCD    1399611753
        0x00811d54:    00000050    P...    DCD    80
        0x00811d58:    00005249    IR..    DCD    21065
        0x00811d5c:    646e6550    Pend    DCD    1684956496
        0x00811d60:    00005653    SV..    DCD    22099
        0x00811d64:    32495053    SPI2    DCD    843665491
        0x00811d68:    00000057    W...    DCD    87
        0x00811d6c:    524f5053    SPOR    DCD    1380929619
        0x00811d70:    52203154    T1 R    DCD    1377841492
        0x00811d74:    00000058    X...    DCD    88
        0x00811d78:    30533249    I2S0    DCD    810758729
        0x00811d7c:    0058525f    _RX.    DCD    5788255
        0x00811d80:    524f5053    SPOR    DCD    1380929619
        0x00811d84:    54203154    T1 T    DCD    1411395924
        0x00811d88:    00000058    X...    DCD    88
        0x00811d8c:    30533249    I2S0    DCD    810758729
        0x00811d90:    0058545f    _TX.    DCD    5788767
        0x00811d94:    64767352    Rsvd    DCD    1685484370
        0x00811d98:    00000000    ....    DCD    0
        0x00811d9c:    63656451    Qdec    DCD    1667589201
        0x00811da0:    0065646f    ode.    DCD    6644847
        0x00811da4:    4d6d654d    MemM    DCD    1299014989
        0x00811da8:    67616e61    anag    DCD    1734438497
        0x00811dac:    00000065    e...    DCD    101
        0x00811db0:    5f495053    SPI_    DCD    1598640211
        0x00811db4:    73616c46    Flas    DCD    1935764550
        0x00811db8:    00000068    h...    DCD    104
        0x00811dbc:    54737953    SysT    DCD    1416853843
        0x00811dc0:    006b6369    ick.    DCD    7037801
        0x00811dc4:    69726550    Peri    DCD    1769104720
        0x00811dc8:    72656870    pher    DCD    1919248496
        0x00811dcc:    00006c61    al..    DCD    27745
        0x00811dd0:    74737953    Syst    DCD    1953724755
        0x00811dd4:    00006d65    em..    DCD    28005
        0x00811dd8:    74616c50    Plat    DCD    1952541776
        0x00811ddc:    6d726f66    form    DCD    1836216166
        0x00811de0:    00000000    ....    DCD    0
        0x00811de4:    7379654b    Keys    DCD    1937335627
        0x00811de8:    006e6163    can.    DCD    7233891
        0x00811dec:    75626544    Debu    DCD    1969382724
        0x00811df0:    6e6f4d67    gMon    DCD    1852788071
        0x00811df4:    00000000    ....    DCD    0
        0x00811df8:    65736552    Rese    DCD    1702061394
        0x00811dfc:    00000074    t...    DCD    116
        0x00811e00:    64726148    Hard    DCD    1685217608
        0x00811e04:    6c756146    Faul    DCD    1819631942
        0x00811e08:    00000074    t...    DCD    116
        0x00811e0c:    67617355    Usag    DCD    1734439765
        0x00811e10:    75614665    eFau    DCD    1969309285
        0x00811e14:    0000746c    lt..    DCD    29804
        0x00811e18:    46737542    BusF    DCD    1181971778
        0x00811e1c:    746c7561    ault    DCD    1953264993
        0x00811e20:    00000000    ....    DCD    0
        0x00811e24:    5f415450    PTA_    DCD    1598116944
        0x00811e28:    6c69614d    Mail    DCD    1818845517
        0x00811e2c:    00786f62    box.    DCD    7892834
    .conststring
        0x00811e30:    6e656353    Scen    DCD    1852138323
        0x00811e34:    00425f65    e_B.    DCD    4349797
        0x00811e38:    6e656353    Scen    DCD    1852138323
        0x00811e3c:    00435f65    e_C.    DCD    4415333
        0x00811e40:    746f6f42    Boot    DCD    1953460034
        0x00811e44:    65636e4f    Once    DCD    1701015119
        0x00811e48:    00000000    ....    DCD    0

** Section #4 'RAM_VECTOR_TABLE' (SHT_PROGBITS) [SHF_ALLOC]
    Size   : 244 bytes (alignment 4)
    Address: 0x00200000

    0x200000:   00 38 20 00 01 e4 80 00 91 e7 80 00 91 e7 80 00    .8 .............
    0x200010:   91 e7 80 00 91 e7 80 00 91 e7 80 00 00 00 00 00    ................
    0x200020:   00 00 00 00 00 00 00 00 00 00 00 00 91 e7 80 00    ................
    0x200030:   91 e7 80 00 00 00 00 00 91 e7 80 00 91 e7 80 00    ................
    0x200040:   91 e7 80 00 91 e7 80 00 91 e7 80 00 91 e7 80 00    ................
    0x200050:   91 e7 80 00 91 e7 80 00 91 e7 80 00 91 e7 80 00    ................
    0x200060:   91 e7 80 00 91 e7 80 00 91 e7 80 00 91 e7 80 00    ................
    0x200070:   91 e7 80 00 91 e7 80 00 91 e7 80 00 91 e7 80 00    ................
    0x200080:   91 e7 80 00 91 e7 80 00 91 e7 80 00 91 e7 80 00    ................
    0x200090:   91 e7 80 00 91 e7 80 00 91 e7 80 00 91 e7 80 00    ................
    0x2000a0:   91 e7 80 00 91 e7 80 00 01 7c 20 00 59 7c 20 00    .........| .Y| .
    0x2000b0:   91 e7 80 00 b1 7c 20 00 ff 7c 20 00 91 e7 80 00    .....| ..| .....
    0x2000c0:   91 e7 80 00 91 e7 80 00 91 e7 80 00 91 e7 80 00    ................
    0x2000d0:   91 e7 80 00 91 e7 80 00 91 e7 80 00 91 e7 80 00    ................
    0x2000e0:   91 e7 80 00 91 e7 80 00 91 e7 80 00 91 e7 80 00    ................
    0x2000f0:   91 e7 80 00                                        ....

    __Vectors_End

** Section #5 'RAM_DATA_ON' (SHT_PROGBITS) [SHF_ALLOC + SHF_EXECINSTR]
    Size   : 336 bytes (alignment 4)
    Address: 0x00207c00

    $t
    .ram.dataon.data
    GPIO_Group3_Handler
;;; .\..\..\..\src\mcu\rtl876x\system_rtl8762c.c
;;;944    void GPIO_Group3_Handler(void)
;;;944    {
        0x00207c00:    b510        ..      PUSH     {r4,lr}
;;;945        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
        0x00207c02:    4852        RH      LDR      r0,[pc,#328] ; [0x207d4c] = 0x40001000
        0x00207c04:    6c04        .l      LDR      r4,[r0,#0x40]
;;;946    
;;;947        //Check exact IRQ function
;;;948        if (GPIOIrqStatus & BIT3)
        0x00207c06:    f0040008    ....    AND      r0,r4,#8
        0x00207c0a:    b108        ..      CBZ      r0,0x207c10 ; GPIO_Group3_Handler + 16
;;;949        {
;;;950            GPIO3_Handler();
        0x00207c0c:    f206f5c0    ....    BL       ADC_Handler ; 0x80e790
;;;951        }
;;;952        if (GPIOIrqStatus & BIT7)
        0x00207c10:    f0040080    ....    AND      r0,r4,#0x80
        0x00207c14:    b108        ..      CBZ      r0,0x207c1a ; GPIO_Group3_Handler + 26
;;;953        {
;;;954            GPIO7_Handler();
        0x00207c16:    f206f5bb    ....    BL       ADC_Handler ; 0x80e790
;;;955        }
;;;956        if (GPIOIrqStatus & BIT11)
        0x00207c1a:    f4046000    ...`    AND      r0,r4,#0x800
        0x00207c1e:    b108        ..      CBZ      r0,0x207c24 ; GPIO_Group3_Handler + 36
;;;957        {
;;;958            GPIO11_Handler();
        0x00207c20:    f206f5b6    ....    BL       ADC_Handler ; 0x80e790
;;;959        }
;;;960        if (GPIOIrqStatus & BIT15)
        0x00207c24:    f4044000    ...@    AND      r0,r4,#0x8000
        0x00207c28:    b108        ..      CBZ      r0,0x207c2e ; GPIO_Group3_Handler + 46
;;;961        {
;;;962            GPIO15_Handler();
        0x00207c2a:    f206f5b1    ....    BL       ADC_Handler ; 0x80e790
;;;963        }
;;;964        if (GPIOIrqStatus & BIT19)
        0x00207c2e:    f4042000    ...     AND      r0,r4,#0x80000
        0x00207c32:    b108        ..      CBZ      r0,0x207c38 ; GPIO_Group3_Handler + 56
;;;965        {
;;;966            GPIO19_Handler();
        0x00207c34:    f206f5ac    ....    BL       ADC_Handler ; 0x80e790
;;;967        }
;;;968        if (GPIOIrqStatus & BIT23)
        0x00207c38:    f4040000    ....    AND      r0,r4,#0x800000
        0x00207c3c:    b108        ..      CBZ      r0,0x207c42 ; GPIO_Group3_Handler + 66
;;;969        {
;;;970            GPIO23_Handler();
        0x00207c3e:    f206f5a7    ....    BL       ADC_Handler ; 0x80e790
;;;971        }
;;;972        if (GPIOIrqStatus & BIT27)
        0x00207c42:    f0046000    ...`    AND      r0,r4,#0x8000000
        0x00207c46:    b108        ..      CBZ      r0,0x207c4c ; GPIO_Group3_Handler + 76
;;;973        {
;;;974            GPIO27_Handler();
        0x00207c48:    f206f5a2    ....    BL       ADC_Handler ; 0x80e790
;;;975        }
;;;976        if (GPIOIrqStatus & BIT31)
        0x00207c4c:    f0044000    ...@    AND      r0,r4,#0x80000000
        0x00207c50:    b108        ..      CBZ      r0,0x207c56 ; GPIO_Group3_Handler + 86
;;;977        {
;;;978            GPIO31_Handler();
        0x00207c52:    f206f59d    ....    BL       ADC_Handler ; 0x80e790
;;;979        }
;;;980    }
        0x00207c56:    bd10        ..      POP      {r4,pc}
    GPIO_Group2_Handler
;;;981    /**
;;;982     * @brief  GPIO Group2 Handler
;;;983     * @param  none
;;;984     * @return none
;;;985      */
;;;986    void GPIO_Group2_Handler(void) DATA_RAM_FUNCTION;
;;;987    void GPIO_Group2_Handler(void)
;;;988    {
        0x00207c58:    b510        ..      PUSH     {r4,lr}
;;;989        uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
        0x00207c5a:    483c        <H      LDR      r0,[pc,#240] ; [0x207d4c] = 0x40001000
        0x00207c5c:    6c04        .l      LDR      r4,[r0,#0x40]
;;;990    
;;;991        //Check exact IRQ function
;;;992        if (GPIOIrqStatus & BIT2)
        0x00207c5e:    f0040004    ....    AND      r0,r4,#4
        0x00207c62:    b108        ..      CBZ      r0,0x207c68 ; GPIO_Group2_Handler + 16
;;;993        {
;;;994            GPIO2_Handler();
        0x00207c64:    f206f594    ....    BL       ADC_Handler ; 0x80e790
;;;995        }
;;;996        if (GPIOIrqStatus & BIT6)
        0x00207c68:    f0040040    ..@.    AND      r0,r4,#0x40
        0x00207c6c:    b108        ..      CBZ      r0,0x207c72 ; GPIO_Group2_Handler + 26
;;;997        {
;;;998            GPIO6_Handler();
        0x00207c6e:    f206f58f    ....    BL       ADC_Handler ; 0x80e790
;;;999        }
;;;1000       if (GPIOIrqStatus & BIT10)
        0x00207c72:    f4046080    ...`    AND      r0,r4,#0x400
        0x00207c76:    b108        ..      CBZ      r0,0x207c7c ; GPIO_Group2_Handler + 36
;;;1001       {
;;;1002           GPIO10_Handler();
        0x00207c78:    f206f58a    ....    BL       ADC_Handler ; 0x80e790
;;;1003       }
;;;1004       if (GPIOIrqStatus & BIT14)
        0x00207c7c:    f4044080    ...@    AND      r0,r4,#0x4000
        0x00207c80:    b108        ..      CBZ      r0,0x207c86 ; GPIO_Group2_Handler + 46
;;;1005       {
;;;1006           GPIO14_Handler();
        0x00207c82:    f206f585    ....    BL       ADC_Handler ; 0x80e790
;;;1007       }
;;;1008       if (GPIOIrqStatus & BIT18)
        0x00207c86:    f4042080    ...     AND      r0,r4,#0x40000
        0x00207c8a:    b108        ..      CBZ      r0,0x207c90 ; GPIO_Group2_Handler + 56
;;;1009       {
;;;1010           GPIO18_Handler();
        0x00207c8c:    f206f580    ....    BL       ADC_Handler ; 0x80e790
;;;1011       }
;;;1012       if (GPIOIrqStatus & BIT22)
        0x00207c90:    f4040080    ....    AND      r0,r4,#0x400000
        0x00207c94:    b108        ..      CBZ      r0,0x207c9a ; GPIO_Group2_Handler + 66
;;;1013       {
;;;1014           GPIO22_Handler();
        0x00207c96:    f206f57b    ..{.    BL       ADC_Handler ; 0x80e790
;;;1015       }
;;;1016       if (GPIOIrqStatus & BIT26)
        0x00207c9a:    f0046080    ...`    AND      r0,r4,#0x4000000
        0x00207c9e:    b108        ..      CBZ      r0,0x207ca4 ; GPIO_Group2_Handler + 76
;;;1017       {
;;;1018           GPIO26_Handler();
        0x00207ca0:    f206f576    ..v.    BL       ADC_Handler ; 0x80e790
;;;1019       }
;;;1020       if (GPIOIrqStatus & BIT30)
        0x00207ca4:    f0044080    ...@    AND      r0,r4,#0x40000000
        0x00207ca8:    b108        ..      CBZ      r0,0x207cae ; GPIO_Group2_Handler + 86
;;;1021       {
;;;1022           GPIO30_Handler();
        0x00207caa:    f206f571    ..q.    BL       ADC_Handler ; 0x80e790
;;;1023       }
;;;1024   }
        0x00207cae:    bd10        ..      POP      {r4,pc}
    GPIO_Group1_Handler
;;;1025   /**
;;;1026    * @brief  GPIO Group1 Handler
;;;1027    * @param  none
;;;1028    * @return none
;;;1029     */
;;;1030   void GPIO_Group1_Handler(void) DATA_RAM_FUNCTION;
;;;1031   void GPIO_Group1_Handler(void)
;;;1032   {
        0x00207cb0:    b510        ..      PUSH     {r4,lr}
;;;1033       uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
        0x00207cb2:    4826        &H      LDR      r0,[pc,#152] ; [0x207d4c] = 0x40001000
        0x00207cb4:    6c04        .l      LDR      r4,[r0,#0x40]
;;;1034   
;;;1035       //Check exact IRQ function
;;;1036       if (GPIOIrqStatus & BIT1)
        0x00207cb6:    f0040002    ....    AND      r0,r4,#2
        0x00207cba:    b108        ..      CBZ      r0,0x207cc0 ; GPIO_Group1_Handler + 16
;;;1037       {
;;;1038           GPIO1_Handler();
        0x00207cbc:    f206f568    ..h.    BL       ADC_Handler ; 0x80e790
;;;1039       }
;;;1040       if (GPIOIrqStatus & BIT9)
        0x00207cc0:    f4047000    ...p    AND      r0,r4,#0x200
        0x00207cc4:    b108        ..      CBZ      r0,0x207cca ; GPIO_Group1_Handler + 26
;;;1041       {
;;;1042           GPIO9_Handler();
        0x00207cc6:    f206f563    ..c.    BL       ADC_Handler ; 0x80e790
;;;1043       }
;;;1044       if (GPIOIrqStatus & BIT13)
        0x00207cca:    f4045000    ...P    AND      r0,r4,#0x2000
        0x00207cce:    b108        ..      CBZ      r0,0x207cd4 ; GPIO_Group1_Handler + 36
;;;1045       {
;;;1046           GPIO13_Handler();
        0x00207cd0:    f206f55e    ..^.    BL       ADC_Handler ; 0x80e790
;;;1047       }
;;;1048       if (GPIOIrqStatus & BIT17)
        0x00207cd4:    f4043000    ...0    AND      r0,r4,#0x20000
        0x00207cd8:    b108        ..      CBZ      r0,0x207cde ; GPIO_Group1_Handler + 46
;;;1049       {
;;;1050           GPIO17_Handler();
        0x00207cda:    f206f559    ..Y.    BL       ADC_Handler ; 0x80e790
;;;1051       }
;;;1052       if (GPIOIrqStatus & BIT21)
        0x00207cde:    f4041000    ....    AND      r0,r4,#0x200000
        0x00207ce2:    b108        ..      CBZ      r0,0x207ce8 ; GPIO_Group1_Handler + 56
;;;1053       {
;;;1054           GPIO21_Handler();
        0x00207ce4:    f206f554    ..T.    BL       ADC_Handler ; 0x80e790
;;;1055       }
;;;1056       if (GPIOIrqStatus & BIT25)
        0x00207ce8:    f0047000    ...p    AND      r0,r4,#0x2000000
        0x00207cec:    b108        ..      CBZ      r0,0x207cf2 ; GPIO_Group1_Handler + 66
;;;1057       {
;;;1058           GPIO25_Handler();
        0x00207cee:    f206f54f    ..O.    BL       ADC_Handler ; 0x80e790
;;;1059       }
;;;1060       if (GPIOIrqStatus & BIT29)
        0x00207cf2:    f0045000    ...P    AND      r0,r4,#0x20000000
        0x00207cf6:    b108        ..      CBZ      r0,0x207cfc ; GPIO_Group1_Handler + 76
;;;1061       {
;;;1062           GPIO29_Handler();
        0x00207cf8:    f206f54a    ..J.    BL       ADC_Handler ; 0x80e790
;;;1063       }
;;;1064   }
        0x00207cfc:    bd10        ..      POP      {r4,pc}
    GPIO_Group0_Handler
;;;1065   /**
;;;1066    * @brief  GPIO Group0 Handler
;;;1067    * @param  none
;;;1068    * @return none
;;;1069     */
;;;1070   void GPIO_Group0_Handler(void) DATA_RAM_FUNCTION;
;;;1071   void GPIO_Group0_Handler(void)
;;;1072   {
        0x00207cfe:    b510        ..      PUSH     {r4,lr}
;;;1073       uint32_t GPIOIrqStatus = GPIO->INTSTATUS;
        0x00207d00:    4812        .H      LDR      r0,[pc,#72] ; [0x207d4c] = 0x40001000
        0x00207d02:    6c04        .l      LDR      r4,[r0,#0x40]
;;;1074   
;;;1075       //Check exact IRQ function
;;;1076       if (GPIOIrqStatus & BIT0)
        0x00207d04:    f0040001    ....    AND      r0,r4,#1
        0x00207d08:    b108        ..      CBZ      r0,0x207d0e ; GPIO_Group0_Handler + 16
;;;1077       {
;;;1078           GPIO0_Handler();
        0x00207d0a:    f206f541    ..A.    BL       ADC_Handler ; 0x80e790
;;;1079       }
;;;1080       if (GPIOIrqStatus & BIT8)
        0x00207d0e:    f4047080    ...p    AND      r0,r4,#0x100
        0x00207d12:    b108        ..      CBZ      r0,0x207d18 ; GPIO_Group0_Handler + 26
;;;1081       {
;;;1082           GPIO8_Handler();
        0x00207d14:    f206f53c    ..<.    BL       ADC_Handler ; 0x80e790
;;;1083       }
;;;1084       if (GPIOIrqStatus & BIT12)
        0x00207d18:    f4045080    ...P    AND      r0,r4,#0x1000
        0x00207d1c:    b108        ..      CBZ      r0,0x207d22 ; GPIO_Group0_Handler + 36
;;;1085       {
;;;1086           GPIO12_Handler();
        0x00207d1e:    f206f537    ..7.    BL       ADC_Handler ; 0x80e790
;;;1087       }
;;;1088       if (GPIOIrqStatus & BIT16)
        0x00207d22:    f4043080    ...0    AND      r0,r4,#0x10000
        0x00207d26:    b108        ..      CBZ      r0,0x207d2c ; GPIO_Group0_Handler + 46
;;;1089       {
;;;1090           GPIO16_Handler();
        0x00207d28:    f206f532    ..2.    BL       ADC_Handler ; 0x80e790
;;;1091       }
;;;1092       if (GPIOIrqStatus & BIT20)
        0x00207d2c:    f4041080    ....    AND      r0,r4,#0x100000
        0x00207d30:    b108        ..      CBZ      r0,0x207d36 ; GPIO_Group0_Handler + 56
;;;1093       {
;;;1094           GPIO20_Handler();
        0x00207d32:    f206f52d    ..-.    BL       ADC_Handler ; 0x80e790
;;;1095       }
;;;1096       if (GPIOIrqStatus & BIT24)
        0x00207d36:    f0047080    ...p    AND      r0,r4,#0x1000000
        0x00207d3a:    b108        ..      CBZ      r0,0x207d40 ; GPIO_Group0_Handler + 66
;;;1097       {
;;;1098           GPIO24_Handler();
        0x00207d3c:    f206f528    ..(.    BL       ADC_Handler ; 0x80e790
;;;1099       }
;;;1100       if (GPIOIrqStatus & BIT28)
        0x00207d40:    f0045080    ...P    AND      r0,r4,#0x10000000
        0x00207d44:    b108        ..      CBZ      r0,0x207d4a ; GPIO_Group0_Handler + 76
;;;1101       {
;;;1102           GPIO28_Handler();
        0x00207d46:    f206f523    ..#.    BL       ADC_Handler ; 0x80e790
;;;1103       }
;;;1104   }
        0x00207d4a:    bd10        ..      POP      {r4,pc}
    $d
        0x00207d4c:    40001000    ...@    DCD    1073745920

** Section #6 'RAM_DATA_ON' (SHT_PROGBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 188 bytes (alignment 4)
    Address: 0x00207d50

    0x207d50:   74 65 72 01 01 03 19 00 00 02 01 05 03 19 00 00    ter.............
    0x207d60:   08 09 42 4c 45 5f 4f 54 41 00 00 00 81 ee 80 00    ..BLE_OTA.......
    0x207d70:   40 1e 81 00 4c 21 81 00 4c 21 81 00 fc 7f 20 00    @...L!..L!.... .
    0x207d80:   fc 7f 20 00 fc 7f 20 00 00 00 00 00 00 00 00 00    .. ... .........
    0x207d90:   00 00 00 00 30 1e 81 00 4c 21 81 00 4c 21 81 00    ....0...L!..L!..
    0x207da0:   fc 7f 20 00 fc 7f 20 00 fc 7f 20 00 00 00 00 00    .. ... ... .....
    0x207db0:   00 00 00 00 00 00 00 00 38 1e 81 00 4c 21 81 00    ........8...L!..
    0x207dc0:   4c 21 81 00 fc 7f 20 00 fc 7f 20 00 fc 7f 20 00    L!.... ... ... .
    0x207dd0:   00 00 00 00 00 00 00 00 00 00 00 00 00 01 02 00    ................
    0x207de0:   00 03 04 05 01 5d 00 00 00 00 01 fe 00 65 78 70    .....].......exp
    0x207df0:   65 72 69 6d 65 6e 74 61 6c 00 00 00 00 00 00 00    erimental.......
    0x207e00:   00 00 00 00 00 00 00 00 00 0e 00 00                ............


** Section #7 'RAM_DATA_ON' (SHT_NOBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 496 bytes (alignment 4)
    Address: 0x00207e0c


** Section #8 'App.trace' (SHT_PROGBITS) [SHF_ALLOC]
    Size   : 4876 bytes (alignment 4)
    Address: 0x08800000

    0x8800000:   21 2a 2a 52 45 53 45 54 20 52 65 61 73 6f 6e 3a    !**RESET Reason:
    0x8800010:   20 48 57 20 6f 72 20 4f 54 41 00 00 21 2a 2a 52     HW or OTA..!**R
    0x8800020:   45 53 45 54 20 52 65 61 73 6f 6e 3a 20 53 57 28    ESET Reason: SW(
    0x8800030:   72 65 73 65 74 20 65 78 63 65 70 74 20 61 6f 6e    reset except aon
    0x8800040:   29 2c 20 54 59 50 45 20 30 78 25 78 00 00 00 00    ), TYPE 0x%x....
    0x8800050:   21 2a 2a 52 45 53 45 54 20 52 65 61 73 6f 6e 3a    !**RESET Reason:
    0x8800060:   20 53 57 28 72 65 73 65 74 20 61 6c 6c 29 2c 20     SW(reset all), 
    0x8800070:   54 59 50 45 20 30 78 25 78 00 00 00 21 21 21 53    TYPE 0x%x...!!!S
    0x8800080:   44 4b 20 56 65 72 3a 20 25 73 2c 20 42 75 69 6c    DK Ver: %s, Buil
    0x8800090:   64 20 54 69 6d 65 3a 20 25 73 00 00 21 21 2a 57    d Time: %s..!!*W
    0x88000a0:   61 72 6e 69 6e 67 21 20 25 73 20 69 73 20 75 70    arning! %s is up
    0x88000b0:   64 61 74 65 64 20 62 79 20 41 50 50 21 00 00 00    dated by APP!...
    0x88000c0:   21 21 2a 57 61 72 6e 69 6e 67 21 20 49 53 52 20    !!*Warning! ISR 
    0x88000d0:   25 73 20 69 73 20 75 70 64 61 74 65 64 20 62 79    %s is updated by
    0x88000e0:   20 41 50 50 21 00 00 00 21 2a 2a 70 65 72 69 70     APP!...!**perip
    0x88000f0:   68 5f 68 61 6e 64 6c 65 5f 64 65 76 5f 73 74 61    h_handle_dev_sta
    0x8800100:   74 65 5f 65 76 74 3a 20 69 6e 69 74 20 73 74 61    te_evt: init sta
    0x8800110:   74 65 20 25 64 2c 20 61 64 76 20 73 74 61 74 65    te %d, adv state
    0x8800120:   20 25 64 2c 20 63 6f 6e 6e 20 73 74 61 74 65 20     %d, conn state 
    0x8800130:   25 64 2c 20 63 61 75 73 65 20 30 78 25 78 00 00    %d, cause 0x%x..
    0x8800140:   21 2a 2a 47 41 50 20 61 64 76 20 73 74 6f 70 65    !**GAP adv stope
    0x8800150:   64 3a 20 62 65 63 61 75 73 65 20 63 6f 6e 6e 65    d: because conne
    0x8800160:   63 74 69 6f 6e 20 63 72 65 61 74 65 64 00 00 00    ction created...
    0x8800170:   21 2a 2a 47 41 50 20 61 64 76 20 73 74 6f 70 65    !**GAP adv stope
    0x8800180:   64 00 00 00 21 2a 2a 47 41 50 20 61 64 76 20 73    d...!**GAP adv s
    0x8800190:   74 61 72 74 00 00 00 00 21 2a 2a 63 6f 6e 6e 20    tart....!**conn 
    0x88001a0:   73 74 61 74 65 3a 20 25 64 20 2d 3e 20 25 64 00    state: %d -> %d.
    0x88001b0:   21 2a 2a 70 65 72 69 70 68 5f 68 61 6e 64 6c 65    !**periph_handle
    0x88001c0:   5f 63 6f 6e 6e 5f 73 74 61 74 65 5f 65 76 74 3a    _conn_state_evt:
    0x88001d0:   20 63 6f 6e 6e 5f 69 64 20 3d 20 25 64 20 6f 6c     conn_id = %d ol
    0x88001e0:   64 5f 73 74 61 74 65 20 3d 20 25 64 20 6e 65 77    d_state = %d new
    0x88001f0:   5f 73 74 61 74 65 20 3d 20 25 64 00 21 21 21 63    _state = %d.!!!c
    0x8800200:   6f 6e 6e 65 63 74 69 6f 6e 20 6c 6f 73 74 3a 20    onnection lost: 
    0x8800210:   63 61 75 73 65 20 30 78 25 78 00 00 21 2a 2a 64    cause 0x%x..!**d
    0x8800220:   69 73 63 5f 63 61 75 73 65 20 69 73 20 25 64 00    isc_cause is %d.
    0x8800230:   21 2a 2a 47 41 50 5f 43 4f 4e 4e 5f 53 54 41 54    !**GAP_CONN_STAT
    0x8800240:   45 5f 43 4f 4e 4e 45 43 54 45 44 3a 72 65 6d 6f    E_CONNECTED:remo
    0x8800250:   74 65 5f 62 64 20 25 73 2c 20 72 65 6d 6f 74 65    te_bd %s, remote
    0x8800260:   5f 61 64 64 72 5f 74 79 70 65 20 25 64 2c 20 63    _addr_type %d, c
    0x8800270:   6f 6e 6e 5f 69 6e 74 65 72 76 61 6c 20 30 78 25    onn_interval 0x%
    0x8800280:   78 2c 20 63 6f 6e 6e 5f 6c 61 74 65 6e 63 79 20    x, conn_latency 
    0x8800290:   30 78 25 78 2c 20 63 6f 6e 6e 5f 73 75 70 65 72    0x%x, conn_super
    0x88002a0:   76 69 73 69 6f 6e 5f 74 69 6d 65 6f 75 74 20 30    vision_timeout 0
    0x88002b0:   78 25 78 00 21 2a 2a 70 65 72 69 70 68 5f 68 61    x%x.!**periph_ha
    0x88002c0:   6e 64 6c 65 5f 61 75 74 68 65 6e 5f 73 74 61 74    ndle_authen_stat
    0x88002d0:   65 5f 65 76 74 3a 63 6f 6e 6e 5f 69 64 20 25 64    e_evt:conn_id %d
    0x88002e0:   00 00 00 00 21 2a 2a 61 70 70 5f 68 61 6e 64 6c    ....!**app_handl
    0x88002f0:   65 5f 61 75 74 68 65 6e 5f 73 74 61 74 65 5f 65    e_authen_state_e
    0x8800300:   76 74 3a 20 47 41 50 5f 41 55 54 48 45 4e 5f 53    vt: GAP_AUTHEN_S
    0x8800310:   54 41 54 45 5f 53 54 41 52 54 45 44 00 00 00 00    TATE_STARTED....
    0x8800320:   21 2a 2a 61 70 70 5f 68 61 6e 64 6c 65 5f 61 75    !**app_handle_au
    0x8800330:   74 68 65 6e 5f 73 74 61 74 65 5f 65 76 74 3a 20    then_state_evt: 
    0x8800340:   47 41 50 5f 41 55 54 48 45 4e 5f 53 54 41 54 45    GAP_AUTHEN_STATE
    0x8800350:   5f 43 4f 4d 50 4c 45 54 45 20 70 61 69 72 20 73    _COMPLETE pair s
    0x8800360:   75 63 63 65 73 73 00 00 21 2a 2a 61 70 70 5f 68    uccess..!**app_h
    0x8800370:   61 6e 64 6c 65 5f 61 75 74 68 65 6e 5f 73 74 61    andle_authen_sta
    0x8800380:   74 65 5f 65 76 74 3a 20 47 41 50 5f 41 55 54 48    te_evt: GAP_AUTH
    0x8800390:   45 4e 5f 53 54 41 54 45 5f 43 4f 4d 50 4c 45 54    EN_STATE_COMPLET
    0x88003a0:   45 20 70 61 69 72 20 66 61 69 6c 65 64 00 00 00    E pair failed...
    0x88003b0:   21 21 21 61 70 70 5f 68 61 6e 64 6c 65 5f 61 75    !!!app_handle_au
    0x88003c0:   74 68 65 6e 5f 73 74 61 74 65 5f 65 76 74 3a 20    then_state_evt: 
    0x88003d0:   75 6e 6b 6e 6f 77 6e 20 6e 65 77 73 74 61 74 65    unknown newstate
    0x88003e0:   20 25 64 00 21 2a 2a 47 41 50 5f 4d 53 47 5f 4c     %d.!**GAP_MSG_L
    0x88003f0:   45 5f 43 4f 4e 4e 5f 50 41 52 41 4d 5f 55 50 44    E_CONN_PARAM_UPD
    0x8800400:   41 54 45 20 75 70 64 61 74 65 20 73 75 63 63 65    ATE update succe
    0x8800410:   73 73 2c 20 63 6f 6e 6e 5f 69 6e 74 65 72 76 61    ss, conn_interva
    0x8800420:   6c 20 3d 20 30 78 25 78 2c 20 63 6f 6e 6e 5f 73    l = 0x%x, conn_s
    0x8800430:   6c 61 76 65 5f 6c 61 74 65 6e 63 79 20 3d 20 30    lave_latency = 0
    0x8800440:   78 25 78 2c 20 63 6f 6e 6e 5f 73 75 70 65 72 76    x%x, conn_superv
    0x8800450:   69 73 69 6f 6e 5f 74 69 6d 65 6f 75 74 20 3d 20    ision_timeout = 
    0x8800460:   30 78 25 78 00 00 00 00 21 21 21 47 41 50 5f 4d    0x%x....!!!GAP_M
    0x8800470:   53 47 5f 4c 45 5f 43 4f 4e 4e 5f 50 41 52 41 4d    SG_LE_CONN_PARAM
    0x8800480:   5f 55 50 44 41 54 45 20 66 61 69 6c 65 64 3a 20    _UPDATE failed: 
    0x8800490:   63 61 75 73 65 20 30 78 25 78 00 00 21 2a 2a 47    cause 0x%x..!**G
    0x88004a0:   41 50 5f 4d 53 47 5f 4c 45 5f 43 4f 4e 4e 5f 50    AP_MSG_LE_CONN_P
    0x88004b0:   41 52 41 4d 5f 55 50 44 41 54 45 20 72 65 71 75    ARAM_UPDATE requ
    0x88004c0:   65 73 74 20 73 75 63 63 65 73 73 2e 00 00 00 00    est success.....
    0x88004d0:   70 65 72 69 70 68 5f 68 61 6e 64 6c 65 5f 67 61    periph_handle_ga
    0x88004e0:   70 5f 6d 73 67 20 73 75 62 74 79 70 65 20 3d 20    p_msg subtype = 
    0x88004f0:   25 64 00 00 21 2a 2a 47 41 50 5f 4d 53 47 5f 4c    %d..!**GAP_MSG_L
    0x8800500:   45 5f 42 4f 4e 44 5f 4a 55 53 54 5f 57 4f 52 4b    E_BOND_JUST_WORK
    0x8800510:   00 00 00 00 21 2a 2a 47 41 50 5f 4d 53 47 5f 4c    ....!**GAP_MSG_L
    0x8800520:   45 5f 42 4f 4e 44 5f 50 41 53 53 4b 45 59 5f 44    E_BOND_PASSKEY_D
    0x8800530:   49 53 50 4c 41 59 3a 70 61 73 73 6b 65 79 20 25    ISPLAY:passkey %
    0x8800540:   64 00 00 00 21 2a 2a 47 41 50 5f 4d 53 47 5f 4c    d...!**GAP_MSG_L
    0x8800550:   45 5f 42 4f 4e 44 5f 55 53 45 52 5f 43 4f 4e 46    E_BOND_USER_CONF
    0x8800560:   49 52 4d 41 54 49 4f 4e 3a 20 70 61 73 73 6b 65    IRMATION: passke
    0x8800570:   79 20 25 64 00 00 00 00 21 2a 2a 47 41 50 5f 4d    y %d....!**GAP_M
    0x8800580:   53 47 5f 4c 45 5f 42 4f 4e 44 5f 50 41 53 53 4b    SG_LE_BOND_PASSK
    0x8800590:   45 59 5f 49 4e 50 55 54 3a 20 63 6f 6e 6e 5f 69    EY_INPUT: conn_i
    0x88005a0:   64 20 25 64 00 00 00 00 21 2a 2a 47 41 50 5f 4d    d %d....!**GAP_M
    0x88005b0:   53 47 5f 4c 45 5f 42 4f 4e 44 5f 4f 4f 42 5f 49    SG_LE_BOND_OOB_I
    0x88005c0:   4e 50 55 54 00 00 00 00 21 21 21 70 65 72 69 70    NPUT....!!!perip
    0x88005d0:   68 5f 68 61 6e 64 6c 65 5f 67 61 70 5f 6d 73 67    h_handle_gap_msg
    0x88005e0:   3a 20 75 6e 6b 6e 6f 77 6e 20 73 75 62 74 79 70    : unknown subtyp
    0x88005f0:   65 20 25 64 00 00 00 00 21 2a 2a 47 41 50 5f 4d    e %d....!**GAP_M
    0x8800600:   53 47 5f 4c 45 5f 44 41 54 41 5f 4c 45 4e 5f 43    SG_LE_DATA_LEN_C
    0x8800610:   48 41 4e 47 45 5f 49 4e 46 4f 3a 20 63 6f 6e 6e    HANGE_INFO: conn
    0x8800620:   5f 69 64 20 25 64 2c 20 74 78 20 6f 63 74 65 74    _id %d, tx octet
    0x8800630:   73 20 30 78 25 78 2c 20 6d 61 78 5f 74 78 5f 74    s 0x%x, max_tx_t
    0x8800640:   69 6d 65 20 30 78 25 78 00 00 00 00 21 2a 2a 47    ime 0x%x....!**G
    0x8800650:   41 50 5f 4d 53 47 5f 4c 45 5f 42 4f 4e 44 5f 4d    AP_MSG_LE_BOND_M
    0x8800660:   4f 44 49 46 59 5f 49 4e 46 4f 3a 20 74 79 70 65    ODIFY_INFO: type
    0x8800670:   20 30 78 25 78 00 00 00 21 2a 2a 47 41 50 5f 4d     0x%x...!**GAP_M
    0x8800680:   53 47 5f 4c 45 5f 4d 4f 44 49 46 59 5f 57 48 49    SG_LE_MODIFY_WHI
    0x8800690:   54 45 5f 4c 49 53 54 3a 20 6f 70 65 72 61 74 69    TE_LIST: operati
    0x88006a0:   6f 6e 20 25 64 2c 20 63 61 75 73 65 20 30 78 25    on %d, cause 0x%
    0x88006b0:   78 00 00 00 21 2a 2a 61 70 70 5f 67 61 70 5f 63    x...!**app_gap_c
    0x88006c0:   61 6c 6c 62 61 63 6b 3a 20 75 6e 68 61 6e 64 6c    allback: unhandl
    0x88006d0:   65 64 20 63 62 5f 74 79 70 65 20 30 78 25 78 00    ed cb_type 0x%x.
    0x88006e0:   21 2a 2a 50 52 4f 46 49 4c 45 5f 45 56 54 5f 53    !**PROFILE_EVT_S
    0x88006f0:   52 56 5f 52 45 47 5f 43 4f 4d 50 4c 45 54 45 3a    RV_REG_COMPLETE:
    0x8800700:   20 72 65 73 75 6c 74 20 25 64 00 00 21 2a 2a 50     result %d..!**P
    0x8800710:   52 4f 46 49 4c 45 5f 45 56 54 5f 53 45 4e 44 5f    ROFILE_EVT_SEND_
    0x8800720:   44 41 54 41 5f 43 4f 4d 50 4c 45 54 45 3a 20 63    DATA_COMPLETE: c
    0x8800730:   6f 6e 6e 5f 69 64 20 25 64 2c 20 63 61 75 73 65    onn_id %d, cause
    0x8800740:   20 30 78 25 78 2c 20 73 65 72 76 69 63 65 5f 69     0x%x, service_i
    0x8800750:   64 20 25 64 2c 20 61 74 74 72 69 62 5f 69 64 78    d %d, attrib_idx
    0x8800760:   20 30 78 25 78 2c 20 63 72 65 64 69 74 73 20 3d     0x%x, credits =
    0x8800770:   20 25 64 00 21 2a 2a 50 52 4f 46 49 4c 45 5f 45     %d.!**PROFILE_E
    0x8800780:   56 54 5f 53 45 4e 44 5f 44 41 54 41 5f 43 4f 4d    VT_SEND_DATA_COM
    0x8800790:   50 4c 45 54 45 20 73 75 63 63 65 73 73 00 00 00    PLETE success...
    0x88007a0:   21 21 21 50 52 4f 46 49 4c 45 5f 45 56 54 5f 53    !!!PROFILE_EVT_S
    0x88007b0:   45 4e 44 5f 44 41 54 41 5f 43 4f 4d 50 4c 45 54    END_DATA_COMPLET
    0x88007c0:   45 20 66 61 69 6c 65 64 00 00 00 00 21 2a 2a 42    E failed....!**B
    0x88007d0:   61 74 74 65 72 79 20 6c 65 76 65 6c 20 6e 6f 74    attery level not
    0x88007e0:   69 66 69 63 61 74 69 6f 6e 20 65 6e 61 62 6c 65    ification enable
    0x88007f0:   00 00 00 00 21 2a 2a 42 61 74 74 65 72 79 20 6c    ....!**Battery l
    0x8800800:   65 76 65 6c 20 6e 6f 74 69 66 69 63 61 74 69 6f    evel notificatio
    0x8800810:   6e 20 64 69 73 61 62 6c 65 00 00 00 21 2a 2a 52    n disable...!**R
    0x8800820:   43 55 5f 42 61 74 74 65 72 79 5f 4c 65 76 65 6c    CU_Battery_Level
    0x8800830:   5f 55 70 64 61 74 65 20 42 61 74 56 6f 6c 20 69    _Update BatVol i
    0x8800840:   73 20 25 64 20 2c 20 42 41 53 42 61 74 74 65 72    s %d , BASBatter
    0x8800850:   79 4c 65 76 65 6c 20 69 73 20 25 64 0a 00 00 00    yLevel is %d....
    0x8800860:   21 2a 2a 50 72 65 70 61 72 69 6e 67 20 73 77 69    !**Preparing swi
    0x8800870:   74 63 68 20 69 6e 74 6f 20 4f 54 41 20 6d 6f 64    tch into OTA mod
    0x8800880:   65 0a 00 00 68 65 61 70 20 74 79 70 65 3a 20 25    e...heap type: %
    0x8800890:   69 2c 20 74 6f 74 61 6c 20 73 69 7a 65 3a 20 25    i, total size: %
    0x88008a0:   64 2c 20 72 65 6d 61 69 6e 20 73 69 7a 65 3a 20    d, remain size: 
    0x88008b0:   25 64 2c 20 6d 69 6e 75 6d 75 6d 20 65 76 65 72    %d, minumum ever
    0x88008c0:   20 66 72 65 65 20 73 69 7a 65 3a 20 25 64 00 00     free size: %d..
    0x88008d0:   66 72 65 65 20 6c 69 73 74 3a 20 66 72 65 65 20    free list: free 
    0x88008e0:   62 6c 6f 63 6b 20 25 64 2e 00 00 00 68 65 61 70    block %d....heap
    0x88008f0:   20 74 79 70 65 3a 20 25 69 2c 66 72 65 65 20 62     type: %i,free b
    0x8800900:   6c 6f 63 6b 3a 20 25 64 2c 20 66 72 65 65 20 73    lock: %d, free s
    0x8800910:   69 7a 65 3a 20 25 64 00 74 61 73 6b 20 73 74 61    ize: %d.task sta
    0x8800920:   63 6b 3a 20 74 61 73 6b 20 6e 75 6d 62 65 72 20    ck: task number 
    0x8800930:   25 64 00 00 74 61 73 6b 20 69 64 3a 20 25 64 2c    %d..task id: %d,
    0x8800940:   20 6e 61 6d 65 3a 20 25 73 2c 20 6d 69 6e 69 6d     name: %s, minim
    0x8800950:   75 6d 20 65 76 65 72 20 72 65 6d 61 69 6e 20 73    um ever remain s
    0x8800960:   69 7a 65 20 25 64 20 62 79 74 65 73 00 00 00 00    ize %d bytes....
    0x8800970:   6d 61 69 6e 20 73 74 61 63 6b 3a 20 6d 69 6e 69    main stack: mini
    0x8800980:   6d 75 6d 20 65 76 65 72 20 72 65 6d 61 69 6e 20    mum ever remain 
    0x8800990:   73 69 7a 65 20 25 64 20 62 79 74 65 73 00 00 00    size %d bytes...
    0x88009a0:   74 69 6d 65 72 3a 20 74 6f 74 61 6c 20 25 64 2c    timer: total %d,
    0x88009b0:   20 63 75 72 72 65 6e 74 20 75 73 65 64 20 25 64     current used %d
    0x88009c0:   2c 20 6d 69 6e 69 6d 75 6d 20 65 76 65 72 20 72    , minimum ever r
    0x88009d0:   65 6d 61 69 6e 20 25 64 00 00 00 00 71 75 65 75    emain %d....queu
    0x88009e0:   65 20 25 64 3a 20 63 61 70 61 63 69 74 79 5f 6e    e %d: capacity_n
    0x88009f0:   75 6d 20 25 64 2c 20 63 75 72 72 5f 6e 75 6d 5f    um %d, curr_num_
    0x8800a00:   69 6e 5f 71 75 65 75 65 20 25 64 2c 20 6d 61 78    in_queue %d, max
    0x8800a10:   69 6d 75 6d 5f 65 76 65 72 5f 6e 75 6d 5f 69 6e    imum_ever_num_in
    0x8800a20:   5f 71 75 65 75 65 20 25 64 00 00 00 21 21 21 74    _queue %d...!!!t
    0x8800a30:   72 61 63 65 20 64 6c 70 73 20 69 6e 69 74 20 66    race dlps init f
    0x8800a40:   61 69 6c 21 00 00 00 00 21 21 21 62 61 73 5f 73    ail!....!!!bas_s
    0x8800a50:   65 74 5f 70 61 72 61 6d 65 74 65 72 20 66 61 69    et_parameter fai
    0x8800a60:   6c 65 64 00 21 2a 2a 62 61 73 5f 61 74 74 72 5f    led.!**bas_attr_
    0x8800a70:   72 65 61 64 5f 63 62 20 61 74 74 72 69 62 5f 69    read_cb attrib_i
    0x8800a80:   6e 64 65 78 20 3d 20 25 64 20 6f 66 66 73 65 74    ndex = %d offset
    0x8800a90:   20 25 78 00 21 21 21 62 61 73 5f 61 74 74 72 5f     %x.!!!bas_attr_
    0x8800aa0:   72 65 61 64 5f 63 62 20 61 74 74 72 69 62 5f 69    read_cb attrib_i
    0x8800ab0:   6e 64 65 78 20 3d 20 25 64 20 6e 6f 74 20 66 6f    ndex = %d not fo
    0x8800ac0:   75 6e 64 00 21 2a 2a 62 61 73 5f 63 63 63 64 5f    und.!**bas_cccd_
    0x8800ad0:   75 70 64 61 74 65 5f 63 62 20 69 6e 64 65 78 20    update_cb index 
    0x8800ae0:   3d 20 25 64 20 63 63 63 5f 62 69 74 73 20 25 78    = %d ccc_bits %x
    0x8800af0:   00 00 00 00 21 21 21 62 61 73 5f 61 64 64 5f 73    ....!!!bas_add_s
    0x8800b00:   65 72 76 69 63 65 3a 20 73 65 72 76 69 63 65 5f    ervice: service_
    0x8800b10:   69 64 20 25 64 00 00 00 21 21 21 44 49 53 20 70    id %d...!!!DIS p
    0x8800b20:   61 72 61 6d 65 74 65 72 20 73 65 74 20 66 61 69    arameter set fai
    0x8800b30:   6c 65 64 00 21 21 21 64 69 73 5f 61 74 74 72 5f    led.!!!dis_attr_
    0x8800b40:   72 65 61 64 5f 63 62 3a 20 61 74 74 72 69 62 5f    read_cb: attrib_
    0x8800b50:   69 6e 64 65 78 20 25 64 00 00 00 00 21 2a 2a 64    index %d....!**d
    0x8800b60:   69 73 5f 61 74 74 72 5f 72 65 61 64 5f 63 62 3a    is_attr_read_cb:
    0x8800b70:   20 61 74 74 72 69 62 5f 69 6e 64 65 78 20 25 64     attrib_index %d
    0x8800b80:   2c 20 2a 6c 65 6e 67 74 68 5f 70 74 72 20 25 64    , *length_ptr %d
    0x8800b90:   00 00 00 00 21 21 21 64 69 73 5f 61 64 64 5f 73    ....!!!dis_add_s
    0x8800ba0:   65 72 76 69 63 65 3a 20 73 65 72 76 69 63 65 5f    ervice: service_
    0x8800bb0:   69 64 20 25 64 00 00 00 21 2a 2a 2d 2d 3e 20 4f    id %d...!**--> O
    0x8800bc0:   54 41 5f 41 74 74 72 57 72 69 74 65 20 45 72 72    TA_AttrWrite Err
    0x8800bd0:   6f 72 20 20 69 41 74 74 72 69 62 49 6e 64 65 78    or  iAttribIndex
    0x8800be0:   20 3d 20 30 78 25 78 20 77 4c 65 6e 67 74 68 3d     = 0x%x wLength=
    0x8800bf0:   25 64 00 00 21 2a 2a 3c 2d 2d 20 4f 54 41 5f 41    %d..!**<-- OTA_A
    0x8800c00:   74 74 72 52 65 61 64 2c 20 41 74 74 72 20 6e 6f    ttrRead, Attr no
    0x8800c10:   74 20 66 6f 75 6e 64 2c 20 69 6e 64 65 78 3d 25    t found, index=%
    0x8800c20:   64 00 00 00 21 2a 2a 70 61 74 63 68 5f 61 64 64    d...!**patch_add
    0x8800c30:   72 20 3d 20 25 78 00 00 21 2a 2a 70 61 74 63 68    r = %x..!**patch
    0x8800c40:   5f 76 65 72 73 69 6f 6e 20 3d 20 25 78 00 00 00    _version = %x...
    0x8800c50:   21 2a 2a 61 70 70 5f 61 64 64 72 20 3d 20 25 78    !**app_addr = %x
    0x8800c60:   00 00 00 00 21 2a 2a 61 70 70 5f 76 65 72 73 69    ....!**app_versi
    0x8800c70:   6f 6e 20 3d 20 25 78 00 21 2a 2a 6f 74 61 20 68    on = %x.!**ota h
    0x8800c80:   65 61 64 65 72 20 61 64 64 72 20 3d 20 25 78 00    eader addr = %x.
    0x8800c90:   21 2a 2a 4f 54 41 20 48 65 61 64 65 72 20 56 5f    !**OTA Header V_
    0x8800ca0:   30 78 25 58 2c 20 50 61 74 63 68 20 56 5f 30 78    0x%X, Patch V_0x
    0x8800cb0:   25 58 2c 20 41 50 50 20 56 5f 30 78 25 58 00 00    %X, APP V_0x%X..
    0x8800cc0:   21 2a 2a 4f 54 41 20 48 65 61 64 65 72 20 56 5f    !**OTA Header V_
    0x8800cd0:   30 78 25 58 2c 20 53 65 63 75 72 65 20 42 6f 6f    0x%X, Secure Boo
    0x8800ce0:   74 20 56 5f 30 78 25 58 2c 20 50 61 74 63 68 20    t V_0x%X, Patch 
    0x8800cf0:   56 5f 30 78 25 58 2c 20 41 50 50 20 56 5f 30 78    V_0x%X, APP V_0x
    0x8800d00:   25 58 00 00 21 21 21 4f 54 41 53 65 72 76 69 63    %X..!!!OTAServic
    0x8800d10:   65 5f 41 64 64 53 65 72 76 69 63 65 3a 20 53 65    e_AddService: Se
    0x8800d20:   72 76 69 63 65 49 64 20 25 64 00 00 21 21 2a 6d    rviceId %d..!!*m
    0x8800d30:   69 73 73 20 69 6e 74 65 72 72 75 70 74 3a 20 70    iss interrupt: p
    0x8800d40:   65 6e 64 69 6e 67 20 72 65 67 69 73 74 65 72 3a    ending register:
    0x8800d50:   20 30 78 25 78 00 00 00 21 21 21 67 61 70 5f 6c     0x%x...!!!gap_l
    0x8800d60:   69 62 5f 69 6e 69 74 3a 20 76 65 72 20 25 64 2c    ib_init: ver %d,
    0x8800d70:   20 46 5f 42 54 5f 4c 45 5f 35 5f 30 5f 53 55 50     F_BT_LE_5_0_SUP
    0x8800d80:   50 4f 52 54 20 25 64 2c 20 46 5f 42 54 5f 4c 45    PORT %d, F_BT_LE
    0x8800d90:   5f 35 5f 30 5f 41 45 5f 41 44 56 5f 53 55 50 50    _5_0_AE_ADV_SUPP
    0x8800da0:   4f 52 54 20 25 64 2c 20 46 5f 42 54 5f 4c 45 5f    ORT %d, F_BT_LE_
    0x8800db0:   35 5f 30 5f 41 45 5f 53 43 41 4e 5f 53 55 50 50    5_0_AE_SCAN_SUPP
    0x8800dc0:   4f 52 54 20 25 64 2c 20 46 5f 42 54 5f 4c 45 5f    ORT %d, F_BT_LE_
    0x8800dd0:   34 5f 31 5f 43 42 43 5f 53 55 50 50 4f 52 54 20    4_1_CBC_SUPPORT 
    0x8800de0:   25 64 2c 20 46 5f 42 54 5f 56 45 4e 44 4f 52 5f    %d, F_BT_VENDOR_
    0x8800df0:   46 45 41 54 55 52 45 5f 53 55 50 50 4f 52 54 20    FEATURE_SUPPORT 
    0x8800e00:   25 64 2c 20 46 5f 42 54 5f 4c 45 5f 36 5f 30 5f    %d, F_BT_LE_6_0_
    0x8800e10:   41 4f 41 5f 41 4f 44 5f 53 55 50 50 4f 52 54 20    AOA_AOD_SUPPORT 
    0x8800e20:   25 64 2c 20 46 5f 42 54 5f 4c 45 5f 36 5f 30 5f    %d, F_BT_LE_6_0_
    0x8800e30:   41 4f 58 5f 43 4f 4e 4e 4c 45 53 53 5f 53 55 50    AOX_CONNLESS_SUP
    0x8800e40:   50 4f 52 54 20 25 64 00 21 21 21 67 61 70 5f 6c    PORT %d.!!!gap_l
    0x8800e50:   69 62 5f 69 6e 69 74 3a 20 46 5f 42 54 5f 4c 45    ib_init: F_BT_LE
    0x8800e60:   5f 53 4d 50 5f 53 43 5f 4f 4f 42 5f 53 55 50 50    _SMP_SC_OOB_SUPP
    0x8800e70:   4f 52 54 20 25 64 2c 20 46 5f 42 54 5f 53 57 5f    ORT %d, F_BT_SW_
    0x8800e80:   52 45 53 45 54 5f 53 55 50 50 4f 52 54 20 25 64    RESET_SUPPORT %d
    0x8800e90:   2c 20 46 5f 42 54 5f 50 41 54 43 48 5f 46 4f 52    , F_BT_PATCH_FOR
    0x8800ea0:   5f 43 48 41 4e 47 45 5f 41 50 49 20 25 64 2c 20    _CHANGE_API %d, 
    0x8800eb0:   46 5f 42 54 5f 44 4c 50 53 5f 41 50 49 20 25 64    F_BT_DLPS_API %d
    0x8800ec0:   2c 20 46 5f 42 54 5f 43 4f 4e 46 49 47 5f 41 50    , F_BT_CONFIG_AP
    0x8800ed0:   49 20 25 64 2c 20 46 5f 42 54 5f 56 45 4e 44 4f    I %d, F_BT_VENDO
    0x8800ee0:   52 5f 41 50 49 20 25 64 2c 20 46 5f 42 54 5f 50    R_API %d, F_BT_P
    0x8800ef0:   41 54 43 48 5f 46 4f 52 5f 43 48 41 4e 47 45 5f    ATCH_FOR_CHANGE_
    0x8800f00:   47 45 4e 5f 41 44 44 52 5f 41 50 49 20 25 64 2c    GEN_ADDR_API %d,
    0x8800f10:   20 46 5f 42 54 5f 50 41 54 43 48 5f 42 4f 4e 44     F_BT_PATCH_BOND
    0x8800f20:   5f 49 4e 46 4f 52 4d 41 54 49 4f 4e 20 25 64 00    _INFORMATION %d.
    0x8800f30:   21 2a 2a 6c 65 5f 63 68 65 63 6b 5f 70 72 69 76    !**le_check_priv
    0x8800f40:   61 63 79 5f 62 6f 6e 64 3a 20 69 64 78 20 25 64    acy_bond: idx %d
    0x8800f50:   20 70 72 69 76 61 63 79 20 64 65 76 69 63 65 00     privacy device.
    0x8800f60:   21 2a 2a 6c 65 5f 63 68 65 63 6b 5f 70 72 69 76    !**le_check_priv
    0x8800f70:   61 63 79 5f 62 6f 6e 64 3a 20 6e 6f 74 20 70 72    acy_bond: not pr
    0x8800f80:   69 76 61 63 79 20 64 65 76 69 63 65 2c 20 63 61    ivacy device, ca
    0x8800f90:   75 73 65 20 25 64 00 00 21 2a 2a 6c 65 5f 67 65    use %d..!**le_ge
    0x8800fa0:   6e 5f 72 61 6e 64 5f 61 64 64 72 3a 20 67 61 70    n_rand_addr: gap
    0x8800fb0:   5f 6c 69 62 2c 20 72 61 6e 64 6f 6d 20 61 64 64    _lib, random add
    0x8800fc0:   72 20 25 73 2c 20 61 64 64 72 20 74 79 70 65 20    r %s, addr type 
    0x8800fd0:   25 64 00 00 70 61 74 63 68 5f 6c 65 5f 6c 69 6e    %d..patch_le_lin
    0x8800fe0:   6b 5f 64 69 73 63 6f 6e 6e 65 63 74 65 64 3a 20    k_disconnected: 
    0x8800ff0:   67 61 70 5f 6c 69 6e 6b 5f 63 72 65 64 69 74 73    gap_link_credits
    0x8801000:   20 25 64 00 21 21 21 70 61 74 63 68 5f 6c 65 5f     %d.!!!patch_le_
    0x8801010:   6c 69 6e 6b 5f 64 69 73 63 6f 6e 6e 65 63 74 65    link_disconnecte
    0x8801020:   64 3a 20 6e 6f 74 20 66 69 6e 64 20 6c 69 6e 6b    d: not find link
    0x8801030:   00 00 00 00 21 21 21 70 61 74 63 68 5f 6c 65 5f    ....!!!patch_le_
    0x8801040:   6c 69 6e 6b 5f 68 61 6e 64 6c 65 5f 64 69 73 63    link_handle_disc
    0x8801050:   6f 6e 6e 65 63 74 5f 72 73 70 3a 20 63 61 75 73    onnect_rsp: caus
    0x8801060:   65 20 30 78 25 78 00 00 21 2a 2a 6c 65 5f 62 6f    e 0x%x..!**le_bo
    0x8801070:   6e 64 5f 67 65 74 5f 73 65 63 5f 6c 65 76 65 6c    nd_get_sec_level
    0x8801080:   3a 20 25 64 00 00 00 00 21 21 21 6c 65 5f 67 65    : %d....!!!le_ge
    0x8801090:   74 5f 64 65 76 5f 62 6f 6e 64 5f 69 6e 66 6f 3a    t_dev_bond_info:
    0x88010a0:   20 69 6e 76 61 6c 69 64 20 69 64 78 00 00 00 00     invalid idx....
    0x88010b0:   21 21 21 6c 65 5f 67 65 74 5f 64 65 76 5f 62 6f    !!!le_get_dev_bo
    0x88010c0:   6e 64 5f 69 6e 66 6f 3a 20 66 61 69 6c 65 64 2c    nd_info: failed,
    0x88010d0:   20 69 6e 76 61 6c 69 64 20 70 61 72 61 6d 74 65     invalid paramte
    0x88010e0:   72 00 00 00 21 2a 2a 6c 65 5f 6b 65 79 5f 65 6e    r...!**le_key_en
    0x88010f0:   74 72 79 5f 69 6e 69 74 3a 20 69 64 78 20 25 64    try_init: idx %d
    0x8801100:   2c 20 61 64 64 72 20 25 73 2c 20 72 65 6d 6f 74    , addr %s, remot
    0x8801110:   65 5f 62 64 5f 74 79 70 65 20 25 64 2c 20 66 6c    e_bd_type %d, fl
    0x8801120:   61 67 73 20 30 78 25 30 32 78 2c 20 6c 6f 63 61    ags 0x%02x, loca
    0x8801130:   6c 5f 62 64 5f 74 79 70 65 20 25 64 00 00 00 00    l_bd_type %d....
    0x8801140:   21 21 21 6c 65 5f 73 65 74 5f 64 65 76 5f 62 6f    !!!le_set_dev_bo
    0x8801150:   6e 64 5f 69 6e 66 6f 3a 20 66 61 69 6c 65 64 2c    nd_info: failed,
    0x8801160:   20 69 6e 76 61 6c 69 64 20 70 61 72 61 6d 65 74     invalid paramet
    0x8801170:   65 72 00 00 21 21 21 6c 65 5f 73 65 74 5f 64 65    er..!!!le_set_de
    0x8801180:   76 5f 62 6f 6e 64 5f 69 6e 66 6f 3a 20 62 6f 6e    v_bond_info: bon
    0x8801190:   64 20 69 6e 66 6f 20 69 73 20 65 78 69 73 74 65    d info is existe
    0x88011a0:   64 00 00 00 21 21 21 6c 65 5f 73 65 74 5f 64 65    d...!!!le_set_de
    0x88011b0:   76 5f 62 6f 6e 64 5f 69 6e 66 6f 3a 20 6f 70 65    v_bond_info: ope
    0x88011c0:   72 61 74 69 6f 6e 20 6f 66 20 73 61 76 69 6e 67    ration of saving
    0x88011d0:   20 62 6f 6e 64 20 69 6e 66 6f 20 66 61 69 6c 65     bond info faile
    0x88011e0:   64 00 00 00 21 21 21 6c 65 5f 73 65 74 5f 64 65    d...!!!le_set_de
    0x88011f0:   76 5f 62 6f 6e 64 5f 69 6e 66 6f 3a 20 66 61 69    v_bond_info: fai
    0x8801200:   6c 65 64 00 21 21 21 6c 65 5f 77 72 69 74 65 5f    led.!!!le_write_
    0x8801210:   61 75 74 68 65 6e 5f 70 61 79 6c 6f 61 64 5f 74    authen_payload_t
    0x8801220:   69 6d 65 6f 75 74 3a 20 69 6e 76 61 6c 69 64 20    imeout: invalid 
    0x8801230:   70 61 72 61 6d 2c 20 63 6f 6e 6e 5f 69 64 20 25    param, conn_id %
    0x8801240:   64 2c 20 61 75 74 68 65 6e 5f 70 61 79 6c 6f 61    d, authen_payloa
    0x8801250:   64 5f 74 69 6d 65 6f 75 74 20 30 78 25 78 2c 20    d_timeout 0x%x, 
    0x8801260:   63 6f 6e 6e 5f 69 6e 74 65 72 76 61 6c 20 30 78    conn_interval 0x
    0x8801270:   25 78 2c 20 73 6c 61 76 65 20 6c 61 74 65 6e 63    %x, slave latenc
    0x8801280:   79 20 30 78 25 78 2c 20 74 69 6d 65 6f 75 74 20    y 0x%x, timeout 
    0x8801290:   30 78 25 78 20 6d 73 2c 20 6d 69 6e 69 6d 75 6d    0x%x ms, minimum
    0x88012a0:   20 76 61 6c 75 65 20 6f 66 20 74 69 6d 65 6f 75     value of timeou
    0x88012b0:   74 20 30 78 25 78 20 6d 73 00 00 00 21 2a 2a 44    t 0x%x ms...!**D
    0x88012c0:   4c 50 53 20 64 69 73 61 6c 6c 6f 77 20 66 75 6e    LPS disallow fun
    0x88012d0:   63 74 69 6f 6e 3a 20 30 78 25 78 2c 20 65 72 72    ction: 0x%x, err
    0x88012e0:   6f 72 20 63 6f 64 65 20 30 78 25 78 00 00 00 00    or code 0x%x....
    0x88012f0:   21 2a 2a 4e 4f 54 20 69 6e 20 44 4c 50 53 20 66    !**NOT in DLPS f
    0x8801300:   6f 72 20 25 64 20 6d 73 00 00 00 00                or %d ms....


** Section #9 'ER$$.ARM.__AT_0x00200E54' (SHT_NOBITS) [SHF_ALLOC + SHF_WRITE]
    Size   : 4 bytes (alignment 2)
    Address: 0x00200e54


** Section #10 '.debug_abbrev' (SHT_PROGBITS)
    Size   : 1476 bytes


** Section #11 '.debug_frame' (SHT_PROGBITS)
    Size   : 4212 bytes


** Section #12 '.debug_info' (SHT_PROGBITS)
    Size   : 173000 bytes


** Section #13 '.debug_line' (SHT_PROGBITS)
    Size   : 21484 bytes


** Section #14 '.debug_loc' (SHT_PROGBITS)
    Size   : 10416 bytes


** Section #15 '.debug_macinfo' (SHT_PROGBITS)
    Size   : 77776 bytes


** Section #16 '.debug_pubnames' (SHT_PROGBITS)
    Size   : 6689 bytes


** Section #17 '.symtab' (SHT_SYMTAB)
    Size   : 21856 bytes (alignment 4)
    String table #18 '.strtab'
    Last local symbol no. 431


** Section #18 '.strtab' (SHT_STRTAB)
    Size   : 21804 bytes


** Section #19 '.note' (SHT_NOTE)
    Size   : 52 bytes (alignment 4)


** Section #20 '.comment' (SHT_PROGBITS)
    Size   : 24424 bytes


** Section #21 '.shstrtab' (SHT_STRTAB)
    Size   : 316 bytes


address     size       variable name                            type
0x00207f14  0x4        gap_common_vendor_cb                     P_FUN_GAP_APP_CB

address     size       variable name                            type
0x00200e54  0x4        timer_counter                            TIMER_COUNTER
0x00200e54  0x2        timer_counter.uxTimerCreateCount         uint16_t
0x00200e56  0x2        timer_counter.uxTimerDeleteCount         uint16_t

address     size       variable name                            type
0x0081198c  0x10       GATT_UUID_OTA_SERVICE                    array[16] of const uint8_t

address     size       variable name                            type
0x00811bb0  0xc        OTAServiceCBs                            const T_FUN_GATT_SERVICE_CBS
0x00811bb0  0x4        OTAServiceCBs.read_attr_cb               P_FUN_GATT_READ_ATTR_CB
0x00811bb4  0x4        OTAServiceCBs.write_attr_cb              P_FUN_GATT_WRITE_ATTR_CB
0x00811bb8  0x4        OTAServiceCBs.cccd_update_cb             P_FUN_GATT_CCCD_UPDATE_CB

address     size       variable name                            type
0x00207ef0  0x4        app_version                              uint32_t

address     size       variable name                            type
0x0081199c  0x214      gattOtaServiceTable                      array[19] of const T_ATTRIB_APPL

address     size       variable name                            type
0x00207ee0  0x6        mac_addr                                 array[6] of uint8_t

address     size       variable name                            type
0x00207eec  0x4        patch_ext_version                        uint32_t

address     size       variable name                            type
0x00207ee8  0x4        patch_version                            uint32_t

address     size       variable name                            type
0x00207edc  0x4        pfnOTAExtendedCB                         P_FUN_SERVER_GENERAL_CB

address     size       variable name                            type
0x00811768  0x214      dis_attr_tbl                             array[19] of const T_ATTRIB_APPL

address     size       variable name                            type
0x0081197c  0x2        dis_attr_tbl_size                        const uint16_t

address     size       variable name                            type
0x00811980  0xc        dis_cbs                                  const T_FUN_GATT_SERVICE_CBS
0x00811980  0x4        dis_cbs.read_attr_cb                     P_FUN_GATT_READ_ATTR_CB
0x00811984  0x4        dis_cbs.write_attr_cb                    P_FUN_GATT_WRITE_ATTR_CB
0x00811988  0x4        dis_cbs.cccd_update_cb                   P_FUN_GATT_CCCD_UPDATE_CB

address     size       variable name                            type
0x00207eb0  0x14       dis_firmware_rev                         array[20] of uint8_t

address     size       variable name                            type
0x00207ec4  0x1        dis_firmware_rev_len                     uint8_t

address     size       variable name                            type
0x00207e9b  0x14       dis_hardware_rev                         array[20] of uint8_t

address     size       variable name                            type
0x00207eaf  0x1        dis_hardware_rev_len                     uint8_t

address     size       variable name                            type
0x00207deb  0x1e       dis_ieee_data_list                       array[30] of uint8_t

address     size       variable name                            type
0x00207e09  0x1        dis_ieee_data_list_len                   uint8_t

address     size       variable name                            type
0x00207e5c  0x14       dis_manufacturer_name                    array[20] of uint8_t

address     size       variable name                            type
0x00207e70  0x1        dis_manufacturer_name_len                uint8_t

address     size       variable name                            type
0x00207e71  0x14       dis_model_number                         array[20] of uint8_t

address     size       variable name                            type
0x00207e85  0x1        dis_model_number_len                     uint8_t

address     size       variable name                            type
0x00207de4  0x7        dis_pnp_id                               array[7] of uint8_t

address     size       variable name                            type
0x00207e86  0x14       dis_serial_number                        array[20] of uint8_t

address     size       variable name                            type
0x00207e9a  0x1        dis_serial_number_len                    uint8_t

address     size       variable name                            type
0x00207ec5  0x14       dis_software_rev                         array[20] of uint8_t

address     size       variable name                            type
0x00207ed9  0x1        dis_software_rev_len                     uint8_t

address     size       variable name                            type
0x00207ddc  0x8        dis_system_id                            array[8] of uint8_t

address     size       variable name                            type
0x00207e58  0x4        pfn_dis_cb                               P_FUN_SERVER_GENERAL_CB

address     size       variable name                            type
0x008116ec  0x70       bas_attr_tbl                             array[4] of const T_ATTRIB_APPL

address     size       variable name                            type
0x0081175c  0xc        bas_cbs                                  const T_FUN_GATT_SERVICE_CBS
0x0081175c  0x4        bas_cbs.read_attr_cb                     P_FUN_GATT_READ_ATTR_CB
0x00811760  0x4        bas_cbs.write_attr_cb                    P_FUN_GATT_WRITE_ATTR_CB
0x00811764  0x4        bas_cbs.cccd_update_cb                   P_FUN_GATT_CCCD_UPDATE_CB

address     size       variable name                            type
0x00207e51  0x1        bas_read_battery_level_pending           _Bool

address     size       variable name                            type
0x00207e50  0x1        battery_level                            uint8_t

address     size       variable name                            type
0x00207e54  0x4        pfn_bas_cb                               P_FUN_SERVER_GENERAL_CB

address     size       variable name                            type
0x00207d70  0x6c       overlay_sections                         array[3] of T_OVERLAY_SECTION

address     size       variable name                            type
0x00207e48  0x8        scenario_name                            array[8] of char

address     size       variable name                            type
0x00207e46  0x2        g_bas_battery_level                      uint16_t

address     size       variable name                            type
0x00207e44  0x2        g_bat_vol                                uint16_t

address     size       variable name                            type
0x00207e40  0x1        g_switch_into_ota_pending                _Bool

address     size       variable name                            type
0x00207e42  0x1        gap_conn_state                           T_GAP_CONN_STATE

address     size       variable name                            type
0x00207e41  0x1        gap_cur_state                            T_GAP_DEV_STATE
0x00207e41  0x1(7:1)   gap_cur_state.gap_init_state             uint8_t
0x00207e41  0x1(6:1)   gap_cur_state.gap_adv_sub_state          uint8_t
0x00207e41  0x1(4:2)   gap_cur_state.gap_adv_state              uint8_t
0x00207e41  0x1(2:2)   gap_cur_state.gap_scan_state             uint8_t
0x00207e41  0x1(0:2)   gap_cur_state.gap_conn_state             uint8_t

address     size       variable name                            type
0x00207d59  0x10       ADV_DATA                                 array[16] of uint8_t

address     size       variable name                            type
0x00207d55  0x4        SCAN_RSP_DATA                            array[4] of uint8_t

address     size       variable name                            type
0x00207d54  0x1        allowed_ota_enter_dlps                   _Bool

address     size       variable name                            type
0x00207d6c  0x4        app_pre_main_cb                          USER_CALL_BACK

address     size       variable name                            type
0x00207e3d  0x1        g_bas_service_id                         T_SERVER_ID

address     size       variable name                            type
0x00207e3e  0x1        g_dis_service_id                         T_SERVER_ID

address     size       variable name                            type
0x00207e3c  0x1        g_ota_mode                               uint8_t

address     size       variable name                            type
0x00207e3f  0x1        g_ota_service_id                         T_SERVER_ID

address     size       variable name                            type
0x00207e30  0x4        app_task_handle                          pointer to unknown Type 

address     size       variable name                            type
0x00207e34  0x4        evt_queue_handle                         pointer to unknown Type 

address     size       variable name                            type
0x00207e38  0x4        io_queue_handle                          pointer to unknown Type 

address     size       variable name                            type
0x00811588  0x24       app_cb_table                             const T_APP_CB_TABLE
0x00811588  0x4        app_cb_table.app_cb_signature            uint32_t
0x0081158c  0x4        app_cb_table.app_cb_numbers              uint32_t
0x00811590  0x1c       app_cb_table.app_cb_addr                 array[7] of uint32_t

address     size       variable name                            type
0x00207d6c  0x4        app_pre_main_cb                          USER_CALL_BACK

address     size       variable name                            type
0x0080e1e0  0x220      auth_header                              const T_AUTH_HEADER_FORMAT
0x0080e1e0  0x100      auth_header.payload_signature            array[256] of uint8_t
0x0080e2e0  0x10       auth_header.payload_mac                  array[16] of uint8_t
0x0080e2f0  0x100      auth_header.header_signature             array[256] of uint8_t
0x0080e3f0  0x10       auth_header.header_mac                   array[16] of uint8_t

address     size       variable name                            type
0x00207d50  0x4        check_reset_ram                          T_CHECK_RESET_RAM_RECORD
0x00207d50  0x4(8:24)  check_reset_ram.check_reset_ram_pattern  uint32_t
0x00207d50  0x4(0:8)   check_reset_ram.check_reset_ram_type     uint32_t

address     size       variable name                            type
0x0080e000  0x1e0      img_header                               const T_IMG_HEADER_FORMAT
0x0080e000  0xc        img_header.ctrl_header                   T_IMG_CTRL_HEADER_FORMAT
0x0080e000  0x1        img_header.ctrl_header.ic_type           uint8_t
0x0080e001  0x1        img_header.ctrl_header.secure_version    uint8_t
0x0080e002  0x2        img_header.ctrl_header.ctrl_flag         anonymous
0x0080e002  0x2        img_header.ctrl_header.ctrl_flag.value   uint16_t
0x0080e002  0x2        img_header.ctrl_header.ctrl_flag.flag_value anonymous
0x0080e002  0x2(15:1)  img_header.ctrl_header.ctrl_flag.flag_value.xip uint16_t
0x0080e002  0x2(14:1)  img_header.ctrl_header.ctrl_flag.flag_value.enc uint16_t
0x0080e002  0x2(13:1)  img_header.ctrl_header.ctrl_flag.flag_value.load_when_boot uint16_t
0x0080e002  0x2(12:1)  img_header.ctrl_header.ctrl_flag.flag_value.enc_load uint16_t
0x0080e002  0x2(9:3)   img_header.ctrl_header.ctrl_flag.flag_value.enc_key_select uint16_t
0x0080e002  0x2(8:1)   img_header.ctrl_header.ctrl_flag.flag_value.not_ready uint16_t
0x0080e002  0x2(7:1)   img_header.ctrl_header.ctrl_flag.flag_value.not_obsolete uint16_t
0x0080e002  0x2(6:1)   img_header.ctrl_header.ctrl_flag.flag_value.integrity_check_en_in_boot uint16_t
0x0080e002  0x2(0:6)   img_header.ctrl_header.ctrl_flag.flag_value.rsvd uint16_t
0x0080e004  0x2        img_header.ctrl_header.image_id          uint16_t
0x0080e006  0x2        img_header.ctrl_header.crc16             uint16_t
0x0080e008  0x4        img_header.ctrl_header.payload_len       uint32_t
0x0080e00c  0x10       img_header.uuid                          array[16] of uint8_t
0x0080e01c  0x4        img_header.exe_base                      uint32_t
0x0080e020  0x4        img_header.load_base                     uint32_t
0x0080e024  0x4        img_header.load_len                      uint32_t
0x0080e028  0x4        img_header.img_base                      uint32_t
0x0080e02c  0x4        img_header.rsvd0                         array[4] of uint8_t
0x0080e030  0x4        img_header.magic_pattern                 uint32_t
0x0080e034  0x10       img_header.dec_key                       array[16] of uint8_t
0x0080e044  0x1c       img_header.rsvd1                         array[28] of uint8_t
0x0080e060  0x10       img_header.git_ver                       T_VERSION_FORMAT
0x0080e060  0x4        img_header.git_ver.ver_info              anonymous
0x0080e060  0x4        img_header.git_ver.ver_info.version      uint32_t
0x0080e060  0x4        img_header.git_ver.ver_info.sub_version  anonymous
0x0080e060  0x4(28:4)  img_header.git_ver.ver_info.sub_version._version_major uint32_t
0x0080e060  0x4(20:8)  img_header.git_ver.ver_info.sub_version._version_minor uint32_t
0x0080e060  0x4(5:15)  img_header.git_ver.ver_info.sub_version._version_revision uint32_t
0x0080e060  0x4(0:5)   img_header.git_ver.ver_info.sub_version._version_reserve uint32_t
0x0080e064  0x4        img_header.git_ver._version_commitid     uint32_t
0x0080e068  0x8        img_header.git_ver._customer_name        array[8] of uint8_t
0x0080e070  0x104      img_header.rsaPubKey                     T_RSA_PUBLIC_KEY
0x0080e070  0x100      img_header.rsaPubKey.N                   array[256] of uint8_t
0x0080e170  0x4        img_header.rsaPubKey.E                   array[4] of uint8_t
0x0080e174  0x20       img_header.sha256                        array[32] of uint8_t
0x0080e194  0x44       img_header.rsvd2                         array[68] of uint8_t
0x0080e1d8  0x4        img_header.app_cb_signature              uint32_t
0x0080e1dc  0x4        img_header.app_cb_table_base_address     uint32_t

address     size       variable name                            type
0x00207e1c  0x4        random_seed_value                        uint32_t

address     size       variable name                            type
0x00207e10  0x4        user_dfu_status_cb                       BOOL_DFU_STATUS_CB

address     size       variable name                            type
0x00207e14  0x4        user_rtc_handler_cb                      APP_MAIN_FUNC

address     size       variable name                            type
0x00207e0c  0x4        user_wdg_cb                              BOOL_WDG_CB

